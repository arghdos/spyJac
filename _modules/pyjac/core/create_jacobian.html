
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pyjac.core.create_jacobian &#8212; pyJac 2.0.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyjac.core.create_jacobian</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;Creates source code for calculating analytical Jacobian matrix.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Python 2 compatibility</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="c1"># Standard libraries</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">string</span> <span class="k">import</span> <span class="n">Template</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># external</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">loopy</span> <span class="k">as</span> <span class="nn">lp</span>
<span class="kn">from</span> <span class="nn">loopy.kernel.data</span> <span class="k">import</span> <span class="n">AddressSpace</span> <span class="k">as</span> <span class="n">scopes</span>
<span class="kn">from</span> <span class="nn">pytools</span> <span class="k">import</span> <span class="n">UniqueNameGenerator</span>

<span class="c1"># Local imports</span>
<span class="kn">from</span> <span class="nn">pyjac</span> <span class="k">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">pyjac.core</span> <span class="k">import</span> <span class="n">mech_interpret</span> <span class="k">as</span> <span class="n">mech</span>
<span class="kn">from</span> <span class="nn">pyjac.core</span> <span class="k">import</span> <span class="n">rate_subs</span> <span class="k">as</span> <span class="n">rate</span>
<span class="kn">from</span> <span class="nn">pyjac.core</span> <span class="k">import</span> <span class="n">mech_auxiliary</span> <span class="k">as</span> <span class="n">aux</span>
<span class="kn">from</span> <span class="nn">pyjac.core.enum_types</span> <span class="k">import</span> <span class="p">(</span><span class="n">JacobianType</span><span class="p">,</span> <span class="n">JacobianFormat</span><span class="p">,</span>
                                   <span class="n">FiniteDifferenceMode</span><span class="p">,</span> <span class="n">RateSpecialization</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyjac.loopy_utils</span> <span class="k">import</span> <span class="n">loopy_utils</span> <span class="k">as</span> <span class="n">lp_utils</span>
<span class="kn">from</span> <span class="nn">pyjac.loopy_utils</span> <span class="k">import</span> <span class="n">preambles_and_manglers</span> <span class="k">as</span> <span class="n">lp_pregen</span>
<span class="kn">from</span> <span class="nn">pyjac.loopy_utils</span> <span class="k">import</span> <span class="n">load_platform</span>
<span class="kn">from</span> <span class="nn">pyjac.kernel_utils</span> <span class="k">import</span> <span class="n">kernel_gen</span> <span class="k">as</span> <span class="n">k_gen</span>
<span class="kn">from</span> <span class="nn">pyjac.core</span> <span class="k">import</span> <span class="n">array_creator</span> <span class="k">as</span> <span class="n">arc</span>
<span class="kn">from</span> <span class="nn">pyjac.core.enum_types</span> <span class="k">import</span> <span class="n">reaction_type</span><span class="p">,</span> <span class="n">falloff_form</span><span class="p">,</span> <span class="n">thd_body_type</span><span class="p">,</span> \
    <span class="n">KernelType</span>
<span class="kn">from</span> <span class="nn">pyjac.core</span> <span class="k">import</span> <span class="n">chem_model</span> <span class="k">as</span> <span class="n">chem</span>
<span class="kn">from</span> <span class="nn">pyjac.core</span> <span class="k">import</span> <span class="n">instruction_creator</span> <span class="k">as</span> <span class="n">ic</span>
<span class="kn">from</span> <span class="nn">pyjac.core.array_creator</span> <span class="k">import</span> <span class="p">(</span><span class="n">global_ind</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">default_inds</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyjac.core.rate_subs</span> <span class="k">import</span> <span class="n">assign_rates</span>
<span class="kn">from</span> <span class="nn">pyjac.core.exceptions</span> <span class="k">import</span> <span class="n">InvalidInputSpecificationException</span>


<div class="viewcode-block" id="inputs_and_outputs"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.inputs_and_outputs">[docs]</a><span class="k">def</span> <span class="nf">inputs_and_outputs</span><span class="p">(</span><span class="n">conp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A convenience method such that kernel inputs / output argument names are</span>
<span class="sd">    available for inspection</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    conp: bool</span>
<span class="sd">        If true, use constant-pressure formulation, else constant-volume</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    input_args: list of str</span>
<span class="sd">        The input arguments to kernels generated in this file</span>
<span class="sd">    output_args: list of str</span>
<span class="sd">        The output arguments to kernels generated in this file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">input_args</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">kernel_argument_ordering</span><span class="p">(</span>
        <span class="p">[</span><span class="n">arc</span><span class="o">.</span><span class="n">pressure_array</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="n">arc</span><span class="o">.</span><span class="n">volume_array</span><span class="p">,</span> <span class="n">arc</span><span class="o">.</span><span class="n">state_vector</span><span class="p">],</span>
        <span class="n">KernelType</span><span class="o">.</span><span class="n">jacobian</span><span class="p">)</span>
    <span class="n">output_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">arc</span><span class="o">.</span><span class="n">jacobian_array</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">input_args</span><span class="p">,</span> <span class="n">output_args</span></div>


<div class="viewcode-block" id="determine_jac_inds"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.determine_jac_inds">[docs]</a><span class="k">def</span> <span class="nf">determine_jac_inds</span><span class="p">(</span><span class="n">reacs</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">rate_spec</span><span class="p">,</span> <span class="n">jacobian_type</span><span class="o">=</span><span class="n">JacobianType</span><span class="o">.</span><span class="n">exact</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From a given set of reactions, determine the populated jacobian indicies.</span>
<span class="sd">    Additionally, populate the rate information from :meth:`pyjac.core.assign_rates`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reacs : list of `ReacInfo`</span>
<span class="sd">        The reactions in the mechanism</span>
<span class="sd">    specs : list of `SpecInfo`</span>
<span class="sd">        The species in the mechanism</span>
<span class="sd">    rate_spec : `RateSpecialization` enum</span>
<span class="sd">        The specialization option specified</span>
<span class="sd">    JacobianType : :class:`JacobianType`</span>
<span class="sd">        The Jacobian type to be constructed, a full Jacobian has no approximations</span>
<span class="sd">        for reactions including the last species while an approximate Jacobian</span>
<span class="sd">        ignores the contributions from species not involved</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    See also :meth:`pyjac.core.assign_rates`, :class:`JacobianType`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jac_info : dict of parameters</span>
<span class="sd">        Keys are &#39;jac_inds&#39;, which contains:</span>
<span class="sd">            &#39;flat&#39;: a flattened list of non-zero jacobian indicies.</span>
<span class="sd">            &#39;ccs&#39;: a dictionary of &#39;col_ind&#39; and &#39;row_ptr&#39; representing the indicies</span>
<span class="sd">                in a compressed column storage format</span>
<span class="sd">            &#39;crs&#39;: a dictionary of &#39;col_ind&#39; and &#39;row_ptr&#39; representing the indicies</span>
<span class="sd">                in a compressed row storage format</span>

<span class="sd">        Additionally, `jac_info` will contain the results from</span>
<span class="sd">        :meth:`pyjac.core.assign_rates`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">jacobian_type</span> <span class="ow">in</span> <span class="n">JacobianType</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">assign_rates</span><span class="p">(</span><span class="n">reacs</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">rate_spec</span><span class="p">)</span>

    <span class="n">inds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">row_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Ns - 1 species + temperature + extra variable</span>
    <span class="n">species_offset</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># temperature + extra variable</span>

    <span class="k">def</span> <span class="nf">__add_row</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="n">inds</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">row</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row_size</span><span class="p">)])</span>

    <span class="c1"># The first row is all derivatives of the dT/dt term, and no entries are</span>
    <span class="c1"># zero</span>
    <span class="n">__add_row</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># the second row is derivatives of the extra variable, and again is</span>
    <span class="c1"># non-zero</span>
    <span class="n">__add_row</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># From here on out:</span>
    <span class="c1">#</span>
    <span class="c1"># The first entry is the derivative of dnj/dt w.r.t Temperature</span>
    <span class="c1">#       -&gt; this is non-zero if this species has a non-zero net stoich. coeff in</span>
    <span class="c1">#          any reaction</span>
    <span class="c1">#</span>
    <span class="c1"># The second entry is the derivative of dnj/dt w.r.t. the extra variable (P/V)</span>
    <span class="c1">#       -&gt; this is non-zero if this species has a non-zero net stoich. coeff in</span>
    <span class="c1">#          any reaction</span>

    <span class="k">def</span> <span class="nf">__offset</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">)]))),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">arc</span><span class="o">.</span><span class="n">kint_type</span><span class="p">)</span>

    <span class="c1"># get list of species that have a non-zero nu in some reaction</span>
    <span class="n">non_zero_specs</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="s1">&#39;net_per_spec&#39;</span><span class="p">][</span><span class="s1">&#39;map&#39;</span><span class="p">]</span>
    <span class="n">rxn_count</span> <span class="o">=</span> <span class="n">__offset</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="s1">&#39;net_per_spec&#39;</span><span class="p">][</span><span class="s1">&#39;reac_count&#39;</span><span class="p">])</span>
    <span class="n">rxn_maps</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="s1">&#39;net_per_spec&#39;</span><span class="p">][</span><span class="s1">&#39;reacs&#39;</span><span class="p">]</span>
    <span class="n">rxn_to_specs_map</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="s1">&#39;net&#39;</span><span class="p">][</span><span class="s1">&#39;reac_to_spec&#39;</span><span class="p">]</span>
    <span class="n">num_specs_in_rxn</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="s1">&#39;net&#39;</span><span class="p">][</span><span class="s1">&#39;num_reac_to_spec&#39;</span><span class="p">]</span>
    <span class="n">num_specs_in_rxn</span> <span class="o">=</span> <span class="n">__offset</span><span class="p">(</span><span class="n">num_specs_in_rxn</span><span class="p">)</span>
    <span class="n">has_ns</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="s1">&#39;reac_has_ns&#39;</span><span class="p">]</span>
    <span class="n">thd_has_ns</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="s1">&#39;thd&#39;</span><span class="p">][</span><span class="s1">&#39;has_ns&#39;</span><span class="p">]</span>
    <span class="n">thd_spec</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="s1">&#39;thd&#39;</span><span class="p">][</span><span class="s1">&#39;spec&#39;</span><span class="p">]</span>
    <span class="n">thd_eff</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="s1">&#39;thd&#39;</span><span class="p">][</span><span class="s1">&#39;eff&#39;</span><span class="p">]</span>
    <span class="n">thd_map</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="s1">&#39;thd&#39;</span><span class="p">][</span><span class="s1">&#39;map&#39;</span><span class="p">]</span>
    <span class="n">rev_map</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="s1">&#39;rev&#39;</span><span class="p">][</span><span class="s1">&#39;map&#39;</span><span class="p">]</span>
    <span class="n">nu_map</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="s1">&#39;net&#39;</span><span class="p">][</span><span class="s1">&#39;nu&#39;</span><span class="p">]</span>
    <span class="n">num_specs_in_thd</span> <span class="o">=</span> <span class="n">__offset</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="s1">&#39;thd&#39;</span><span class="p">][</span><span class="s1">&#39;spec_num&#39;</span><span class="p">])</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="s1">&#39;Ns&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">non_zero_specs</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">non_zero_specs</span><span class="o">.</span><span class="n">size</span>
    <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">non_zero_specs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># ignore last species derivatives</span>
            <span class="k">continue</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">species_offset</span>
        <span class="n">nonzero_derivs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">__add_specs</span><span class="p">(</span><span class="n">slist</span><span class="p">):</span>
            <span class="c1"># add species to derivative list</span>
            <span class="n">nonzero_derivs</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="n">species_offset</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">slist</span>
                                   <span class="k">if</span> <span class="n">x</span> <span class="o">+</span> <span class="n">species_offset</span> <span class="o">&lt;</span> <span class="n">row_size</span><span class="p">])</span>

        <span class="c1"># add the temperature and extra var derivative</span>
        <span class="c1"># note: this isn&#39;t _technically_ true, e.g., for a irreversible reaction</span>
        <span class="c1"># with b = 0 and Ea = 0, the temperature derivative of the species is zero</span>
        <span class="c1"># however it&#39;s not really worth writing a lot of complicated logic (e.g.,</span>
        <span class="c1"># to test falloff, etc.) to check when it&#39;s true 95+% of the time.</span>
        <span class="n">nonzero_derivs</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># now we go through the reactions for which this species is non-zero</span>
        <span class="n">inner_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">non_zero_specs</span> <span class="o">==</span> <span class="n">spec</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">rxn</span> <span class="ow">in</span> <span class="n">rxn_maps</span><span class="p">[</span><span class="n">rxn_count</span><span class="p">[</span><span class="n">inner_ind</span><span class="p">]:</span><span class="n">rxn_count</span><span class="p">[</span><span class="n">inner_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]:</span>
            <span class="c1"># get third body index</span>
            <span class="n">thd_ind</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">rxn</span> <span class="ow">in</span> <span class="n">thd_map</span><span class="p">:</span>
                <span class="n">thd_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">thd_map</span> <span class="o">==</span> <span class="n">rxn</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># if the last species directly participates in the reaction, and we&#39;re</span>
            <span class="c1"># looking for a full Jacobian, this entire row has non-zero</span>
            <span class="c1"># derivatives</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rxn</span> <span class="ow">in</span> <span class="n">has_ns</span> <span class="ow">or</span> <span class="p">(</span><span class="n">thd_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">thd_ind</span> <span class="ow">in</span> <span class="n">thd_has_ns</span><span class="p">))</span> \
                    <span class="ow">and</span> <span class="n">jacobian_type</span> <span class="o">!=</span> <span class="n">JacobianType</span><span class="o">.</span><span class="n">approximate</span><span class="p">:</span>
                <span class="n">__add_specs</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">row_size</span><span class="p">))</span>
                <span class="k">break</span>

            <span class="c1"># test reversible</span>
            <span class="n">deriv_specs</span> <span class="o">=</span> <span class="n">rxn_to_specs_map</span><span class="p">[</span>
                <span class="n">num_specs_in_rxn</span><span class="p">[</span><span class="n">rxn</span><span class="p">]:</span><span class="n">num_specs_in_rxn</span><span class="p">[</span><span class="n">rxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">rev</span> <span class="o">=</span> <span class="n">rxn</span> <span class="ow">in</span> <span class="n">rev_map</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">rev</span><span class="p">:</span>
                <span class="c1"># forward irreversible -- need to look at nu</span>
                <span class="n">nu</span> <span class="o">=</span> <span class="n">nu_map</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_specs_in_rxn</span><span class="p">[</span><span class="n">rxn</span><span class="p">]:</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_specs_in_rxn</span><span class="p">[</span><span class="n">rxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="n">is_prod</span> <span class="o">=</span> <span class="p">[</span><span class="n">nu</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">deriv_specs</span><span class="p">))]</span>
                <span class="n">is_reac</span> <span class="o">=</span> <span class="p">[</span><span class="n">nu</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">deriv_specs</span><span class="p">))]</span>
                <span class="c1"># find out which this species is</span>
                <span class="n">spec_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">deriv_specs</span> <span class="o">==</span> <span class="n">spec</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">is_prod</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">]</span> <span class="ow">and</span> <span class="n">is_reac</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">]:</span>
                    <span class="c1"># both product and reactant, all species contribute to derivative</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># only reactants contribute to the derivative</span>
                    <span class="n">deriv_specs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">deriv_specs</span><span class="p">)</span>
                                   <span class="k">if</span> <span class="n">is_reac</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

            <span class="c1"># update species in the reaction</span>
            <span class="n">__add_specs</span><span class="p">(</span><span class="n">deriv_specs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">thd_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># update third body species in the reaction where the efficiency</span>
                <span class="c1"># is not equal to that of the last species</span>
                <span class="n">last_spec_eff</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="c1"># get species</span>
                <span class="n">third_body_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_specs_in_thd</span><span class="p">[</span>
                    <span class="n">thd_ind</span><span class="p">],</span> <span class="n">num_specs_in_thd</span><span class="p">[</span><span class="n">thd_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">third_body_species</span> <span class="o">=</span> <span class="n">thd_spec</span><span class="p">[</span><span class="n">third_body_inds</span><span class="p">]</span>
                <span class="c1"># and efficiencies</span>
                <span class="n">third_body_eff</span> <span class="o">=</span> <span class="n">thd_eff</span><span class="p">[</span><span class="n">third_body_inds</span><span class="p">]</span>
                <span class="c1"># check for ns in third body to get right efficiency</span>
                <span class="k">if</span> <span class="n">ns</span> <span class="ow">in</span> <span class="n">third_body_species</span><span class="p">:</span>
                    <span class="n">last_spec_eff</span> <span class="o">=</span> <span class="n">third_body_eff</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">third_body_species</span> <span class="o">==</span> <span class="n">ns</span><span class="p">)]</span>
                <span class="c1"># now filter based on efficiencies</span>
                <span class="n">__add_specs</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">third_body_species</span><span class="p">)</span>
                             <span class="k">if</span> <span class="n">third_body_eff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">last_spec_eff</span><span class="p">])</span>

        <span class="c1"># finally add the non-zero derivatives</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonzero_derivs</span><span class="p">):</span>
            <span class="n">inds</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">row</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nonzero_derivs</span><span class="p">)])</span>

    <span class="c1"># get the compressed storage</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">inds</span><span class="p">)</span>

    <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arc</span><span class="o">.</span><span class="n">kint_type</span><span class="p">)</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arc</span><span class="o">.</span><span class="n">kint_type</span><span class="p">)</span>

    <span class="c1"># get a column-major version for flat inds</span>
    <span class="n">inds_F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cols</span><span class="p">)):</span>
        <span class="c1"># find the rows that contains this col</span>
        <span class="n">row_F</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cols</span> <span class="o">==</span> <span class="n">col</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="c1"># place in inds</span>
        <span class="n">inds_F</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="n">row_F</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">(</span><span class="n">row_F</span><span class="p">,</span> <span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">*</span> <span class="n">row_F</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arc</span><span class="o">.</span><span class="n">kint_type</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="n">row_F</span><span class="o">.</span><span class="n">size</span>

    <span class="c1"># turn into row and column counts</span>
    <span class="n">row_ptr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">col_ind</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">col_ptr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">row_ind</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row_size</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">in_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rows</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">row_ptr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">in_row</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">col_ind</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="n">in_row</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">in_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cols</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">col_ptr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">in_col</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">row_ind</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="n">in_col</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="c1"># update indicies in return value</span>
    <span class="n">val</span><span class="p">[</span><span class="s1">&#39;jac_inds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;flat_C&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arc</span><span class="o">.</span><span class="n">kint_type</span><span class="p">),</span>
        <span class="s1">&#39;flat_F&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">inds_F</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arc</span><span class="o">.</span><span class="n">kint_type</span><span class="p">),</span>
        <span class="s1">&#39;crs&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;col_ind&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">col_ind</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arc</span><span class="o">.</span><span class="n">kint_type</span><span class="p">),</span>
                <span class="s1">&#39;row_ptr&#39;</span><span class="p">:</span> <span class="n">__offset</span><span class="p">(</span><span class="n">row_ptr</span><span class="p">)},</span>
        <span class="s1">&#39;ccs&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;row_ind&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">row_ind</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arc</span><span class="o">.</span><span class="n">kint_type</span><span class="p">),</span>
                <span class="s1">&#39;col_ptr&#39;</span><span class="p">:</span> <span class="n">__offset</span><span class="p">(</span><span class="n">col_ptr</span><span class="p">)}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="reset_arrays"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.reset_arrays">[docs]</a><span class="k">def</span> <span class="nf">reset_arrays</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Resets the Jacobian array for use in the evaluations</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator for both</span>
<span class="sd">        equation types</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># first, create all arrays</span>
    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># add problem size</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">jac_format</span> <span class="o">==</span> <span class="n">JacobianFormat</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
        <span class="c1"># simply loop over the whole jacobian array</span>
        <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_nonzero_jac_inds</span><span class="p">,</span>
                                <span class="n">test_size</span><span class="p">)</span>
        <span class="n">jac_lp</span><span class="p">,</span> <span class="n">jac_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span>
                                              <span class="n">ignore_lookups</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                ${jac_str} = 0d {id=reset}</span>
<span class="sd">            &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

        <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">jac_lp</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># simply loop over the whole jacobian array</span>
        <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac_size</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>
        <span class="c1"># need jac_array</span>
        <span class="n">row</span> <span class="o">=</span> <span class="s1">&#39;row&#39;</span>
        <span class="n">col</span> <span class="o">=</span> <span class="s1">&#39;col&#39;</span>
        <span class="n">row_size</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">var_name</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">jac_type</span> <span class="o">==</span> <span class="n">JacobianType</span><span class="o">.</span><span class="n">finite_difference</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ignore_lookups&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">jac_lp</span><span class="p">,</span> <span class="n">jac_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span>
                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            &lt;&gt; ${row} = ${i} // ${row_size}</span>
<span class="sd">            &lt;&gt; ${col} = ${i} % ${row_size}</span>
<span class="sd">            ${jac_str} = 0d {id=reset}</span>
<span class="sd">            &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

        <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">jac_lp</span><span class="p">])</span>

    <span class="c1"># add arrays</span>
    <span class="n">can_vectorize</span><span class="p">,</span> <span class="n">vec_spec</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_deep_specializer</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">init_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;reset&#39;</span><span class="p">],</span> <span class="n">is_write_race</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="c1"># for FD jacobian, no need for atomics</span>
        <span class="n">atomic</span><span class="o">=</span><span class="n">loopy_opts</span><span class="o">.</span><span class="n">jac_type</span> <span class="o">!=</span> <span class="n">JacobianType</span><span class="o">.</span><span class="n">finite_difference</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;reset_arrays&#39;</span><span class="p">,</span>
                          <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
                          <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
                          <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
                          <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
                          <span class="n">can_vectorize</span><span class="o">=</span><span class="n">can_vectorize</span><span class="p">,</span>
                          <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">vec_spec</span><span class="p">)</span></div>


<span class="nd">@ic</span><span class="o">.</span><span class="n">with_conditional_jacobian</span>
<span class="k">def</span> <span class="nf">__dcidE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">rxn_type</span><span class="o">=</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jac_create</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the pressure modification term for all third body /</span>
<span class="sd">    falloff / chemically activated reactions with respect to the extra variable</span>
<span class="sd">    (volume / pressure) for constant pressure/volume respectively</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    rxn_type: [reaction_type.thd, falloff_form.lind, falloff_form.sri,</span>
<span class="sd">               falloff_form.troe]</span>
<span class="sd">        The reaction type to generate the pressure modification derivative for</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>
<span class="sd">    jac_create: Callable</span>
<span class="sd">        The conditional Jacobian instruction creator from :mod:`instruction_creator`</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="n">num_range_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_thd_only</span><span class="p">,</span>
                      <span class="n">falloff_form</span><span class="o">.</span><span class="n">lind</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_lind</span><span class="p">,</span>
                      <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_sri</span><span class="p">,</span>
                      <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_troe</span><span class="p">}</span>
    <span class="n">thd_range_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">thd_only_map</span><span class="p">,</span>
                      <span class="n">falloff_form</span><span class="o">.</span><span class="n">lind</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">fall_to_thd_map</span><span class="p">,</span>
                      <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">fall_to_thd_map</span><span class="p">,</span>
                      <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">fall_to_thd_map</span><span class="p">}</span>
    <span class="n">fall_range_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">falloff_form</span><span class="o">.</span><span class="n">lind</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">lind_map</span><span class="p">,</span>
                       <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">sri_map</span><span class="p">,</span>
                       <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">troe_map</span><span class="p">}</span>
    <span class="n">name_description</span> <span class="o">=</span> <span class="p">{</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span><span class="p">:</span> <span class="s1">&#39;thd&#39;</span><span class="p">,</span>
                        <span class="n">falloff_form</span><span class="o">.</span><span class="n">lind</span><span class="p">:</span> <span class="s1">&#39;lind&#39;</span><span class="p">,</span>
                        <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">:</span> <span class="s1">&#39;sri&#39;</span><span class="p">,</span>
                        <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">:</span> <span class="s1">&#39;troe&#39;</span><span class="p">}</span>
    <span class="c1"># get num</span>
    <span class="n">num_range</span> <span class="o">=</span> <span class="n">num_range_dict</span><span class="p">[</span><span class="n">rxn_type</span><span class="p">]</span>
    <span class="n">thd_range</span> <span class="o">=</span> <span class="n">thd_range_dict</span><span class="p">[</span><span class="n">rxn_type</span><span class="p">]</span>
    <span class="n">rxn_range</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">thd_map</span>

    <span class="c1"># number of species</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># create mapstore</span>
    <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">num_range</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>

    <span class="c1"># setup static mappings</span>

    <span class="k">if</span> <span class="n">rxn_type</span> <span class="ow">in</span> <span class="n">fall_range_dict</span><span class="p">:</span>
        <span class="n">fall_range</span> <span class="o">=</span> <span class="n">fall_range_dict</span><span class="p">[</span><span class="n">rxn_type</span><span class="p">]</span>

        <span class="c1"># falloff index depends on num_range</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">fall_range</span><span class="p">,</span> <span class="n">num_range</span><span class="p">)</span>

        <span class="c1"># and the third body index depends on the falloff index</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">thd_range</span><span class="p">,</span> <span class="n">fall_range</span><span class="p">)</span>

    <span class="c1"># and finally the reaction index depends on the third body index</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">rxn_range</span><span class="p">,</span> <span class="n">thd_range</span><span class="p">)</span>

    <span class="c1"># setup third body stuff</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">thd_type</span><span class="p">,</span> <span class="n">thd_range</span><span class="p">)</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">thd_offset</span><span class="p">,</span> <span class="n">thd_range</span><span class="p">)</span>

    <span class="c1"># and place rop&#39;s / species maps, etc.</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rop_fwd</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rop_rev</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">)</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>

    <span class="c1"># pressure mod term</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span> <span class="n">thd_range</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rxn_type</span> <span class="o">!=</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span><span class="p">:</span>
        <span class="c1"># falloff type</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">fall_type</span><span class="p">,</span> <span class="n">fall_range</span><span class="p">)</span>
        <span class="c1"># need falloff blending / reduced pressure</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Fi</span><span class="p">,</span> <span class="n">fall_range</span><span class="p">)</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Pr</span><span class="p">,</span> <span class="n">fall_range</span><span class="p">)</span>

        <span class="c1"># in addition we (most likely) need the falloff / regular kf rates</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kf</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kf_fall</span><span class="p">,</span> <span class="n">fall_range</span><span class="p">)</span>

    <span class="c1"># get the third body types</span>
    <span class="n">thd_type_lp</span><span class="p">,</span> <span class="n">thd_type_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_type</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
    <span class="n">thd_offset_lp</span><span class="p">,</span> <span class="n">thd_offset_next_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_offset</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># get third body efficiencies &amp; species</span>
    <span class="n">thd_eff_lp</span><span class="p">,</span> <span class="n">thd_eff_last_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_eff</span><span class="p">,</span> <span class="n">thd_offset_next_str</span><span class="p">,</span> <span class="n">affine</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">thd_spec_lp</span><span class="p">,</span> <span class="n">thd_spec_last_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_spec</span><span class="p">,</span> <span class="n">thd_offset_next_str</span><span class="p">,</span> <span class="n">affine</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">k_ind</span> <span class="o">=</span> <span class="s1">&#39;k_ind&#39;</span>
    <span class="c1"># nu offsets</span>
    <span class="n">nu_offset_lp</span><span class="p">,</span> <span class="n">offset_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">offset_next_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># setup species k loop</span>
    <span class="n">extra_inames</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k_ind</span><span class="p">,</span> <span class="s1">&#39;offset &lt;= </span><span class="si">{}</span><span class="s1"> &lt; offset_next&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k_ind</span><span class="p">))]</span>

    <span class="c1"># reac and prod nu for net</span>
    <span class="n">nu_lp</span><span class="p">,</span> <span class="n">reac_nu_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_reac_nu</span><span class="p">,</span> <span class="n">k_ind</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">k_ind</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">prod_nu_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_prod_nu</span><span class="p">,</span> <span class="n">k_ind</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">k_ind</span><span class="p">)</span>
    <span class="c1"># get species</span>
    <span class="n">spec_lp</span><span class="p">,</span> <span class="n">spec_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec</span><span class="p">,</span> <span class="n">k_ind</span><span class="p">)</span>

    <span class="c1"># ropnet</span>
    <span class="n">rop_fwd_lp</span><span class="p">,</span> <span class="n">rop_fwd_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rop_fwd</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
    <span class="n">rop_rev_lp</span><span class="p">,</span> <span class="n">rop_rev_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rop_rev</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

    <span class="c1"># T, P, V</span>
    <span class="n">T_lp</span><span class="p">,</span> <span class="n">T_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">T_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">V_lp</span><span class="p">,</span> <span class="n">V_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">V_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">P_lp</span><span class="p">,</span> <span class="n">P_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">P_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">pres_mod_lp</span><span class="p">,</span> <span class="n">pres_mod_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

    <span class="c1"># update kernel data</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">thd_type_lp</span><span class="p">,</span> <span class="n">thd_offset_lp</span><span class="p">,</span> <span class="n">thd_eff_lp</span><span class="p">,</span> <span class="n">thd_spec_lp</span><span class="p">,</span>
                        <span class="n">nu_offset_lp</span><span class="p">,</span> <span class="n">nu_lp</span><span class="p">,</span> <span class="n">spec_lp</span><span class="p">,</span> <span class="n">rop_fwd_lp</span><span class="p">,</span> <span class="n">rop_rev_lp</span><span class="p">,</span>
                        <span class="n">pres_mod_lp</span><span class="p">,</span> <span class="n">T_lp</span><span class="p">,</span> <span class="n">V_lp</span><span class="p">,</span> <span class="n">P_lp</span><span class="p">])</span>

    <span class="n">mix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">thd_body_type</span><span class="o">.</span><span class="n">mix</span><span class="p">)</span>
    <span class="n">spec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">thd_body_type</span><span class="o">.</span><span class="n">species</span><span class="p">)</span>
    <span class="n">unity</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">thd_body_type</span><span class="o">.</span><span class="n">unity</span><span class="p">)</span>

    <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Ru&#39;</span><span class="p">:</span> <span class="n">chem</span><span class="o">.</span><span class="n">RU</span><span class="p">}</span>
    <span class="n">pre_instructions</span> <span class="o">=</span> <span class="p">[</span><span class="n">Template</span><span class="p">(</span>
        <span class="s1">&#39;&lt;&gt; rt_inv = 1 / (Ru * $</span><span class="si">{T_str}</span><span class="s1">)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())]</span>
    <span class="c1"># the factor to multiply the &#39;factor&#39; term by for updat</span>
    <span class="n">fac_term</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;* rt_inv * </span><span class="si">{}</span><span class="s1"> * rop_net &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">V_str</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">conp</span> <span class="k">else</span> <span class="s1">&#39; * rop_net&#39;</span><span class="p">)</span>
    <span class="c1"># the k0 / kinf factor</span>
    <span class="n">manglers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># by default we are using the third body factors (these may be changed</span>
    <span class="c1"># in the falloff types below)</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="s1">&#39;dci_thd_dE_fac&#39;</span>
    <span class="c1"># the pressure modification term to use (pres_mod for thd, Pr for falloff)</span>
    <span class="n">fall_instructions</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="c1"># create a precomputed instruction generator</span>
    <span class="n">precompute</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">PrecomputedInstructions</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">rxn_type</span> <span class="o">!=</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span><span class="p">:</span>
        <span class="c1"># update factors</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="s1">&#39;dci_fall_dE&#39;</span>
        <span class="c1"># create arrays</span>
        <span class="n">fall_type_lp</span><span class="p">,</span> <span class="n">fall_type_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">fall_type</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
        <span class="n">Fi_lp</span><span class="p">,</span> <span class="n">Fi_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Fi</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">Pr_lp</span><span class="p">,</span> <span class="n">Pr_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Pr</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="c1"># set the pmod factor</span>
        <span class="n">kf_lp</span><span class="p">,</span> <span class="n">kf_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kf</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">kf_fall_lp</span><span class="p">,</span> <span class="n">kf_fall_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">kf_fall</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

        <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pres_mod_lp</span><span class="p">,</span> <span class="n">fall_type_lp</span><span class="p">,</span> <span class="n">Fi_lp</span><span class="p">,</span> <span class="n">Pr_lp</span><span class="p">,</span> <span class="n">kf_lp</span><span class="p">,</span>
                            <span class="n">kf_fall_lp</span><span class="p">])</span>

        <span class="c1"># factor used for the Theta_Pr part of conp Pr derivative</span>
        <span class="n">fall_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
            <span class="s1">&#39;&lt;int32&gt; not_unity = $</span><span class="si">{thd_type_str}</span><span class="s1"> != $</span><span class="si">{unity}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span>
            <span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
        <span class="n">conp_theta_pr_fac</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s1">&#39;- $</span><span class="si">{Pr_str}</span><span class="s1"> * not_unity&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span>
            <span class="o">**</span><span class="nb">locals</span><span class="p">())</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># check for Troe / SRI</span>
        <span class="k">if</span> <span class="n">rxn_type</span> <span class="o">==</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">:</span>
            <span class="n">Atroe_lp</span><span class="p">,</span> <span class="n">Atroe_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">Atroe</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
            <span class="n">Btroe_lp</span><span class="p">,</span> <span class="n">Btroe_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">Btroe</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
            <span class="n">Fcent_lp</span><span class="p">,</span> <span class="n">Fcent_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">Fcent</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
            <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">Atroe_lp</span><span class="p">,</span> <span class="n">Btroe_lp</span><span class="p">,</span> <span class="n">Fcent_lp</span><span class="p">])</span>
            <span class="n">dFi_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                &lt;&gt; absqsq = $</span><span class="si">{Atroe_str}</span><span class="s2"> * $</span><span class="si">{Atroe_str}</span><span class="s2"> + </span><span class="se">\</span>
<span class="s2">                    $</span><span class="si">{Btroe_str}</span><span class="s2"> * $</span><span class="si">{Btroe_str}</span><span class="s2"> {id=ab_init}</span>
<span class="s2">                absqsq = absqsq * absqsq {id=ab_fin, dep=ab_init}</span>
<span class="s2">                &lt;&gt; dFi = -2 * $</span><span class="si">{Atroe_str}</span><span class="s2"> * $</span><span class="si">{Btroe_str}</span><span class="s2"> * log($</span><span class="si">{Fcent_str}</span><span class="s2">) </span><span class="se">\</span>
<span class="s2">                * (0.14 * $</span><span class="si">{Atroe_str}</span><span class="s2"> + $</span><span class="si">{Btroe_str}</span><span class="s2">) * </span><span class="se">\</span>
<span class="s2">                (mod $</span><span class="si">{conp_theta_pr_fac}</span><span class="s2">) / </span><span class="se">\</span>
<span class="s2">                (fmax(1e-300d, $</span><span class="si">{Pr_str}</span><span class="s2">) * absqsq * logten) </span><span class="se">\</span>
<span class="s2">                    {id=dFi_final, dep=ab_fin:mod_final}</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
            <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;logten&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">manglers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lp_pregen</span><span class="o">.</span><span class="n">fmax</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">rxn_type</span> <span class="o">==</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">:</span>
            <span class="n">X_lp</span><span class="p">,</span> <span class="n">X_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">X_sri</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
            <span class="n">a_lp</span><span class="p">,</span> <span class="n">a_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">sri_a</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">b_lp</span><span class="p">,</span> <span class="n">b_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">sri_b</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">c_lp</span><span class="p">,</span> <span class="n">c_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">sri_c</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">X_lp</span><span class="p">,</span> <span class="n">a_lp</span><span class="p">,</span> <span class="n">b_lp</span><span class="p">,</span> <span class="n">c_lp</span><span class="p">])</span>
            <span class="n">pre_instructions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">precompute</span><span class="p">(</span><span class="s1">&#39;Tval&#39;</span><span class="p">,</span> <span class="n">T_str</span><span class="p">,</span> <span class="s1">&#39;VAL&#39;</span><span class="p">))</span>
            <span class="n">pre_instructions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">precompute</span><span class="p">(</span><span class="s1">&#39;Tinv&#39;</span><span class="p">,</span> <span class="n">T_str</span><span class="p">,</span> <span class="s1">&#39;INV&#39;</span><span class="p">))</span>
            <span class="n">manglers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lp_pregen</span><span class="o">.</span><span class="n">fmax</span><span class="p">())</span>

            <span class="n">sri_fac</span> <span class="o">=</span> <span class="p">(</span><span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                log(($</span><span class="si">{a_str}</span><span class="s2"> * exp(Tval * cinv) + exp($</span><span class="si">{b_str}</span><span class="s2"> * Tinv)) * </span><span class="se">\</span>
<span class="s2">                     exp(-$</span><span class="si">{b_str}</span><span class="s2"> * Tinv - Tval * cinv))</span><span class="se">\</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                log($</span><span class="si">{a_str}</span><span class="s2"> * exp(-$</span><span class="si">{b_str}</span><span class="s2"> * Tinv) + exp(-Tval * cinv))</span><span class="se">\</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span>
                <span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
            <span class="n">dFi_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                &lt;&gt; cinv = 1 / $</span><span class="si">{c_str}</span><span class="s2"></span>
<span class="s2">                &lt;&gt; dFi = -2 * $</span><span class="si">{X_str}</span><span class="s2"> * $</span><span class="si">{X_str}</span><span class="s2"> * (</span><span class="se">\</span>
<span class="s2">                    mod $</span><span class="si">{conp_theta_pr_fac}</span><span class="s2">) * $</span><span class="si">{sri_fac}</span><span class="s2"> * </span><span class="se">\</span>
<span class="s2">                    log(fmax(1e-300d, $</span><span class="si">{Pr_str}</span><span class="s2">)) / </span><span class="se">\</span>
<span class="s2">                    (fmax(1e-300d, $</span><span class="si">{Pr_str}</span><span class="s2">) * logtensquared) </span><span class="se">\</span>
<span class="s2">                        {id=dFi_final, dep=mod_final}</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
            <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;logtensquared&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dFi_instructions</span> <span class="o">=</span> <span class="s1">&#39;&lt;&gt; dFi = 0 {id=dFi_final}&#39;</span>

        <span class="c1"># the theta_Pr term that appears inside the pressure modification</span>
        <span class="c1"># term.  We simplify it to this to put in the falloff (non-chemically</span>
        <span class="c1"># activated) if statement</span>
        <span class="n">conp_theta_pr_outer_fac</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
            <span class="s1">&#39;- not_unity * $</span><span class="si">{pres_mod_str}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span>
            <span class="o">**</span><span class="nb">locals</span><span class="p">())</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="c1"># change the sign on this factor</span>
        <span class="n">conp_theta_pr_fac</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s1">&#39; + $</span><span class="si">{Pr_str}</span><span class="s1"> * not_unity&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span>
            <span class="o">**</span><span class="nb">locals</span><span class="p">())</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">fall_finish</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> * rop_net &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">V_str</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">conp</span> <span class="k">else</span> \
            <span class="s1">&#39; rop_net&#39;</span>
        <span class="n">Pfac</span> <span class="o">=</span> <span class="s1">&#39; * &#39;</span> <span class="o">+</span> <span class="n">P_str</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">fall_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        $</span><span class="si">{fall_instructions}</span><span class="s2"></span>
<span class="s2">        if $</span><span class="si">{fall_type_str}</span><span class="s2"></span>
<span class="s2">            # chemically activated</span>
<span class="s2">            &lt;&gt;kf_0 = $</span><span class="si">{kf_str}</span><span class="s2"> {id=kf_chem , nosync=kf_fall}</span>
<span class="s2">            &lt;&gt;kf_inf = $</span><span class="si">{kf_fall_str}</span><span class="s2"> {id=kf_inf_chem, nosync=kf_inf_fall}</span>
<span class="s2">        else</span>
<span class="s2">            # fall-off</span>
<span class="s2">            kf_0 = $</span><span class="si">{kf_fall_str}</span><span class="s2"> {id=kf_fall, nosync=kf_chem}</span>
<span class="s2">            kf_inf = $</span><span class="si">{kf_str}</span><span class="s2"> {id=kf_inf_fall, nosync=kf_inf_chem}</span>
<span class="s2">        end</span>
<span class="s2">        mod = mod$</span><span class="si">{Pfac}</span><span class="s2"> * rt_inv * kf_0 / </span><span class="se">\</span>
<span class="s2">            kf_inf {id=mod_final, dep=kf*:mod_mix:mod_spec}</span>
<span class="s2">        $</span><span class="si">{dFi_instructions}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; dci_fall_dE = $</span><span class="si">{pres_mod_str}</span><span class="s2"> * </span><span class="se">\</span>
<span class="s2">            ((-mod$</span><span class="si">{conp_theta_pr_fac}</span><span class="s2">)/ ($</span><span class="si">{Pr_str}</span><span class="s2"> + 1) + </span><span class="se">\</span>
<span class="s2">                dFi) {id=dci_fall_init, dep=mod_final}</span>
<span class="s2">        if not $</span><span class="si">{fall_type_str}</span><span class="s2"></span>
<span class="s2">            # falloff</span>
<span class="s2">            dci_fall_dE = dci_fall_dE + $</span><span class="si">{Fi_str}</span><span class="s2"> * mod / ($</span><span class="si">{Pr_str}</span><span class="s2"> + 1) </span><span class="se">\</span>
<span class="s2">                $</span><span class="si">{conp_theta_pr_outer_fac}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                {id=dci_fall_up1, dep=dci_fall_init:mod_final}</span>
<span class="s2">        end</span>
<span class="s2">        dci_fall_dE = dci_fall_dE * $</span><span class="si">{fall_finish}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">            {id=dci_fall_final, dep=dci_fall_up1:rop_net_up}</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="n">rop_net_rev_update</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_update_instruction</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">rop_rev</span><span class="p">,</span>
        <span class="n">Template</span><span class="p">(</span>
            <span class="s1">&#39;rop_net = rop_net - $</span><span class="si">{rop_rev_str}</span><span class="s1"> </span><span class="se">\</span>
<span class="s1">                        {id=rop_net_up, dep=rop_net_init}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span>
            <span class="o">**</span><span class="nb">locals</span><span class="p">()))</span>

    <span class="c1"># need to update mod term by subtracting off either pres_mod or Pr</span>
    <span class="c1"># for conp-third body or falloff respectively</span>
    <span class="n">fall_deps</span> <span class="o">=</span> <span class="s1">&#39;:kf*&#39;</span> <span class="k">if</span> <span class="n">rxn_type</span> <span class="o">!=</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
    <span class="n">mod_update</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    if $</span><span class="si">{thd_type_str}</span><span class="s2"> != $</span><span class="si">{unity}</span><span class="s2"></span>
<span class="s2">        mod = mod * $</span><span class="si">{P_str}</span><span class="s2"> * rt_inv - $</span><span class="si">{pres_mod_str}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">            {id=mod_up, dep=mod_mix:mod_spec$</span><span class="si">{fall_deps}</span><span class="s2">}</span>
<span class="s2">    end</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span> <span class="k">if</span> <span class="n">conp</span> <span class="ow">and</span> <span class="n">rxn_type</span> <span class="o">==</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span>\
        <span class="k">else</span> <span class="s1">&#39;&#39;</span>

    <span class="c1"># mod term initialization depends on conp / conv</span>
    <span class="n">mod_init</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    &lt;&gt; mod = $</span><span class="si">{thd_type_str}</span><span class="s2"> == $</span><span class="si">{mix}</span><span class="s2"> {id=mod_init}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="p">(</span>
        <span class="s1">&#39;&lt;&gt; mod = 1 {id=mod_init}&#39;</span><span class="p">)</span>

    <span class="c1"># set the third body factor for the reactions (thd only)</span>
    <span class="n">thd_factor_set</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
        <span class="s1">&#39;&lt;&gt; dci_thd_dE_fac = mod$</span><span class="si">{fac_term}</span><span class="s1"> </span><span class="se">\</span>
<span class="s1">        {id=dci_thd_init, dep=mod*:rop_net*}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span>
        <span class="o">**</span><span class="nb">locals</span><span class="p">())</span> <span class="k">if</span> <span class="n">rxn_type</span> <span class="o">==</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

    <span class="c1"># set up third body only instruction</span>
    <span class="c1"># (which get the Pr deriv for falloff)</span>
    <span class="n">thd_mod_insns</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    $</span><span class="si">{mod_init}</span><span class="s2"></span>
<span class="s2">    if $</span><span class="si">{thd_type_str}</span><span class="s2"> == $</span><span class="si">{mix}</span><span class="s2"> and $</span><span class="si">{thd_spec_last_str}</span><span class="s2"> == $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">        mod = $</span><span class="si">{thd_eff_last_str}</span><span class="s2"> {id=mod_mix, dep=mod_init, nosync=mod_spec}</span>
<span class="s2">    end</span>
<span class="s2">    if $</span><span class="si">{thd_type_str}</span><span class="s2"> == $</span><span class="si">{spec}</span><span class="s2"></span>
<span class="s2">        mod = $</span><span class="si">{thd_spec_last_str}</span><span class="s2"> == $</span><span class="si">{ns}</span><span class="s2"> {id=mod_spec, dep=mod_init, </span><span class="se">\</span>
<span class="s2">            nosync=mod_mix}</span>
<span class="s2">    end</span>
<span class="s2">    $</span><span class="si">{mod_update}</span><span class="s2"></span>
<span class="s2">    $</span><span class="si">{thd_factor_set}</span><span class="s2"></span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="c1"># and jac</span>
    <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
        <span class="s2">&quot;$</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + ($</span><span class="si">{prod_nu_k_str}</span><span class="s2"> - $</span><span class="si">{reac_nu_k_str}</span><span class="s2">) * &quot;</span>
        <span class="s2">&quot;$</span><span class="si">{factor}</span><span class="s2"> {id=jac, dep=$</span><span class="si">{deps}</span><span class="s2">}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">jac_lp</span><span class="p">,</span> <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">spec_k_str</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">spec_k_str</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="n">insn</span><span class="o">=</span><span class="n">jac_update_insn</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;dci_*&#39;</span><span class="p">)</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jac_lp</span><span class="p">)</span>

    <span class="c1"># and instructions</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    &lt;&gt; rop_net = $</span><span class="si">{rop_fwd_str}</span><span class="s2"> {id=rop_net_init}</span>
<span class="s2">    $</span><span class="si">{rop_net_rev_update}</span><span class="s2"></span>
<span class="s2">    $</span><span class="si">{thd_mod_insns}</span><span class="s2"></span>
<span class="s2">    $</span><span class="si">{fall_instructions}</span><span class="s2"></span>
<span class="s2">    &lt;&gt; offset = $</span><span class="si">{offset_str}</span><span class="s2"></span>
<span class="s2">    &lt;&gt; offset_next = $</span><span class="si">{offset_next_str}</span><span class="s2"></span>
<span class="s2">    for $</span><span class="si">{k_ind}</span><span class="s2"></span>
<span class="s2">        if $</span><span class="si">{spec_k_str}</span><span class="s2"> != $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">            $</span><span class="si">{jac_update_insn}</span><span class="s2"></span>
<span class="s2">        end</span>
<span class="s2">    end</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">()))</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="n">can_vectorize</span><span class="p">,</span> <span class="n">vec_spec</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_deep_specializer</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">atomic_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;dci_</span><span class="si">{}</span><span class="s1">_dE&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">name_description</span><span class="p">[</span><span class="n">rxn_type</span><span class="p">]),</span>
        <span class="n">extra_inames</span><span class="o">=</span><span class="n">extra_inames</span><span class="p">,</span>
        <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
        <span class="n">pre_instructions</span><span class="o">=</span><span class="n">pre_instructions</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
        <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
        <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
        <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
        <span class="n">manglers</span><span class="o">=</span><span class="n">manglers</span><span class="p">,</span>
        <span class="n">can_vectorize</span><span class="o">=</span><span class="n">can_vectorize</span><span class="p">,</span>
        <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">vec_spec</span>
    <span class="p">)</span>


<div class="viewcode-block" id="dci_thd_dE"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dci_thd_dE">[docs]</a><span class="k">def</span> <span class="nf">dci_thd_dE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the pressure modification term of third body reactions</span>
<span class="sd">    w.r.t. the extra variable (volume / pressure) for constant pressure/volume</span>
<span class="sd">    respectively</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See :meth:`pyjac.core.create_jacobian.__dcidE`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">__dcidE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span>
                                <span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="dci_lind_dE"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dci_lind_dE">[docs]</a><span class="k">def</span> <span class="nf">dci_lind_dE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the pressure modification term of Lindemann falloff</span>
<span class="sd">    reactions w.r.t. the extra variable (volume / pressure)</span>
<span class="sd">    for constant pressure/volume respectively</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See :meth:`pyjac.core.create_jacobian.__dcidE`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">__dcidE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span>
                                <span class="n">falloff_form</span><span class="o">.</span><span class="n">lind</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="dci_troe_dE"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dci_troe_dE">[docs]</a><span class="k">def</span> <span class="nf">dci_troe_dE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the pressure modification term of Troe falloff</span>
<span class="sd">    reactions w.r.t. the extra variable (volume / pressure)</span>
<span class="sd">    for constant pressure/volume respectively</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See :meth:`pyjac.core.create_jacobian.__dcidE`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">__dcidE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span>
                                <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="dci_sri_dE"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dci_sri_dE">[docs]</a><span class="k">def</span> <span class="nf">dci_sri_dE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the pressure modification term of SRI falloff</span>
<span class="sd">    reactions w.r.t. the extra variable (volume / pressure)</span>
<span class="sd">    for constant pressure/volume respectively</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See :meth:`pyjac.core.create_jacobian.__dcidE`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">__dcidE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span>
                                <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<span class="nd">@ic</span><span class="o">.</span><span class="n">with_conditional_jacobian</span>
<span class="k">def</span> <span class="nf">__dRopidE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">do_ns</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rxn_type</span><span class="o">=</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">elementary</span><span class="p">,</span> <span class="n">maxP</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">maxT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jac_create</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the rate of progress (for all reaction types)</span>
<span class="sd">    with respect to the extra variable -- Volume / Pressure, depending on</span>
<span class="sd">    constant pressure / volume accordingly</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    do_ns : bool [False]</span>
<span class="sd">        If True, generate kernel to handle derivatives of the last species&#39;</span>
<span class="sd">        concentration w.r.t. temperature</span>
<span class="sd">    rxn_type : [reaction_type.thd, reaction_type.plog, reaction_type.cheb]</span>
<span class="sd">        The type of reaction to generate fore</span>
<span class="sd">    maxP: int [None]</span>
<span class="sd">        The maximum number of pressure interpolations of any reaction in</span>
<span class="sd">        the mechanism.</span>
<span class="sd">        - For PLOG - the maximum number of pressure interpolations of any</span>
<span class="sd">        reaction in the mechanism.</span>
<span class="sd">        - For CHEB - The maximum degree of temperature polynomials for</span>
<span class="sd">        chebyshev reactions in this mechanism</span>
<span class="sd">    maxT : int [None]</span>
<span class="sd">        The maximum degree of temperature polynomials for chebyshev reactions</span>
<span class="sd">        in this mechanism</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>
<span class="sd">    jac_create: Callable</span>
<span class="sd">        The conditional Jacobian instruction creator from :mod:`instruction_creator`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># indicies</span>
    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># check rxn type</span>
    <span class="k">if</span> <span class="n">rxn_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">,</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">]</span> <span class="ow">and</span> <span class="n">do_ns</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># this is handled by do_ns w / elementary</span>
    <span class="k">elif</span> <span class="n">rxn_type</span> <span class="o">==</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">maxP</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;The maximum # of pressure interpolations must be&#39;</span>
                      <span class="s1">&#39; supplied&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">rxn_type</span> <span class="o">==</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">maxP</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;The maximum chebyshev pressure polynomial degree must &#39;</span>
                      <span class="s1">&#39; be supplied&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">maxT</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;The maximum chebyshev temperature polynomial degree &#39;</span>
                      <span class="s1">&#39; must be supplied&#39;</span><span class="p">)</span>

    <span class="n">num_range_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">elementary</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_simple</span><span class="p">,</span>
                      <span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_plog</span><span class="p">,</span>
                      <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_cheb</span><span class="p">}</span>
    <span class="c1"># get num</span>
    <span class="n">num_range</span> <span class="o">=</span> <span class="n">num_range_dict</span><span class="p">[</span><span class="n">rxn_type</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> <span class="k">else</span>\
        <span class="n">namestore</span><span class="o">.</span><span class="n">num_rxn_has_ns</span>

    <span class="c1"># return an empty kernel if it doesn&#39;t apply</span>
    <span class="k">if</span> <span class="n">num_range</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">num_range</span><span class="o">.</span><span class="n">initializer</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># number of species</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">num_range</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>

    <span class="n">rxn_range_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">elementary</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">simple_map</span><span class="p">,</span>
                      <span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">plog_map</span><span class="p">,</span>
                      <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_map</span><span class="p">}</span>

    <span class="c1"># add map</span>
    <span class="n">rxn_range</span> <span class="o">=</span> <span class="n">rxn_range_dict</span><span class="p">[</span><span class="n">rxn_type</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> <span class="k">else</span>\
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_has_ns</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">rxn_range</span><span class="p">,</span> <span class="n">num_range</span><span class="p">)</span>

    <span class="c1"># rev mask depends on actual reaction index</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
    <span class="c1"># thd_mask depends on actual reaction index</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">thd_mask</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
    <span class="c1"># pres mod is on thd_mask</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">thd_mask</span><span class="p">)</span>
    <span class="c1"># nu&#39;s are on the actual rxn index</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>

    <span class="c1"># specific transforms</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span><span class="p">:</span>
        <span class="c1"># fwd ROP is on actual rxn index</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rop_fwd</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
        <span class="c1"># rev ROP is on rev mask</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rop_rev</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># kf is on real index</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kf</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
        <span class="c1"># kr is on rev rxn index</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kr</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">)</span>

    <span class="c1"># extra inames</span>
    <span class="n">net_ind</span> <span class="o">=</span> <span class="s1">&#39;net_ind&#39;</span>
    <span class="n">k_ind</span> <span class="o">=</span> <span class="s1">&#39;k_ind&#39;</span>

    <span class="c1"># common variables</span>
    <span class="c1"># temperature</span>
    <span class="n">T_lp</span><span class="p">,</span> <span class="n">T_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">T_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="c1"># Volume</span>
    <span class="n">V_lp</span><span class="p">,</span> <span class="n">V_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">V_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="c1"># pressure mod term</span>
    <span class="n">pres_mod_lp</span><span class="p">,</span> <span class="n">pres_mod_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
    <span class="c1"># nu offsets</span>
    <span class="n">nu_offset_lp</span><span class="p">,</span> <span class="n">nu_offset_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">nu_offset_next_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># reac and prod nu for net</span>
    <span class="n">nu_lp</span><span class="p">,</span> <span class="n">net_reac_nu_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_reac_nu</span><span class="p">,</span> <span class="n">net_ind</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">net_ind</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">net_prod_nu_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_prod_nu</span><span class="p">,</span> <span class="n">net_ind</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">net_ind</span><span class="p">)</span>
    <span class="c1"># get species</span>
    <span class="n">spec_lp</span><span class="p">,</span> <span class="n">spec_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec</span><span class="p">,</span> <span class="n">net_ind</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">spec_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec</span><span class="p">,</span> <span class="n">k_ind</span><span class="p">)</span>

    <span class="c1"># add to data</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">T_lp</span><span class="p">,</span> <span class="n">V_lp</span><span class="p">,</span> <span class="n">pres_mod_lp</span><span class="p">,</span> <span class="n">nu_offset_lp</span><span class="p">,</span> <span class="n">nu_lp</span><span class="p">,</span> <span class="n">spec_lp</span><span class="p">])</span>

    <span class="n">extra_inames</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">net_ind</span><span class="p">,</span> <span class="s1">&#39;offset &lt;= </span><span class="si">{}</span><span class="s1"> &lt; offset_next&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">net_ind</span><span class="p">)),</span>
        <span class="p">(</span><span class="n">k_ind</span><span class="p">,</span> <span class="s1">&#39;offset &lt;= </span><span class="si">{}</span><span class="s1"> &lt; offset_next&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k_ind</span><span class="p">))]</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pre_instructions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">manglers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">preambles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># create a precomputed instruction generator</span>
    <span class="n">precompute</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">PrecomputedInstructions</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">conp</span> <span class="ow">and</span> \
                <span class="n">rxn_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">,</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">]:</span>
            <span class="c1"># the non-NS portion of these reactions is zero by definition</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># rop&#39;s &amp; pres mod</span>
        <span class="n">rop_fwd_lp</span><span class="p">,</span> <span class="n">rop_fwd_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">rop_fwd</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">rop_rev_lp</span><span class="p">,</span> <span class="n">rop_rev_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">rop_rev</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

        <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">rop_fwd_lp</span><span class="p">,</span> <span class="n">rop_rev_lp</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">conp</span><span class="p">:</span>
            <span class="c1"># handle updates for dRopi_dE&#39;s</span>
            <span class="n">rev_update</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_update_instruction</span><span class="p">(</span>
                <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">rop_rev</span><span class="p">,</span>
                <span class="n">Template</span><span class="p">(</span>
                    <span class="s1">&#39;dRopi_dE = dRopi_dE + nu_rev * $</span><span class="si">{rop_rev_str}</span><span class="s1"> </span><span class="se">\</span>
<span class="s1">                {id=dE_update, dep=dE_init}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">()))</span>

            <span class="n">pmod_deps</span> <span class="o">=</span> <span class="s1">&#39;:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;dE_update&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">rev_update</span> <span class="k">else</span> <span class="p">[])</span>
            <span class="n">pres_mod_update</span> <span class="o">=</span> <span class="s1">&#39;... nop {{id=dE_final, dep=</span><span class="si">{pmod_deps}</span><span class="s1">}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">pmod_deps</span><span class="o">=</span><span class="n">pmod_deps</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rxn_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">,</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">]:</span>
                <span class="n">pres_mod_update</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_update_instruction</span><span class="p">(</span>
                    <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span>
                    <span class="n">Template</span><span class="p">(</span>
                        <span class="s1">&#39;dRopi_dE = dRopi_dE * $</span><span class="si">{pres_mod_str}</span><span class="s1"> </span><span class="se">\</span>
<span class="s1">                    {id=dE_final, dep=$</span><span class="si">{pmod_deps}</span><span class="s1">}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">()))</span>

            <span class="c1"># if conp, need to include the fwd / reverse ROP an extra time</span>
            <span class="c1"># to account for the qi term resulting from d/dV (qi * V)</span>
            <span class="c1"># the negative is to account for the difference in signs between</span>
            <span class="c1"># this and the Rop * sum(nu) terms</span>
            <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="c1"># all constant pressure cases are the same (Rop * sum of nu)</span>
            <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                &lt;&gt; nu_fwd = $</span><span class="si">{start}</span><span class="s2"></span>
<span class="s2">                &lt;&gt; nu_rev = $</span><span class="si">{start}</span><span class="s2"></span>
<span class="s2">                for $</span><span class="si">{net_ind}</span><span class="s2"></span>
<span class="s2">                    nu_fwd = nu_fwd + $</span><span class="si">{net_reac_nu_str}</span><span class="s2"> {id=nuf_up}</span>
<span class="s2">                    nu_rev = nu_rev + $</span><span class="si">{net_prod_nu_str}</span><span class="s2"> {id=nur_up}</span>
<span class="s2">                end</span>
<span class="s2">                &lt;&gt; dRopi_dE = -nu_fwd * $</span><span class="si">{rop_fwd_str}</span><span class="s2"> {id=dE_init, dep=nu*}</span>
<span class="s2">                $</span><span class="si">{rev_update}</span><span class="s2"></span>
<span class="s2">                $</span><span class="si">{pres_mod_update}</span><span class="s2"></span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># conv</span>
            <span class="k">if</span> <span class="n">rxn_type</span> <span class="o">==</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">:</span>
                <span class="c1"># conp &amp; plog</span>
                <span class="n">lo_ind</span> <span class="o">=</span> <span class="s1">&#39;lo&#39;</span>
                <span class="n">hi_ind</span> <span class="o">=</span> <span class="s1">&#39;hi&#39;</span>
                <span class="n">param_ind</span> <span class="o">=</span> <span class="s1">&#39;p&#39;</span>
                <span class="c1"># create extra arrays</span>
                <span class="n">P_lp</span><span class="p">,</span> <span class="n">P_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">P_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
                <span class="c1"># number of plog rates per rxn</span>
                <span class="n">plog_num_param_lp</span><span class="p">,</span> <span class="n">plog_num_param_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">plog_num_param</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
                <span class="c1"># pressure ranges</span>
                <span class="n">plog_params_lp</span><span class="p">,</span> <span class="n">pressure_mid_lo</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">param_ind</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">pressure_mid_hi</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">param_ind</span><span class="p">,</span>
                    <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">param_ind</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">pres_lo_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">lo_ind</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">pres_hi_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">hi_ind</span><span class="p">)</span>
                <span class="c1"># arrhenius params</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">A_lo_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">lo_ind</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">A_hi_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">hi_ind</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">beta_lo_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">lo_ind</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">beta_hi_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">hi_ind</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">Ta_lo_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">lo_ind</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">Ta_hi_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">hi_ind</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">pressure_lo</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">pressure_hi</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="s1">&#39;numP&#39;</span><span class="p">)</span>
                <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">P_lp</span><span class="p">,</span> <span class="n">plog_num_param_lp</span><span class="p">,</span> <span class="n">plog_params_lp</span><span class="p">])</span>

                <span class="c1"># add plog instruction</span>
                <span class="n">pre_instructions</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">precompute</span><span class="p">(</span>
                    <span class="s1">&#39;logP&#39;</span><span class="p">,</span> <span class="n">P_str</span><span class="p">,</span> <span class="s1">&#39;LOG&#39;</span><span class="p">),</span> <span class="n">precompute</span><span class="p">(</span>
                    <span class="s1">&#39;logT&#39;</span><span class="p">,</span> <span class="n">T_str</span><span class="p">,</span> <span class="s1">&#39;LOG&#39;</span><span class="p">),</span> <span class="n">precompute</span><span class="p">(</span>
                    <span class="s1">&#39;Tinv&#39;</span><span class="p">,</span> <span class="n">T_str</span><span class="p">,</span> <span class="s1">&#39;INV&#39;</span><span class="p">)])</span>

                <span class="n">plog_preloads</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">if</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">is_simd</span><span class="p">:</span>
                    <span class="c1"># add some pre-loads for the plog parameters to avoid</span>
                    <span class="c1"># precompute avoid errors with lookup of individual SIMD-vector</span>
                    <span class="c1"># elements</span>

                    <span class="n">plog_preloads</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                    with {id_prefix=set_lo, dep=set_lo}</span>
<span class="s2">                        &lt;&gt; p_lo = $</span><span class="si">{pres_lo_str}</span><span class="s2"></span>
<span class="s2">                        &lt;&gt; a_lo = $</span><span class="si">{A_lo_str}</span><span class="s2"></span>
<span class="s2">                        &lt;&gt; beta_lo = $</span><span class="si">{beta_lo_str}</span><span class="s2"></span>
<span class="s2">                        &lt;&gt; Ta_lo = $</span><span class="si">{Ta_lo_str}</span><span class="s2"></span>
<span class="s2">                    end</span>
<span class="s2">                    with {id_prefix=set_hi, dep=set_hi}</span>
<span class="s2">                        &lt;&gt; p_hi = $</span><span class="si">{pres_hi_str}</span><span class="s2"></span>
<span class="s2">                        &lt;&gt; a_hi = $</span><span class="si">{A_hi_str}</span><span class="s2"></span>
<span class="s2">                        &lt;&gt; beta_hi = $</span><span class="si">{beta_hi_str}</span><span class="s2"></span>
<span class="s2">                        &lt;&gt; Ta_hi = $</span><span class="si">{Ta_hi_str}</span><span class="s2"></span>
<span class="s2">                    end&quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
                    <span class="c1"># and update strings</span>
                    <span class="n">pres_lo_str</span> <span class="o">=</span> <span class="s1">&#39;p_lo&#39;</span>
                    <span class="n">A_lo_str</span> <span class="o">=</span> <span class="s1">&#39;a_lo&#39;</span>
                    <span class="n">beta_lo_str</span> <span class="o">=</span> <span class="s1">&#39;beta_lo&#39;</span>
                    <span class="n">Ta_lo_str</span> <span class="o">=</span> <span class="s1">&#39;Ta_lo&#39;</span>
                    <span class="n">pres_hi_str</span> <span class="o">=</span> <span class="s1">&#39;p_hi&#39;</span>
                    <span class="n">A_hi_str</span> <span class="o">=</span> <span class="s1">&#39;a_hi&#39;</span>
                    <span class="n">beta_hi_str</span> <span class="o">=</span> <span class="s1">&#39;beta_hi&#39;</span>
                    <span class="n">Ta_hi_str</span> <span class="o">=</span> <span class="s1">&#39;Ta_hi&#39;</span>

                <span class="c1"># and dkf instructions</span>
                <span class="n">dkf_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                    &lt;&gt; lo = 0 {id=lo_init}</span>
<span class="s2">                    &lt;&gt; hi = numP {id=hi_init}</span>
<span class="s2">                    &lt;&gt; numP = $</span><span class="si">{plog_num_param_str}</span><span class="s2"> - 1</span>
<span class="s2">                    for $</span><span class="si">{param_ind}</span><span class="s2"></span>
<span class="s2">                        if $</span><span class="si">{param_ind}</span><span class="s2"> &lt;= numP and </span><span class="se">\</span>
<span class="s2">                                (logP &gt; $</span><span class="si">{pressure_mid_lo}</span><span class="s2">) and </span><span class="se">\</span>
<span class="s2">                                (logP &lt;= $</span><span class="si">{pressure_mid_hi}</span><span class="s2">)</span>
<span class="s2">                            lo = $</span><span class="si">{param_ind}</span><span class="s2"> {id=set_lo, dep=lo_init}</span>
<span class="s2">                            hi = $</span><span class="si">{param_ind}</span><span class="s2"> + 1 {id=set_hi, dep=hi_init}</span>
<span class="s2">                        end</span>
<span class="s2">                    end</span>

<span class="s2">                    $</span><span class="si">{plog_preloads}</span><span class="s2"></span>
<span class="s2">                    &lt;&gt; dkf = 0 {id=dkf_init}</span>
<span class="s2">                    # not out of range</span>
<span class="s2">                    if logP &gt; $</span><span class="si">{pressure_lo}</span><span class="s2"> and logP &lt;= $</span><span class="si">{pressure_hi}</span><span class="s2"></span>
<span class="s2">                        dkf = ($</span><span class="si">{A_hi_str}</span><span class="s2"> - $</span><span class="si">{A_lo_str}</span><span class="s2"> + </span><span class="se">\</span>
<span class="s2">                            logT * ($</span><span class="si">{beta_hi_str}</span><span class="s2"> - $</span><span class="si">{beta_lo_str}</span><span class="s2">) - </span><span class="se">\</span>
<span class="s2">                            ($</span><span class="si">{Ta_hi_str}</span><span class="s2"> - $</span><span class="si">{Ta_lo_str}</span><span class="s2">) * Tinv) / </span><span class="se">\</span>
<span class="s2">                            ($</span><span class="si">{P_str}</span><span class="s2"> * ($</span><span class="si">{pres_hi_str}</span><span class="s2"> - $</span><span class="si">{pres_lo_str}</span><span class="s2">)) </span><span class="se">\</span>
<span class="s2">                            {id=dkf_final, dep=dkf_init:set_*}</span>
<span class="s2">                    end</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
                <span class="n">extra_inames</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                    <span class="n">param_ind</span><span class="p">,</span> <span class="s1">&#39;0 &lt;= </span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param_ind</span><span class="p">,</span> <span class="n">maxP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">rxn_type</span> <span class="o">==</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">:</span>
                <span class="c1"># conp &amp; cheb</span>
                <span class="c1"># max degrees in mechanism</span>
                <span class="c1"># derivative by P decreases pressure poly degree by 1</span>
                <span class="n">poly_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">maxP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxT</span><span class="p">))</span>

                <span class="c1"># extra inames</span>
                <span class="n">pres_poly_ind</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>
                <span class="n">temp_poly_ind</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
                <span class="n">poly_compute_ind</span> <span class="o">=</span> <span class="s1">&#39;p&#39;</span>
                <span class="n">lim_ind</span> <span class="o">=</span> <span class="s1">&#39;dummy&#39;</span>
                <span class="c1"># derivative by P decreases pressure poly degree by 1</span>
                <span class="n">extra_inames</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
                    <span class="p">(</span><span class="n">pres_poly_ind</span><span class="p">,</span> <span class="s1">&#39;0 &lt;= </span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">pres_poly_ind</span><span class="p">,</span> <span class="n">maxP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="p">(</span><span class="n">temp_poly_ind</span><span class="p">,</span> <span class="s1">&#39;0 &lt;= </span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">temp_poly_ind</span><span class="p">,</span> <span class="n">maxT</span><span class="p">)),</span>
                    <span class="p">(</span><span class="n">poly_compute_ind</span><span class="p">,</span> <span class="s1">&#39;2 &lt;= </span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">poly_compute_ind</span><span class="p">,</span> <span class="n">poly_max</span><span class="p">))])</span>

                <span class="c1"># create arrays</span>

                <span class="n">num_P_lp</span><span class="p">,</span> <span class="n">num_P_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_numP</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
                <span class="n">num_T_lp</span><span class="p">,</span> <span class="n">num_T_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_numT</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
                <span class="c1"># derivative by P forces us to look 1 over in the pressure</span>
                <span class="c1"># polynomial index</span>
                <span class="n">params_lp</span><span class="p">,</span> <span class="n">params_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_params</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">temp_poly_ind</span><span class="p">,</span>
                    <span class="n">pres_poly_ind</span><span class="p">,</span>
                    <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">pres_poly_ind</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
                <span class="n">plim_lp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_Plim</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">lim_ind</span><span class="p">)</span>
                <span class="n">tlim_lp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_Tlim</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">lim_ind</span><span class="p">)</span>

                <span class="c1"># workspace vars are based only on their polynomial indicies</span>
                <span class="n">pres_poly_lp</span><span class="p">,</span> <span class="n">ppoly_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_pres_poly</span><span class="p">,</span> <span class="n">pres_poly_ind</span><span class="p">)</span>
                <span class="n">temp_poly_lp</span><span class="p">,</span> <span class="n">tpoly_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_temp_poly</span><span class="p">,</span> <span class="n">temp_poly_ind</span><span class="p">)</span>

                <span class="c1"># create temperature and pressure arrays</span>
                <span class="n">P_lp</span><span class="p">,</span> <span class="n">P_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">P_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

                <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">params_lp</span><span class="p">,</span> <span class="n">num_P_lp</span><span class="p">,</span> <span class="n">num_T_lp</span><span class="p">,</span> <span class="n">plim_lp</span><span class="p">,</span>
                                    <span class="n">P_lp</span><span class="p">,</span> <span class="n">tlim_lp</span><span class="p">,</span> <span class="n">pres_poly_lp</span><span class="p">,</span> <span class="n">temp_poly_lp</span><span class="p">])</span>

                <span class="c1"># preinstructions</span>
                <span class="n">pre_instructions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">precompute</span><span class="p">(</span><span class="s1">&#39;logP&#39;</span><span class="p">,</span> <span class="n">P_str</span><span class="p">,</span> <span class="s1">&#39;LOG&#39;</span><span class="p">),</span>
                     <span class="n">precompute</span><span class="p">(</span><span class="s1">&#39;Tinv&#39;</span><span class="p">,</span> <span class="n">T_str</span><span class="p">,</span> <span class="s1">&#39;INV&#39;</span><span class="p">)])</span>

                <span class="c1"># various strings for preindexed limits, params, etc</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">Pmin_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_Plim</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">Pmax_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_Plim</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">Tmin_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_Tlim</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">Tmax_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_Tlim</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>

                <span class="c1"># the various indexing for the pressure / temperature</span>
                <span class="c1"># polynomials</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">ppoly0_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_pres_poly</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">ppoly1_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_pres_poly</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">ppolyp_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_pres_poly</span><span class="p">,</span>
                                                    <span class="n">poly_compute_ind</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">ppolypm1_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_pres_poly</span><span class="p">,</span>
                                                      <span class="n">poly_compute_ind</span><span class="p">,</span>
                                                      <span class="n">affine</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">ppolypm2_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_pres_poly</span><span class="p">,</span>
                                                      <span class="n">poly_compute_ind</span><span class="p">,</span>
                                                      <span class="n">affine</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">tpoly0_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_temp_poly</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">tpoly1_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                    <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_temp_poly</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">tpolyp_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_temp_poly</span><span class="p">,</span>
                                                    <span class="n">poly_compute_ind</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">tpolypm1_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_temp_poly</span><span class="p">,</span>
                                                      <span class="n">poly_compute_ind</span><span class="p">,</span>
                                                      <span class="n">affine</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">tpolypm2_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_temp_poly</span><span class="p">,</span>
                                                      <span class="n">poly_compute_ind</span><span class="p">,</span>
                                                      <span class="n">affine</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

                <span class="n">dkf_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                    &lt;&gt;numP = $</span><span class="si">{num_P_str}</span><span class="s2"> - 1 {id=plim} # derivative by P</span>
<span class="s2">                    &lt;&gt;numT = $</span><span class="si">{num_T_str}</span><span class="s2"> {id=tlim}</span>
<span class="s2">                    &lt;&gt; Tred = (2 * Tinv - $</span><span class="si">{Tmax_str}</span><span class="s2">- $</span><span class="si">{Tmin_str}</span><span class="s2">) / </span><span class="se">\</span>
<span class="s2">                        ($</span><span class="si">{Tmax_str}</span><span class="s2"> - $</span><span class="si">{Tmin_str}</span><span class="s2">)</span>
<span class="s2">                    &lt;&gt; Pred = (2 * logP - $</span><span class="si">{Pmax_str}</span><span class="s2"> - $</span><span class="si">{Pmin_str}</span><span class="s2">) / </span><span class="se">\</span>
<span class="s2">                        ($</span><span class="si">{Pmax_str}</span><span class="s2"> - $</span><span class="si">{Pmin_str}</span><span class="s2">)</span>
<span class="s2">                    $</span><span class="si">{ppoly0_str}</span><span class="s2"> = 1 {id=ppoly_init1}</span>
<span class="s2">                    $</span><span class="si">{ppoly1_str}</span><span class="s2"> = 2 * Pred {id=ppoly_init2} # derivative by P</span>
<span class="s2">                    $</span><span class="si">{tpoly0_str}</span><span class="s2"> = 1 {id=tpoly_init1}</span>
<span class="s2">                    $</span><span class="si">{tpoly1_str}</span><span class="s2"> = Tred {id=tpoly_init2}</span>

<span class="s2">                    # compute polynomial terms</span>
<span class="s2">                    for p</span>
<span class="s2">                        if p &lt; numP</span>
<span class="s2">                            $</span><span class="si">{ppolyp_str}</span><span class="s2"> = 2 * Pred * $</span><span class="si">{ppolypm1_str}</span><span class="s2"> - </span><span class="se">\</span>
<span class="s2">                                $</span><span class="si">{ppolypm2_str}</span><span class="s2"> {id=ppoly, dep=plim:ppoly_init*}</span>
<span class="s2">                        end</span>
<span class="s2">                        if p &lt; numT</span>
<span class="s2">                            $</span><span class="si">{tpolyp_str}</span><span class="s2"> = 2 * Tred * $</span><span class="si">{tpolypm1_str}</span><span class="s2"> - </span><span class="se">\</span>
<span class="s2">                                $</span><span class="si">{tpolypm2_str}</span><span class="s2"> {id=tpoly, dep=tlim:tpoly_init*}</span>
<span class="s2">                        end</span>
<span class="s2">                    end</span>

<span class="s2">                    &lt;&gt; dkf = 0 {id=dkf_init}</span>
<span class="s2">                    for m</span>
<span class="s2">                        &lt;&gt;temp = 0 {id=temp_init}</span>
<span class="s2">                        for k</span>
<span class="s2">                            # derivative by P</span>
<span class="s2">                            temp = temp + (k + 1) * $</span><span class="si">{ppoly_str}</span><span class="s2"> * </span><span class="se">\</span>
<span class="s2">                                $</span><span class="si">{params_str}</span><span class="s2"> {id=temp, dep=ppoly:tpoly:temp_init}</span>
<span class="s2">                        end</span>
<span class="s2">                        dkf = dkf + $</span><span class="si">{tpoly_str}</span><span class="s2"> * temp </span><span class="se">\</span>
<span class="s2">                            {id=dkf_update, dep=temp:dkf_init}</span>
<span class="s2">                    end</span>
<span class="s2">                    dkf = dkf * 2 * logten / ($</span><span class="si">{P_str}</span><span class="s2"> * </span><span class="se">\</span>
<span class="s2">                        ($</span><span class="si">{Pmax_str}</span><span class="s2"> - $</span><span class="si">{Pmin_str}</span><span class="s2">)) {id=dkf_final, dep=dkf_update}</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;logten&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

            <span class="n">rev_update</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_update_instruction</span><span class="p">(</span>
                <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">rop_rev</span><span class="p">,</span>
                <span class="n">Template</span><span class="p">(</span>
                    <span class="s1">&#39;dRopi_dE = dRopi_dE - $</span><span class="si">{rop_rev_str}</span><span class="s1"> </span><span class="se">\</span>
<span class="s1">                {id=dE_update, dep=dE_init}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">()))</span>

            <span class="n">rev_dep</span> <span class="o">=</span> <span class="s1">&#39;dE_update:&#39;</span> <span class="k">if</span> <span class="n">rev_update</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

            <span class="c1"># and put together instructions</span>
            <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            $</span><span class="si">{dkf_instructions}</span><span class="s2"></span>
<span class="s2">            &lt;&gt; dRopi_dE = $</span><span class="si">{rop_fwd_str}</span><span class="s2"> {id=dE_init}</span>
<span class="s2">            $</span><span class="si">{rev_update}</span><span class="s2"></span>
<span class="s2">            dRopi_dE = dRopi_dE * dkf * $</span><span class="si">{V_str}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                {id=dE_final, dep=$</span><span class="si">{rev_dep}</span><span class="s2">dkf_*}</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># create kf / kr</span>
        <span class="n">kf_lp</span><span class="p">,</span> <span class="n">kf_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kf</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">kr_lp</span><span class="p">,</span> <span class="n">kr_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kr</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">P_lp</span><span class="p">,</span> <span class="n">P_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">P_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
        <span class="n">conc_lp</span><span class="p">,</span> <span class="n">conc_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">conc_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="s1">&#39;net_spec&#39;</span><span class="p">)</span>
        <span class="c1"># TODO: forward allint to this function</span>
        <span class="c1"># get the appropriate power function and calls</span>
        <span class="n">power_func</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">power_function</span><span class="p">(</span><span class="n">loopy_opts</span><span class="o">.</span><span class="n">lang</span><span class="p">,</span> <span class="n">is_integer_power</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                          <span class="n">guard_nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nu_fwd</span> <span class="o">=</span> <span class="s1">&#39;nu_fwd&#39;</span>
        <span class="n">nu_rev</span> <span class="o">=</span> <span class="s1">&#39;nu_rev&#39;</span>
        <span class="n">pow_conc_fwd</span> <span class="o">=</span> <span class="n">power_func</span><span class="p">(</span><span class="n">conc_str</span><span class="p">,</span> <span class="n">nu_fwd</span><span class="p">)</span>
        <span class="n">pow_conc_rev</span> <span class="o">=</span> <span class="n">power_func</span><span class="p">(</span><span class="n">conc_str</span><span class="p">,</span> <span class="n">nu_rev</span><span class="p">)</span>
        <span class="n">manglers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lp_pregen</span><span class="o">.</span><span class="n">power_function_manglers</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">power_func</span><span class="p">))</span>
        <span class="n">preambles</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lp_pregen</span><span class="o">.</span><span class="n">power_function_preambles</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">power_func</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">conp</span><span class="p">:</span>
            <span class="n">pre_instructions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Template</span><span class="p">(</span>
                <span class="s1">&#39;&lt;&gt;fac = $</span><span class="si">{P_str}</span><span class="s1"> / (Ru * $</span><span class="si">{T_str}</span><span class="s1">)&#39;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pre_instructions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Template</span><span class="p">(</span>
                <span class="s1">&#39;&lt;&gt;fac = $</span><span class="si">{V_str}</span><span class="s1"> / (Ru * $</span><span class="si">{T_str}</span><span class="s1">)&#39;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">()))</span>

        <span class="c1"># create Ns nu&#39;s</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ns_reac_nu_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_reac_nu</span><span class="p">,</span> <span class="s1">&#39;offset_next&#39;</span><span class="p">,</span>
            <span class="n">affine</span><span class="o">=</span><span class="s1">&#39;offset_next - 2&#39;</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ns_prod_nu_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_prod_nu</span><span class="p">,</span> <span class="s1">&#39;offset_next&#39;</span><span class="p">,</span>
            <span class="n">affine</span><span class="o">=</span><span class="s1">&#39;offset_next - 2&#39;</span><span class="p">)</span>

        <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">kf_lp</span><span class="p">,</span> <span class="n">kr_lp</span><span class="p">,</span> <span class="n">P_lp</span><span class="p">,</span> <span class="n">conc_lp</span><span class="p">])</span>
        <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Ru&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chem</span><span class="o">.</span><span class="n">RU</span>

        <span class="n">rev_update</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_update_instruction</span><span class="p">(</span>
            <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">kr</span><span class="p">,</span>
            <span class="n">Template</span><span class="p">(</span><span class="s1">&#39;kr_i = $</span><span class="si">{kr_str}</span><span class="s1"> {id=kr_up, dep=kr_in}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span>
                <span class="o">**</span><span class="nb">locals</span><span class="p">()))</span>

        <span class="n">pres_mod_update</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="n">rxn_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">,</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">]:</span>
            <span class="n">pres_mod_update</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_update_instruction</span><span class="p">(</span>
                <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span>
                <span class="n">Template</span><span class="p">(</span><span class="s1">&#39;ci = $</span><span class="si">{pres_mod_str}</span><span class="s1"> </span><span class="se">\</span>
<span class="s1">                        {id=ci, dep=ci_init}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span>
                    <span class="o">**</span><span class="nb">locals</span><span class="p">()),)</span>

        <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        &lt;&gt; kr_i = 0 {id=kr_in}</span>
<span class="s2">        $</span><span class="si">{rev_update}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; ci = 1 {id=ci_init}</span>
<span class="s2">        $</span><span class="si">{pres_mod_update}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; Sns_fwd = $</span><span class="si">{ns_reac_nu_str}</span><span class="s2"> {id=Sns_fwd_init}</span>
<span class="s2">        &lt;&gt; Sns_rev = $</span><span class="si">{ns_prod_nu_str}</span><span class="s2"> {id=Sns_rev_init}</span>
<span class="s2">        for $</span><span class="si">{net_ind}</span><span class="s2"></span>
<span class="s2">            &lt;&gt; $</span><span class="si">{nu_fwd}</span><span class="s2"> = $</span><span class="si">{net_reac_nu_str}</span><span class="s2"> {id=nuf_inner}</span>
<span class="s2">            &lt;&gt; $</span><span class="si">{nu_rev}</span><span class="s2"> = $</span><span class="si">{net_prod_nu_str}</span><span class="s2"> {id=nur_inner}</span>
<span class="s2">            &lt;&gt; net_spec = $</span><span class="si">{spec_str}</span><span class="s2"></span>
<span class="s2">            # handle nu</span>
<span class="s2">            if net_spec == $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">                $</span><span class="si">{nu_fwd}</span><span class="s2"> = $</span><span class="si">{nu_fwd}</span><span class="s2"> - 1 {id=nuf_inner_up, dep=nuf_inner}</span>
<span class="s2">            end</span>
<span class="s2">            Sns_fwd = Sns_fwd * $</span><span class="si">{pow_conc_fwd}</span><span class="s2"> {id=Sns_fwd_up, </span><span class="se">\</span>
<span class="s2">                dep=nuf_inner_up:Sns_fwd_init}</span>
<span class="s2">            if net_spec == $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">                $</span><span class="si">{nu_rev}</span><span class="s2"> = $</span><span class="si">{nu_rev}</span><span class="s2"> - 1 {id=nur_inner_up, dep=nur_inner}</span>
<span class="s2">            end</span>
<span class="s2">            Sns_rev = Sns_rev * $</span><span class="si">{pow_conc_rev}</span><span class="s2"> {id=Sns_rev_up, </span><span class="se">\</span>
<span class="s2">                dep=nur_inner_up:Sns_rev_init}</span>
<span class="s2">        end</span>
<span class="s2">        &lt;&gt; dRopi_dE = (Sns_fwd * $</span><span class="si">{kf_str}</span><span class="s2"> - Sns_rev * kr_i) * ci </span><span class="se">\</span>
<span class="s2">            * fac {id=dE_final, dep=Sns*:kr_up:ci}</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="c1"># get nuk&#39;s</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">reac_nu_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_reac_nu</span><span class="p">,</span> <span class="n">k_ind</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">k_ind</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">prod_nu_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_prod_nu</span><span class="p">,</span> <span class="n">k_ind</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">k_ind</span><span class="p">)</span>
    <span class="c1"># and jac</span>
    <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
        <span class="s2">&quot;$</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + ($</span><span class="si">{prod_nu_k_str}</span><span class="s2"> - $</span><span class="si">{reac_nu_k_str}</span><span class="s2">) &quot;</span>
        <span class="s2">&quot;* dRopi_dE {id=jac, dep=$</span><span class="si">{deps}</span><span class="s2">}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">jac_lp</span><span class="p">,</span> <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">spec_k_str</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">spec_k_str</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
        <span class="n">insn</span><span class="o">=</span><span class="n">jac_update_insn</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;*:dE_final&#39;</span><span class="p">)</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jac_lp</span><span class="p">)</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        &lt;&gt; offset = $</span><span class="si">{nu_offset_str}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; offset_next = $</span><span class="si">{nu_offset_next_str}</span><span class="s2"></span>
<span class="s2">        $</span><span class="si">{instructions}</span><span class="s2"></span>
<span class="s2">        for $</span><span class="si">{k_ind}</span><span class="s2"></span>
<span class="s2">            if $</span><span class="si">{spec_k_str}</span><span class="s2"> != $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">                $</span><span class="si">{jac_update_insn}</span><span class="s2"></span>
<span class="s2">            end</span>
<span class="s2">        end</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="n">name_description</span> <span class="o">=</span> <span class="p">{</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">elementary</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                        <span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">:</span> <span class="s1">&#39;_plog&#39;</span><span class="p">,</span>
                        <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">:</span> <span class="s1">&#39;_cheb&#39;</span><span class="p">}</span>

    <span class="n">can_vectorize</span><span class="p">,</span> <span class="n">vec_spec</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_deep_specializer</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">atomic_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;dRopi</span><span class="si">{}</span><span class="s1">_d</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">name_description</span><span class="p">[</span><span class="n">rxn_type</span><span class="p">],</span>
        <span class="s1">&#39;V&#39;</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_ns&#39;</span> <span class="k">if</span> <span class="n">do_ns</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
        <span class="n">extra_inames</span><span class="o">=</span><span class="n">extra_inames</span><span class="p">,</span>
        <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
        <span class="n">pre_instructions</span><span class="o">=</span><span class="n">pre_instructions</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
        <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
        <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
        <span class="n">preambles</span><span class="o">=</span><span class="n">preambles</span><span class="p">,</span>
        <span class="n">manglers</span><span class="o">=</span><span class="n">manglers</span><span class="p">,</span>
        <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
        <span class="n">can_vectorize</span><span class="o">=</span><span class="n">can_vectorize</span><span class="p">,</span>
        <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">vec_spec</span><span class="p">,</span>
        <span class="c1"># expected vectorized scatter load instructions for plog parameters</span>
        <span class="c1"># with wide vectorization (pressure non-constant between vector-lanes)</span>
        <span class="n">silenced_warnings</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vectorize_failed&#39;</span><span class="p">]</span>
    <span class="p">)</span>


<div class="viewcode-block" id="dRopidE"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dRopidE">[docs]</a><span class="k">def</span> <span class="nf">dRopidE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the rate of progress (for non-pressure dependent reaction</span>
<span class="sd">    types) with respect to the extra variable -- volume/pressure for constant</span>
<span class="sd">    volume / pressure respectively</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See :meth:`pyjac.core.create_jacobian.__dRopidE`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">__dRopidE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span>
                                  <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">do_ns</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">),</span>
                        <span class="n">__dRopidE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span>
                                  <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">do_ns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="dRopi_plog_dE"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dRopi_plog_dE">[docs]</a><span class="k">def</span> <span class="nf">dRopi_plog_dE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">maxP</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the rate of progress (for PLOG reactions)</span>
<span class="sd">    with respect to the extra variable -- volume/pressure for constant</span>
<span class="sd">    volume / pressure respectively</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See :meth:`pyjac.core.create_jacobian.__dRopidE`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>
<span class="sd">    maxP: int [None]</span>
<span class="sd">        The maximum number of pressure interpolations of any reaction in</span>
<span class="sd">        the mechanism.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">__dRopidE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span>
                     <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">do_ns</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">rxn_type</span><span class="o">=</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span>
                     <span class="n">maxP</span><span class="o">=</span><span class="n">maxP</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">test_size</span> <span class="o">==</span> <span class="s1">&#39;problem_size&#39;</span><span class="p">:</span>
        <span class="c1"># include the ns version for convenience in testing</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">__dRopidE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span>
                             <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">do_ns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">rxn_type</span><span class="o">=</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span>
                             <span class="n">maxP</span><span class="o">=</span><span class="n">maxP</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ret</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="dRopi_cheb_dE"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dRopi_cheb_dE">[docs]</a><span class="k">def</span> <span class="nf">dRopi_cheb_dE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">maxP</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxT</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the rate of progress (for CHEB reactions)</span>
<span class="sd">    with respect to the extra variable -- volume/pressure for constant</span>
<span class="sd">    volume / pressure respectively</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See :meth:`pyjac.core.create_jacobian.__dRopidE`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>
<span class="sd">    maxP : int [None]</span>
<span class="sd">        The maximum degree of pressure polynomials for chebyshev reactions in</span>
<span class="sd">        this mechanism</span>
<span class="sd">    maxT : int [None]</span>
<span class="sd">        The maximum degree of temperature polynomials for chebyshev reactions</span>
<span class="sd">        in this mechanism</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">__dRopidE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span>
                     <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">do_ns</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">rxn_type</span><span class="o">=</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span>
                     <span class="n">maxP</span><span class="o">=</span><span class="n">maxP</span><span class="p">,</span> <span class="n">maxT</span><span class="o">=</span><span class="n">maxT</span><span class="p">)]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># include the ns version for convenience in testing</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">__dRopidE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span>
                             <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">do_ns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">rxn_type</span><span class="o">=</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span>
                             <span class="n">maxP</span><span class="o">=</span><span class="n">maxP</span><span class="p">,</span> <span class="n">maxT</span><span class="o">=</span><span class="n">maxT</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ret</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="dTdotdE"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dTdotdE">[docs]</a><span class="nd">@ic</span><span class="o">.</span><span class="n">with_conditional_jacobian</span>
<span class="k">def</span> <span class="nf">dTdotdE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jac_create</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the rate of change of temperature with respect to</span>
<span class="sd">    the extra variable (volume/pressure for const. pressure / volume</span>
<span class="sd">    respectively)</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>
<span class="sd">    jac_create: Callable</span>
<span class="sd">        The conditional Jacobian instruction creator from :mod:`instruction_creator`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># indicies</span>
    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs_no_ns</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>

    <span class="c1"># create arrays</span>
    <span class="n">T_lp</span><span class="p">,</span> <span class="n">T_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">T_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">V_lp</span><span class="p">,</span> <span class="n">V_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">V_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="c1"># specific heats and energies</span>
    <span class="n">spec_heat_tot_lp</span><span class="p">,</span> <span class="n">spec_heat_total_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_heat_total</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">spec_heat_lp</span><span class="p">,</span> <span class="n">spec_heat_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_heat</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">spec_heat_ns_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_heat_ns</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">spec_energy_lp</span><span class="p">,</span> <span class="n">spec_energy_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_energy</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">spec_energy_ns_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_energy_ns</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="c1"># concs</span>
    <span class="n">conc_lp</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">conp</span><span class="p">:</span>
        <span class="n">conc_lp</span><span class="p">,</span> <span class="n">conc_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">conc_arr</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

    <span class="c1"># rates</span>
    <span class="n">wdot_lp</span><span class="p">,</span> <span class="n">wdot_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_rates</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
    <span class="n">Tdot_lp</span><span class="p">,</span> <span class="n">Tdot_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">T_dot</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="c1"># molecular weights</span>
    <span class="n">mw_lp</span><span class="p">,</span> <span class="n">mw_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">mw_post_arr</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
    <span class="c1"># create a precomputed instruction generator</span>
    <span class="n">precompute</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">PrecomputedInstructions</span><span class="p">()</span>

    <span class="c1"># setup instructions</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">conp</span><span class="p">:</span>
        <span class="n">pre_instructions</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&lt;&gt; dTsum = 0 {id=dTinit}&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;&lt;&gt; specsum = 0 {id=specsum}&#39;</span><span class="p">]</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">True</span><span class="p">,</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            specsum = specsum + ($</span><span class="si">{spec_energy_str}</span><span class="s2"> - $</span><span class="si">{spec_energy_ns_str}</span><span class="s2"> * </span><span class="se">\</span>
<span class="s2">                $</span><span class="si">{mw_str}</span><span class="s2">) * ($</span><span class="si">{jac_str}</span><span class="s2"> - $</span><span class="si">{wdot_str}</span><span class="s2">) {id=up, dep=$</span><span class="si">{deps}</span><span class="s2">}</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())),</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            dTsum = dTsum + ($</span><span class="si">{spec_heat_str}</span><span class="s2"> - $</span><span class="si">{spec_heat_ns_str}</span><span class="s2">) * </span><span class="se">\</span>
<span class="s2">                $</span><span class="si">{conc_str}</span><span class="s2"> {id=up2, dep=*:dTinit}</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">()))]</span>
        <span class="n">post_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            &lt;&gt; spec_inv = 1 / ($</span><span class="si">{spec_heat_total_str}</span><span class="s2"> * $</span><span class="si">{V_str}</span><span class="s2">)</span>
<span class="s2">            $</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + ($</span><span class="si">{Tdot_str}</span><span class="s2"> * dTsum - specsum) * </span><span class="se">\</span>
<span class="s2">                spec_inv {id=jac, dep=$</span><span class="si">{deps}</span><span class="s2">, nosync=up*}</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="s1">&#39;*:specsum&#39;</span>
        <span class="n">post_deps</span> <span class="o">=</span> <span class="s1">&#39;up*&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pre_instructions</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&lt;&gt; sum = 0 {id=sum}&#39;</span><span class="p">,</span>
                            <span class="n">precompute</span><span class="p">(</span><span class="s1">&#39;Vinv&#39;</span><span class="p">,</span> <span class="n">V_str</span><span class="p">,</span> <span class="s1">&#39;INV&#39;</span><span class="p">)]</span>
        <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Ru&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chem</span><span class="o">.</span><span class="n">RU</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">True</span><span class="p">,</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            sum = sum + ($</span><span class="si">{spec_energy_str}</span><span class="s2"> - $</span><span class="si">{spec_energy_ns_str}</span><span class="s2"> * </span><span class="se">\</span>
<span class="s2">                $</span><span class="si">{mw_str}</span><span class="s2">) * $</span><span class="si">{jac_str}</span><span class="s2"> {id=up, dep=$</span><span class="si">{deps}</span><span class="s2">}</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">()))]</span>
        <span class="n">post_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            &lt;&gt; spec_inv = 1 / ($</span><span class="si">{spec_heat_total_str}</span><span class="s2">)</span>
<span class="s2">            $</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> - ($</span><span class="si">{Tdot_str}</span><span class="s2"> * $</span><span class="si">{spec_heat_ns_str}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                / (Ru * $</span><span class="si">{T_str}</span><span class="s2">)) * spec_inv {id=jac_split, dep=$</span><span class="si">{deps}</span><span class="s2">, </span><span class="se">\</span>
<span class="s2">                nosync=up:jac}</span>
<span class="s2">            $</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> - (sum * Vinv) * spec_inv </span><span class="se">\</span>
<span class="s2">                {id=jac, dep=$</span><span class="si">{deps}</span><span class="s2">, nosync=jac_split:up}</span>
<span class="s2">                    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="s1">&#39;*:sum&#39;</span>
        <span class="n">post_deps</span> <span class="o">=</span> <span class="s1">&#39;up&#39;</span>

    <span class="c1"># jacobian entries</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">insn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
        <span class="n">has_jac</span><span class="p">,</span> <span class="n">insn</span> <span class="o">=</span> <span class="n">insn</span>
        <span class="k">if</span> <span class="n">has_jac</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
                <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">var_name</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="n">insn</span><span class="o">=</span><span class="n">insn</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">insn</span>

    <span class="n">jac_lp</span><span class="p">,</span> <span class="n">post_instructions</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">insn</span><span class="o">=</span><span class="n">post_instructions</span><span class="p">,</span>
        <span class="n">deps</span><span class="o">=</span><span class="n">post_deps</span><span class="p">,</span> <span class="n">entry_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span>
        <span class="n">spec_heat_tot_lp</span><span class="p">,</span> <span class="n">spec_heat_lp</span><span class="p">,</span> <span class="n">spec_energy_lp</span><span class="p">,</span> <span class="n">wdot_lp</span><span class="p">,</span> <span class="n">Tdot_lp</span><span class="p">,</span>
        <span class="n">mw_lp</span><span class="p">,</span> <span class="n">jac_lp</span><span class="p">,</span> <span class="n">conc_lp</span><span class="p">,</span> <span class="n">T_lp</span><span class="p">,</span> <span class="n">V_lp</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">])</span>

    <span class="n">can_vectorize</span><span class="p">,</span> <span class="n">vec_spec</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_deep_specializer</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">atomic_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">],</span> <span class="n">split_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac_split&#39;</span><span class="p">],</span>
        <span class="n">split_size</span><span class="o">=</span><span class="n">mapstore</span><span class="o">.</span><span class="n">map_domain</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;dTdotd</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;V&#39;</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="s1">&#39;P&#39;</span><span class="p">),</span>
                          <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
                          <span class="n">pre_instructions</span><span class="o">=</span><span class="n">pre_instructions</span><span class="p">,</span>
                          <span class="n">post_instructions</span><span class="o">=</span><span class="p">[</span><span class="n">post_instructions</span><span class="p">],</span>
                          <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
                          <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
                          <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
                          <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
                          <span class="n">can_vectorize</span><span class="o">=</span><span class="n">can_vectorize</span><span class="p">,</span>
                          <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">vec_spec</span>
                          <span class="p">)</span></div>


<div class="viewcode-block" id="dEdotdE"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dEdotdE">[docs]</a><span class="nd">@ic</span><span class="o">.</span><span class="n">with_conditional_jacobian</span>
<span class="k">def</span> <span class="nf">dEdotdE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jac_create</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the rate of change of volume / pressure</span>
<span class="sd">    with respect to the extra variable (volume/pressure for const. pressure /</span>
<span class="sd">    volume respectively)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>
<span class="sd">    jac_create: Callable</span>
<span class="sd">        The conditional Jacobian instruction creator from :mod:`instruction_creator`</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># indicies</span>
    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">net_nonzero_spec</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>

    <span class="c1"># create arrays</span>
    <span class="n">T_lp</span><span class="p">,</span> <span class="n">T_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">T_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">V_lp</span><span class="p">,</span> <span class="n">V_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">V_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">P_lp</span><span class="p">,</span> <span class="n">P_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">P_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="c1"># rates</span>
    <span class="n">Tdot_lp</span><span class="p">,</span> <span class="n">Tdot_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">T_dot</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="c1"># molecular weights</span>
    <span class="n">mw_lp</span><span class="p">,</span> <span class="n">mw_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">mw_post_arr</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>

    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
        <span class="n">T_lp</span><span class="p">,</span> <span class="n">V_lp</span><span class="p">,</span> <span class="n">P_lp</span><span class="p">,</span> <span class="n">Tdot_lp</span><span class="p">,</span> <span class="n">mw_lp</span><span class="p">])</span>

    <span class="n">var_str</span> <span class="o">=</span> <span class="n">V_str</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="n">P_str</span>
    <span class="n">param_str</span> <span class="o">=</span> <span class="n">P_str</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="n">V_str</span>

    <span class="n">pre_instructions</span> <span class="o">=</span> <span class="p">[</span><span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        &lt;&gt; sum = 0 {id=init}</span>
<span class="s2">        ... nop {id=index_dummy} # included to avoid non-existant dep check</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())]</span>

    <span class="c1"># jacobian entries</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        # hook the sum depenency onto any resulting index changes for the</span>
<span class="s2">        # net_non_zero sum</span>
<span class="s2">        sum = sum + (1 - $</span><span class="si">{mw_str}</span><span class="s2">) * $</span><span class="si">{jac_str}</span><span class="s2"> {id=up, dep=$</span><span class="si">{deps}</span><span class="s2">}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">jac_lp</span><span class="p">,</span> <span class="n">instructions</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">var_name</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
        <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;init:index*&#39;</span><span class="p">,</span> <span class="n">insn</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
        <span class="n">entry_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># as we&#39;re looping over non-zero</span>
    <span class="p">)</span>

    <span class="n">kernel_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jac_lp</span><span class="p">)</span>

    <span class="c1"># and create post instructions</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">dTdot_de_str</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">entry_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">post_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        $</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + Ru * $</span><span class="si">{T_str}</span><span class="s2"> * sum / $</span><span class="si">{param_str}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">            {id=jac, dep=$</span><span class="si">{deps}</span><span class="s2">, nosync=up:jac_split}</span>
<span class="s2">        $</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + ($</span><span class="si">{var_str}</span><span class="s2"> * $</span><span class="si">{dTdot_de_str}</span><span class="s2"> + $</span><span class="si">{Tdot_str}</span><span class="s2">) </span><span class="se">\</span>
<span class="s2">            / $</span><span class="si">{T_str}</span><span class="s2"> {id=jac_split, dep=$</span><span class="si">{deps}</span><span class="s2">, nosync=up:jac}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">post_instructions</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">insn</span><span class="o">=</span><span class="n">post_instructions</span><span class="p">,</span>
        <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;up:init&#39;</span><span class="p">,</span> <span class="n">entry_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Ru&#39;</span><span class="p">:</span> <span class="n">chem</span><span class="o">.</span><span class="n">RU</span><span class="p">}</span>

    <span class="n">can_vectorize</span><span class="p">,</span> <span class="n">vec_spec</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_deep_specializer</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">atomic_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">],</span> <span class="n">split_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac_split&#39;</span><span class="p">],</span>
        <span class="n">split_size</span><span class="o">=</span><span class="n">mapstore</span><span class="o">.</span><span class="n">map_domain</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;d</span><span class="si">{0}</span><span class="s1">dotd</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;V&#39;</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="s1">&#39;P&#39;</span><span class="p">),</span>
                          <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
                          <span class="n">pre_instructions</span><span class="o">=</span><span class="n">pre_instructions</span><span class="p">,</span>
                          <span class="n">post_instructions</span><span class="o">=</span><span class="p">[</span><span class="n">post_instructions</span><span class="p">],</span>
                          <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
                          <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
                          <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
                          <span class="n">can_vectorize</span><span class="o">=</span><span class="n">can_vectorize</span><span class="p">,</span>
                          <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">vec_spec</span><span class="p">,</span>
                          <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span>
                          <span class="p">)</span></div>


<div class="viewcode-block" id="dTdotdT"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dTdotdT">[docs]</a><span class="nd">@ic</span><span class="o">.</span><span class="n">with_conditional_jacobian</span>
<span class="k">def</span> <span class="nf">dTdotdT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jac_create</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the rate of change of temprature with respect to</span>
<span class="sd">    temperature</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>
<span class="sd">    jac_create: Callable</span>
<span class="sd">        The conditional Jacobian instruction creator from :mod:`instruction_creator`</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># indicies</span>
    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="n">ns</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs_no_ns</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>

    <span class="c1"># Temperature</span>
    <span class="n">T_lp</span><span class="p">,</span> <span class="n">T_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">T_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="c1"># spec sum</span>
    <span class="n">spec_heat_tot_lp</span><span class="p">,</span> <span class="n">spec_heat_total_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_heat_total</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="c1"># dT/dt</span>
    <span class="n">dTdt_lp</span><span class="p">,</span> <span class="n">Tdot_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">T_dot</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="c1"># spec heat</span>
    <span class="n">spec_heat_lp</span><span class="p">,</span> <span class="n">spec_heat_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_heat</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

    <span class="c1"># and derivative w.r.t T</span>
    <span class="n">dspec_heat_lp</span><span class="p">,</span> <span class="n">dspec_heat_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">dspec_heat</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

    <span class="c1"># Ns derivative</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">dspec_heat_ns_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">dspec_heat</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>

    <span class="c1"># last species spec heat</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">spec_heat_ns_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_heat_ns</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="c1"># energy</span>
    <span class="n">spec_energy_lp</span><span class="p">,</span> <span class="n">spec_energy_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_energy</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

    <span class="c1"># last species energy</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">spec_energy_ns_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_energy_ns</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="c1"># molecular weights</span>
    <span class="n">mw_lp</span><span class="p">,</span> <span class="n">mw_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">mw_post_arr</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>

    <span class="c1"># concentrations</span>
    <span class="n">conc_lp</span><span class="p">,</span> <span class="n">conc_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">conc_arr</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

    <span class="c1"># last species concentration</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">conc_ns_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">conc_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>

    <span class="c1"># volume</span>
    <span class="n">V_lp</span><span class="p">,</span> <span class="n">V_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">V_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="c1"># spec rates</span>
    <span class="n">wdot_lp</span><span class="p">,</span> <span class="n">wdot_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_rates</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">spec_heat_tot_lp</span><span class="p">,</span> <span class="n">dTdt_lp</span><span class="p">,</span> <span class="n">spec_heat_lp</span><span class="p">,</span> <span class="n">dspec_heat_lp</span><span class="p">,</span>
                        <span class="n">spec_energy_lp</span><span class="p">,</span> <span class="n">mw_lp</span><span class="p">,</span> <span class="n">conc_lp</span><span class="p">,</span> <span class="n">V_lp</span><span class="p">,</span> <span class="n">wdot_lp</span><span class="p">,</span> <span class="n">T_lp</span><span class="p">])</span>

    <span class="c1"># create a precomputed instruction generator</span>
    <span class="n">precompute</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">PrecomputedInstructions</span><span class="p">()</span>

    <span class="n">pre_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    &lt;&gt; dTsum = (($</span><span class="si">{spec_heat_ns_str}</span><span class="s2"> * Tinv - $</span><span class="si">{dspec_heat_ns_str}</span><span class="s2">) </span><span class="se">\</span>
<span class="s2">        * $</span><span class="si">{conc_ns_str}</span><span class="s2">) {id=split}</span>
<span class="s2">    &lt;&gt; rate_sum = 0 {id=rate_sum}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">pre_instructions</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
        <span class="n">precompute</span><span class="p">(</span><span class="s1">&#39;Vinv&#39;</span><span class="p">,</span> <span class="n">V_str</span><span class="p">,</span> <span class="s1">&#39;INV&#39;</span><span class="p">),</span>
        <span class="n">precompute</span><span class="p">(</span><span class="s1">&#39;Tinv&#39;</span><span class="p">,</span> <span class="n">T_str</span><span class="p">,</span> <span class="s1">&#39;INV&#39;</span><span class="p">)])</span>

    <span class="c1"># add create molar rate update insn</span>
    <span class="n">jac_update</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        rate_sum = rate_sum + Vinv * $</span><span class="si">{jac_str}</span><span class="s2"> * </span><span class="se">\</span>
<span class="s2">            (-$</span><span class="si">{spec_energy_str}</span><span class="s2"> + $</span><span class="si">{spec_energy_ns_str}</span><span class="s2"> * $</span><span class="si">{mw_str}</span><span class="s2">) </span><span class="se">\</span>
<span class="s2">                {id=rate_update, dep=$</span><span class="si">{deps}</span><span class="s2">, nosync=rate_sum2}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">jac_update</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">var_name</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
        <span class="n">insn</span><span class="o">=</span><span class="n">jac_update</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;*:precompute*:rate_sum&#39;</span><span class="p">)</span>
    <span class="c1"># and place in inner loop</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        dTsum = dTsum + ($</span><span class="si">{spec_heat_ns_str}</span><span class="s2"> * Tinv - $</span><span class="si">{dspec_heat_str}</span><span class="s2">) </span><span class="se">\</span>
<span class="s2">            * $</span><span class="si">{conc_str}</span><span class="s2"> {id=dTsum_up, dep=split}</span>
<span class="s2">        rate_sum = rate_sum + $</span><span class="si">{wdot_str}</span><span class="s2"> * </span><span class="se">\</span>
<span class="s2">            (-$</span><span class="si">{spec_heat_str}</span><span class="s2"> + $</span><span class="si">{mw_str}</span><span class="s2"> * $</span><span class="si">{spec_heat_ns_str}</span><span class="s2">) {id=rate_sum2, </span><span class="se">\</span>
<span class="s2">                nosync=rate_update, dep=rate_sum}</span>
<span class="s2">        $</span><span class="si">{jac_update}</span><span class="s2"></span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="n">post_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        $</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + ($</span><span class="si">{Tdot_str}</span><span class="s2"> * dTsum + rate_sum) </span><span class="se">\</span>
<span class="s2">            / $</span><span class="si">{spec_heat_total_str}</span><span class="s2"> {id=jac, dep=$</span><span class="si">{deps}</span><span class="s2">, nosync=rate_update}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="c1"># jacobian entry</span>
    <span class="n">jac_lp</span><span class="p">,</span> <span class="n">post_instructions</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">entry_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">insn</span><span class="o">=</span><span class="n">post_instructions</span><span class="p">,</span>
        <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;rate_update:dTsum_up:rate_sum*&#39;</span><span class="p">)</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jac_lp</span><span class="p">)</span>

    <span class="n">can_vectorize</span><span class="p">,</span> <span class="n">vec_spec</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_deep_specializer</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">atomic_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">],</span> <span class="n">split_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;split&#39;</span><span class="p">],</span>
        <span class="n">split_size</span><span class="o">=</span><span class="n">mapstore</span><span class="o">.</span><span class="n">map_domain</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;dTdot_dT&#39;</span><span class="p">,</span>
                          <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
                          <span class="n">pre_instructions</span><span class="o">=</span><span class="n">pre_instructions</span><span class="p">,</span>
                          <span class="n">post_instructions</span><span class="o">=</span><span class="n">post_instructions</span><span class="p">,</span>
                          <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
                          <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
                          <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
                          <span class="n">can_vectorize</span><span class="o">=</span><span class="n">can_vectorize</span><span class="p">,</span>
                          <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">vec_spec</span><span class="p">,</span>
                          <span class="p">)</span></div>


<div class="viewcode-block" id="dEdotdT"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dEdotdT">[docs]</a><span class="nd">@ic</span><span class="o">.</span><span class="n">with_conditional_jacobian</span>
<span class="k">def</span> <span class="nf">dEdotdT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">jac_create</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the rate of change of the extra variable (volume/pressure</span>
<span class="sd">    for constant pressure/volume respectively) with respect to temperature</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>
<span class="sd">    jac_create: Callable</span>
<span class="sd">        The conditional Jacobian instruction creator from :mod:`instruction_creator`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="n">ns</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs_no_ns</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>

    <span class="c1"># create arrays</span>
    <span class="n">mw_lp</span><span class="p">,</span> <span class="n">mw_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">mw_post_arr</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
    <span class="n">V_lp</span><span class="p">,</span> <span class="n">V_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">V_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">P_lp</span><span class="p">,</span> <span class="n">P_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">P_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">T_lp</span><span class="p">,</span> <span class="n">T_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">T_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">wdot_lp</span><span class="p">,</span> <span class="n">wdot_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_rates</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
    <span class="n">dphi_lp</span><span class="p">,</span> <span class="n">Tdot_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">T_dot</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">mw_lp</span><span class="p">,</span> <span class="n">V_lp</span><span class="p">,</span> <span class="n">P_lp</span><span class="p">,</span> <span class="n">T_lp</span><span class="p">,</span> <span class="n">wdot_lp</span><span class="p">,</span> <span class="n">dphi_lp</span><span class="p">])</span>

    <span class="c1"># instructions</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">dTdot_dT_str</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># create a precomputed instruction generator</span>
    <span class="n">precompute</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">PrecomputedInstructions</span><span class="p">()</span>

    <span class="n">pre_instructions</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&lt;&gt; sum = 0 {id=init}&#39;</span><span class="p">,</span>
                        <span class="n">precompute</span><span class="p">(</span><span class="s1">&#39;Tinv&#39;</span><span class="p">,</span> <span class="n">T_str</span><span class="p">,</span> <span class="s1">&#39;INV&#39;</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">conp</span><span class="p">:</span>
        <span class="n">pre_instructions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">precompute</span><span class="p">(</span><span class="s1">&#39;Vinv&#39;</span><span class="p">,</span> <span class="n">V_str</span><span class="p">,</span> <span class="s1">&#39;INV&#39;</span><span class="p">))</span>
        <span class="c1"># sums</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            sum = sum + (1 - $</span><span class="si">{mw_str}</span><span class="s2">) * (Vinv * $</span><span class="si">{jac_str}</span><span class="s2"> + Tinv * </span><span class="se">\</span>
<span class="s2">                $</span><span class="si">{wdot_str}</span><span class="s2">) {id=sum, dep=$</span><span class="si">{deps}</span><span class="s2">}</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
        <span class="c1"># sum finish</span>
        <span class="n">post_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            $</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + Ru * $</span><span class="si">{T_str}</span><span class="s2"> * $</span><span class="si">{V_str}</span><span class="s2"> * sum / $</span><span class="si">{P_str}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                {id=jac, dep=$</span><span class="si">{deps}</span><span class="s2">, nosync=sum:jac_split}</span>
<span class="s2">            $</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + $</span><span class="si">{V_str}</span><span class="s2"> * Tinv * </span><span class="se">\</span>
<span class="s2">                ($</span><span class="si">{dTdot_dT_str}</span><span class="s2"> - Tinv * $</span><span class="si">{Tdot_str}</span><span class="s2">) {id=jac_split, dep=$</span><span class="si">{deps}</span><span class="s2">,</span><span class="se">\</span>
<span class="s2">                    nosync=sum:jac}</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">myname</span> <span class="o">=</span> <span class="n">precompute</span><span class="o">.</span><span class="n">reserve_name</span><span class="p">()</span>
        <span class="n">pre_instructions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Template</span><span class="p">(</span>
            <span class="s1">&#39;&lt;&gt; fac = $</span><span class="si">{T_str}</span><span class="s1"> / $</span><span class="si">{V_str}</span><span class="s1"> {id=$</span><span class="si">{myname}</span><span class="s1">}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span>
            <span class="o">**</span><span class="nb">locals</span><span class="p">()))</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            sum = sum + (1 - $</span><span class="si">{mw_str}</span><span class="s2">) * ($</span><span class="si">{jac_str}</span><span class="s2"> * fac + </span><span class="se">\</span>
<span class="s2">                $</span><span class="si">{wdot_str}</span><span class="s2">) {id=sum, dep=$</span><span class="si">{deps}</span><span class="s2">}</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
        <span class="n">post_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            $</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + Ru * sum {id=jac, nosync=sum:jac_split,</span><span class="se">\</span>
<span class="s2">                dep=$</span><span class="si">{deps}</span><span class="s2">}</span>
<span class="s2">            $</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + $</span><span class="si">{P_str}</span><span class="s2"> * </span><span class="se">\</span>
<span class="s2">                ($</span><span class="si">{dTdot_dT_str}</span><span class="s2"> - $</span><span class="si">{Tdot_str}</span><span class="s2"> * Tinv) * Tinv {id=jac_split, </span><span class="se">\</span>
<span class="s2">                dep=$</span><span class="si">{deps}</span><span class="s2">, nosync=sum:jac}</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">instructions</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">var_name</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
        <span class="n">insn</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;*:init:&#39;</span> <span class="o">+</span> <span class="n">precompute</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>
    <span class="n">jac_lp</span><span class="p">,</span> <span class="n">post_instructions</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">insn</span><span class="o">=</span><span class="n">post_instructions</span><span class="p">,</span>
        <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jac_lp</span><span class="p">)</span>

    <span class="n">can_vectorize</span><span class="p">,</span> <span class="n">vec_spec</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_deep_specializer</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">atomic_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">],</span> <span class="n">split_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac_split&#39;</span><span class="p">],</span>
        <span class="n">split_size</span><span class="o">=</span><span class="n">mapstore</span><span class="o">.</span><span class="n">map_domain</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Ru&#39;</span><span class="p">:</span> <span class="n">chem</span><span class="o">.</span><span class="n">RU</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;d</span><span class="si">{}</span><span class="s1">dotdT&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;V&#39;</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="s1">&#39;P&#39;</span><span class="p">),</span>
                          <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
                          <span class="n">pre_instructions</span><span class="o">=</span><span class="n">pre_instructions</span><span class="p">,</span>
                          <span class="n">post_instructions</span><span class="o">=</span><span class="n">post_instructions</span><span class="p">,</span>
                          <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
                          <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
                          <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
                          <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
                          <span class="n">can_vectorize</span><span class="o">=</span><span class="n">can_vectorize</span><span class="p">,</span>
                          <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">vec_spec</span>
                          <span class="p">)</span></div>


<span class="nd">@ic</span><span class="o">.</span><span class="n">with_conditional_jacobian</span>
<span class="k">def</span> <span class="nf">__dcidT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">rxn_type</span><span class="o">=</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span><span class="p">,</span> <span class="n">jac_create</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the pressure modification term for all third body /</span>
<span class="sd">    falloff / chemically activated reactions with respect to temperature</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    rxn_type: [reaction_type.thd, falloff_form.lind, falloff_form.sri,</span>
<span class="sd">               falloff_form.troe]</span>
<span class="sd">        The reaction type to generate the pressure modification derivative for</span>
<span class="sd">    jac_create: Callable</span>
<span class="sd">        The conditional Jacobian instruction creator from :mod:`instruction_creator`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="n">num_range_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_thd_only</span><span class="p">,</span>
                      <span class="n">falloff_form</span><span class="o">.</span><span class="n">lind</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_lind</span><span class="p">,</span>
                      <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_sri</span><span class="p">,</span>
                      <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_troe</span><span class="p">}</span>
    <span class="n">thd_range_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">thd_only_map</span><span class="p">,</span>
                      <span class="n">falloff_form</span><span class="o">.</span><span class="n">lind</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">fall_to_thd_map</span><span class="p">,</span>
                      <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">fall_to_thd_map</span><span class="p">,</span>
                      <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">fall_to_thd_map</span><span class="p">}</span>
    <span class="n">fall_range_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">falloff_form</span><span class="o">.</span><span class="n">lind</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">lind_map</span><span class="p">,</span>
                       <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">sri_map</span><span class="p">,</span>
                       <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">troe_map</span><span class="p">}</span>
    <span class="n">name_description</span> <span class="o">=</span> <span class="p">{</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span><span class="p">:</span> <span class="s1">&#39;thd&#39;</span><span class="p">,</span>
                        <span class="n">falloff_form</span><span class="o">.</span><span class="n">lind</span><span class="p">:</span> <span class="s1">&#39;lind&#39;</span><span class="p">,</span>
                        <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">:</span> <span class="s1">&#39;sri&#39;</span><span class="p">,</span>
                        <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">:</span> <span class="s1">&#39;troe&#39;</span><span class="p">}</span>
    <span class="c1"># get num</span>
    <span class="n">num_range</span> <span class="o">=</span> <span class="n">num_range_dict</span><span class="p">[</span><span class="n">rxn_type</span><span class="p">]</span>
    <span class="n">thd_range</span> <span class="o">=</span> <span class="n">thd_range_dict</span><span class="p">[</span><span class="n">rxn_type</span><span class="p">]</span>
    <span class="n">rxn_range</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">thd_map</span>

    <span class="c1"># number of species</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># create mapstore</span>
    <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">num_range</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>

    <span class="c1"># setup static mappings</span>

    <span class="k">if</span> <span class="n">rxn_type</span> <span class="ow">in</span> <span class="n">fall_range_dict</span><span class="p">:</span>
        <span class="n">fall_range</span> <span class="o">=</span> <span class="n">fall_range_dict</span><span class="p">[</span><span class="n">rxn_type</span><span class="p">]</span>

        <span class="c1"># falloff index depends on num_range</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">fall_range</span><span class="p">,</span> <span class="n">num_range</span><span class="p">)</span>

        <span class="c1"># and the third body index depends on the falloff index</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">thd_range</span><span class="p">,</span> <span class="n">fall_range</span><span class="p">)</span>

    <span class="c1"># and finally the reaction index depends on the third body index</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">rxn_range</span><span class="p">,</span> <span class="n">thd_range</span><span class="p">)</span>

    <span class="c1"># setup third body stuff</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">thd_type</span><span class="p">,</span> <span class="n">thd_range</span><span class="p">)</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">thd_offset</span><span class="p">,</span> <span class="n">thd_range</span><span class="p">)</span>

    <span class="c1"># and place rop&#39;s / species maps, etc.</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rop_fwd</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rop_rev</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">)</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rxn_type</span> <span class="o">!=</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span><span class="p">:</span>
        <span class="c1"># pressure mod term</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span> <span class="n">thd_range</span><span class="p">)</span>
        <span class="c1"># falloff type</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">fall_type</span><span class="p">,</span> <span class="n">fall_range</span><span class="p">)</span>
        <span class="c1"># need falloff blending / reduced pressure</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Fi</span><span class="p">,</span> <span class="n">fall_range</span><span class="p">)</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Pr</span><span class="p">,</span> <span class="n">fall_range</span><span class="p">)</span>

        <span class="c1"># in addition we (most likely) need the falloff / regular kf rates</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kf</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kf_fall</span><span class="p">,</span> <span class="n">fall_range</span><span class="p">)</span>

        <span class="c1"># and the beta / Ta parameters for falloff / regular kf</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">fall_beta</span><span class="p">,</span> <span class="n">fall_range</span><span class="p">)</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">fall_Ta</span><span class="p">,</span> <span class="n">fall_range</span><span class="p">)</span>

        <span class="c1"># the regular kf params require the simple_mask</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">simple_mask</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">simple_beta</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">simple_mask</span><span class="p">)</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">simple_Ta</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">simple_mask</span><span class="p">)</span>

    <span class="c1"># get the third body types</span>
    <span class="n">thd_type_lp</span><span class="p">,</span> <span class="n">thd_type_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_type</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
    <span class="n">thd_offset_lp</span><span class="p">,</span> <span class="n">thd_offset_next_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_offset</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># get third body efficiencies &amp; species</span>
    <span class="n">thd_eff_lp</span><span class="p">,</span> <span class="n">thd_eff_last_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_eff</span><span class="p">,</span> <span class="n">thd_offset_next_str</span><span class="p">,</span> <span class="n">affine</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">thd_spec_lp</span><span class="p">,</span> <span class="n">thd_spec_last_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_spec</span><span class="p">,</span> <span class="n">thd_offset_next_str</span><span class="p">,</span> <span class="n">affine</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">k_ind</span> <span class="o">=</span> <span class="s1">&#39;k_ind&#39;</span>
    <span class="c1"># nu offsets</span>
    <span class="n">nu_offset_lp</span><span class="p">,</span> <span class="n">offset_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">offset_next_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># setup species k loop</span>
    <span class="n">extra_inames</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k_ind</span><span class="p">,</span> <span class="s1">&#39;offset &lt;= </span><span class="si">{}</span><span class="s1"> &lt; offset_next&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k_ind</span><span class="p">))]</span>

    <span class="c1"># reac and prod nu for net</span>
    <span class="n">nu_lp</span><span class="p">,</span> <span class="n">reac_nu_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_reac_nu</span><span class="p">,</span> <span class="n">k_ind</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">k_ind</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">prod_nu_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_prod_nu</span><span class="p">,</span> <span class="n">k_ind</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">k_ind</span><span class="p">)</span>
    <span class="c1"># get species</span>
    <span class="n">spec_lp</span><span class="p">,</span> <span class="n">spec_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec</span><span class="p">,</span> <span class="n">k_ind</span><span class="p">)</span>

    <span class="c1"># ropnet</span>
    <span class="n">rop_fwd_lp</span><span class="p">,</span> <span class="n">rop_fwd_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rop_fwd</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
    <span class="n">rop_rev_lp</span><span class="p">,</span> <span class="n">rop_rev_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rop_rev</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

    <span class="c1"># T, P, V</span>
    <span class="n">T_lp</span><span class="p">,</span> <span class="n">T_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">T_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">V_lp</span><span class="p">,</span> <span class="n">V_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">V_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">P_lp</span><span class="p">,</span> <span class="n">P_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">P_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="c1"># update kernel data</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">thd_type_lp</span><span class="p">,</span> <span class="n">thd_offset_lp</span><span class="p">,</span> <span class="n">thd_eff_lp</span><span class="p">,</span> <span class="n">thd_spec_lp</span><span class="p">,</span>
                        <span class="n">nu_offset_lp</span><span class="p">,</span> <span class="n">nu_lp</span><span class="p">,</span> <span class="n">spec_lp</span><span class="p">,</span> <span class="n">rop_fwd_lp</span><span class="p">,</span> <span class="n">rop_rev_lp</span><span class="p">,</span>
                        <span class="n">T_lp</span><span class="p">,</span> <span class="n">V_lp</span><span class="p">,</span> <span class="n">P_lp</span><span class="p">])</span>
    <span class="c1"># create a precomputed instruction generator</span>
    <span class="n">precompute</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">PrecomputedInstructions</span><span class="p">()</span>

    <span class="n">pre_instructions</span> <span class="o">=</span> <span class="p">[</span><span class="n">precompute</span><span class="p">(</span><span class="s1">&#39;Tinv&#39;</span><span class="p">,</span> <span class="n">T_str</span><span class="p">,</span> <span class="s1">&#39;INV&#39;</span><span class="p">)]</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">manglers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># by default we are using the third body factors (these may be changed</span>
    <span class="c1"># in the falloff types below)</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="s1">&#39;dci_thd_dT_fac&#39;</span>
    <span class="n">thd_fac</span> <span class="o">=</span> <span class="s1">&#39; * </span><span class="si">{}</span><span class="s1"> * rop_net &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">V_str</span><span class="p">)</span>
    <span class="c1"># use a no-op for third body reactions, w/ anchor for dependencies</span>
    <span class="n">fall_instructions</span> <span class="o">=</span> <span class="s1">&#39;... nop {id=dfall_final}&#39;</span>
    <span class="k">if</span> <span class="n">rxn_type</span> <span class="o">!=</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span><span class="p">:</span>
        <span class="c1"># update factors</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="s1">&#39;dci_fall_dT&#39;</span>
        <span class="n">thd_fac</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="c1"># create arrays</span>
        <span class="n">pres_mod_lp</span><span class="p">,</span> <span class="n">pres_mod_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">fall_type_lp</span><span class="p">,</span> <span class="n">fall_type_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">fall_type</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
        <span class="n">Fi_lp</span><span class="p">,</span> <span class="n">Fi_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Fi</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">Pr_lp</span><span class="p">,</span> <span class="n">Pr_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Pr</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">kf_lp</span><span class="p">,</span> <span class="n">kf_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kf</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">s_beta_lp</span><span class="p">,</span> <span class="n">s_beta_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">simple_beta</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
        <span class="n">s_Ta_lp</span><span class="p">,</span> <span class="n">s_Ta_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">simple_Ta</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
        <span class="n">kf_fall_lp</span><span class="p">,</span> <span class="n">kf_fall_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">kf_fall</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">f_beta_lp</span><span class="p">,</span> <span class="n">f_beta_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">fall_beta</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
        <span class="n">f_Ta_lp</span><span class="p">,</span> <span class="n">f_Ta_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">fall_Ta</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>

        <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pres_mod_lp</span><span class="p">,</span> <span class="n">fall_type_lp</span><span class="p">,</span> <span class="n">Fi_lp</span><span class="p">,</span> <span class="n">Pr_lp</span><span class="p">,</span> <span class="n">kf_lp</span><span class="p">,</span>
                            <span class="n">s_beta_lp</span><span class="p">,</span> <span class="n">s_Ta_lp</span><span class="p">,</span> <span class="n">kf_fall_lp</span><span class="p">,</span> <span class="n">f_beta_lp</span><span class="p">,</span>
                            <span class="n">f_Ta_lp</span><span class="p">])</span>

        <span class="c1"># check for Troe / SRI</span>
        <span class="k">if</span> <span class="n">rxn_type</span> <span class="o">==</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">:</span>
            <span class="n">Atroe_lp</span><span class="p">,</span> <span class="n">Atroe_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">Atroe</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
            <span class="n">Btroe_lp</span><span class="p">,</span> <span class="n">Btroe_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">Btroe</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
            <span class="n">Fcent_lp</span><span class="p">,</span> <span class="n">Fcent_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">Fcent</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
            <span class="n">troe_a_lp</span><span class="p">,</span> <span class="n">troe_a_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">troe_a</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">troe_T1_lp</span><span class="p">,</span> <span class="n">troe_T1_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">troe_T1</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">troe_T2_lp</span><span class="p">,</span> <span class="n">troe_T2_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">troe_T2</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">troe_T3_lp</span><span class="p">,</span> <span class="n">troe_T3_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">troe_T3</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">Atroe_lp</span><span class="p">,</span> <span class="n">Btroe_lp</span><span class="p">,</span> <span class="n">Fcent_lp</span><span class="p">,</span> <span class="n">troe_a_lp</span><span class="p">,</span>
                                <span class="n">troe_T1_lp</span><span class="p">,</span> <span class="n">troe_T2_lp</span><span class="p">,</span> <span class="n">troe_T3_lp</span><span class="p">])</span>
            <span class="n">pre_instructions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">precompute</span><span class="p">(</span><span class="s1">&#39;Tval&#39;</span><span class="p">,</span> <span class="n">T_str</span><span class="p">,</span> <span class="s1">&#39;VAL&#39;</span><span class="p">))</span>
            <span class="n">dFi_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                &lt;&gt; dFcent = -$</span><span class="si">{troe_a_str}</span><span class="s2"> * $</span><span class="si">{troe_T1_str}</span><span class="s2"> * </span><span class="se">\</span>
<span class="s2">                exp(-Tval * $</span><span class="si">{troe_T1_str}</span><span class="s2">) + ($</span><span class="si">{troe_a_str}</span><span class="s2"> - 1) * $</span><span class="si">{troe_T3_str}</span><span class="s2"> *</span><span class="se">\</span>
<span class="s2">                exp(-Tval * $</span><span class="si">{troe_T3_str}</span><span class="s2">) + $</span><span class="si">{troe_T2_str}</span><span class="s2"> * Tinv * Tinv * </span><span class="se">\</span>
<span class="s2">                    exp(-$</span><span class="si">{troe_T2_str}</span><span class="s2"> * Tinv)</span>
<span class="s2">                &lt;&gt; logFcent = log($</span><span class="si">{Fcent_str}</span><span class="s2">)</span>
<span class="s2">                &lt;&gt; absq = $</span><span class="si">{Atroe_str}</span><span class="s2"> * $</span><span class="si">{Atroe_str}</span><span class="s2"> + $</span><span class="si">{Btroe_str}</span><span class="s2"> * $</span><span class="si">{Btroe_str}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                    {id=ab_init}</span>
<span class="s2">                &lt;&gt; absqsq = absq * absq {id=ab_fin}</span>
<span class="s2">                &lt;&gt; dFi = -$</span><span class="si">{Btroe_str}</span><span class="s2"> * (2 * $</span><span class="si">{Atroe_str}</span><span class="s2"> * $</span><span class="si">{Fcent_str}</span><span class="s2"> * </span><span class="se">\</span>
<span class="s2">                (0.14 * $</span><span class="si">{Atroe_str}</span><span class="s2"> + $</span><span class="si">{Btroe_str}</span><span class="s2">) * </span><span class="se">\</span>
<span class="s2">                ($</span><span class="si">{Pr_str}</span><span class="s2"> * theta_Pr + theta_no_Pr) * logFcent + </span><span class="se">\</span>
<span class="s2">                $</span><span class="si">{Pr_str}</span><span class="s2"> * dFcent * (2 * $</span><span class="si">{Atroe_str}</span><span class="s2"> * </span><span class="se">\</span>
<span class="s2">                (1.1762 * $</span><span class="si">{Atroe_str}</span><span class="s2"> - 0.67 * $</span><span class="si">{Btroe_str}</span><span class="s2">) * logFcent </span><span class="se">\</span>
<span class="s2">                - $</span><span class="si">{Btroe_str}</span><span class="s2"> * absq * logten)) / </span><span class="se">\</span>
<span class="s2">                ($</span><span class="si">{Fcent_str}</span><span class="s2"> * fmax(1e-300d, $</span><span class="si">{Pr_str}</span><span class="s2">) * absqsq * logten) </span><span class="se">\</span>
<span class="s2">                    {id=dFi_final}</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
            <span class="n">manglers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lp_pregen</span><span class="o">.</span><span class="n">fmax</span><span class="p">())</span>
            <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;logten&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">rxn_type</span> <span class="o">==</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">:</span>
            <span class="n">X_lp</span><span class="p">,</span> <span class="n">X_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">X_sri</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
            <span class="n">a_lp</span><span class="p">,</span> <span class="n">a_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">sri_a</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">b_lp</span><span class="p">,</span> <span class="n">b_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">sri_b</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">c_lp</span><span class="p">,</span> <span class="n">c_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">sri_c</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">d_lp</span><span class="p">,</span> <span class="n">d_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">sri_d</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">e_lp</span><span class="p">,</span> <span class="n">e_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">sri_e</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">X_lp</span><span class="p">,</span> <span class="n">a_lp</span><span class="p">,</span> <span class="n">b_lp</span><span class="p">,</span> <span class="n">c_lp</span><span class="p">,</span> <span class="n">d_lp</span><span class="p">,</span> <span class="n">e_lp</span><span class="p">])</span>
            <span class="n">pre_instructions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">precompute</span><span class="p">(</span><span class="s1">&#39;Tval&#39;</span><span class="p">,</span> <span class="n">T_str</span><span class="p">,</span> <span class="s1">&#39;VAL&#39;</span><span class="p">))</span>
            <span class="n">manglers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lp_pregen</span><span class="o">.</span><span class="n">fmax</span><span class="p">())</span>

            <span class="n">dFi_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                &lt;&gt; cinv = 1 / $</span><span class="si">{c_str}</span><span class="s2"></span>
<span class="s2">                &lt;&gt; dFi = -$</span><span class="si">{X_str}</span><span class="s2"> * (</span><span class="se">\</span>
<span class="s2">                exp(-Tval * cinv) * cinv - $</span><span class="si">{a_str}</span><span class="s2"> * $</span><span class="si">{b_str}</span><span class="s2"> * Tinv * </span><span class="se">\</span>
<span class="s2">                Tinv * exp(-$</span><span class="si">{b_str}</span><span class="s2"> * Tinv)) / </span><span class="se">\</span>
<span class="s2">                ($</span><span class="si">{a_str}</span><span class="s2"> * exp(-$</span><span class="si">{b_str}</span><span class="s2"> * Tinv) + exp(-Tval * cinv)) </span><span class="se">\</span>
<span class="s2">                + $</span><span class="si">{e_str}</span><span class="s2"> * Tinv - </span><span class="se">\</span>
<span class="s2">                2 * $</span><span class="si">{X_str}</span><span class="s2"> * $</span><span class="si">{X_str}</span><span class="s2"> * </span><span class="se">\</span>
<span class="s2">                log($</span><span class="si">{a_str}</span><span class="s2"> * exp(-$</span><span class="si">{b_str}</span><span class="s2"> * Tinv) + exp(-Tval * cinv)) * </span><span class="se">\</span>
<span class="s2">                ($</span><span class="si">{Pr_str}</span><span class="s2"> * theta_Pr + theta_no_Pr) * </span><span class="se">\</span>
<span class="s2">                log(fmax(1e-300d, $</span><span class="si">{Pr_str}</span><span class="s2">)) / </span><span class="se">\</span>
<span class="s2">                (fmax(1e-300d, $</span><span class="si">{Pr_str}</span><span class="s2">) * logtensquared) {id=dFi_final}</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
            <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;logtensquared&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dFi_instructions</span> <span class="o">=</span> <span class="s1">&#39;&lt;&gt; dFi = 0 {id=dFi_final}&#39;</span>

        <span class="n">fall_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        if $</span><span class="si">{fall_type_str}</span><span class="s2"></span>
<span class="s2">            # chemically activated</span>
<span class="s2">            &lt;&gt;kf_0 = $</span><span class="si">{kf_str}</span><span class="s2"> {id=kf_chem, nosync=kf_fall}</span>
<span class="s2">            &lt;&gt;beta_0 = $</span><span class="si">{s_beta_str}</span><span class="s2"> {id=beta0_chem, nosync=beta0_fall}</span>
<span class="s2">            &lt;&gt;Ta_0 = $</span><span class="si">{s_Ta_str}</span><span class="s2"> {id=Ta0_chem, nosync=Ta0_fall}</span>
<span class="s2">            &lt;&gt;kf_inf = $</span><span class="si">{kf_fall_str}</span><span class="s2"> {id=kf_inf_chem, nosync=kf_inf_fall}</span>
<span class="s2">            &lt;&gt;beta_inf = $</span><span class="si">{f_beta_str}</span><span class="s2"> {id=betaf_chem, nosync=betaf_fall}</span>
<span class="s2">            &lt;&gt;Ta_inf = $</span><span class="si">{f_Ta_str}</span><span class="s2"> {id=Taf_chem, nosync=Taf_fall}</span>
<span class="s2">        else</span>
<span class="s2">            # fall-off</span>
<span class="s2">            kf_0 = $</span><span class="si">{kf_fall_str}</span><span class="s2"> {id=kf_fall, nosync=kf_chem}</span>
<span class="s2">            beta_0 = $</span><span class="si">{f_beta_str}</span><span class="s2"> {id=beta0_fall, nosync=beta0_chem}</span>
<span class="s2">            Ta_0 = $</span><span class="si">{f_Ta_str}</span><span class="s2"> {id=Ta0_fall, nosync=Ta0_chem}</span>
<span class="s2">            kf_inf = $</span><span class="si">{kf_str}</span><span class="s2"> {id=kf_inf_fall, nosync=kf_inf_chem}</span>
<span class="s2">            beta_inf = $</span><span class="si">{s_beta_str}</span><span class="s2"> {id=betaf_fall, nosync=betaf_chem}</span>
<span class="s2">            Ta_inf = $</span><span class="si">{s_Ta_str}</span><span class="s2"> {id=Taf_fall, nosync=Taf_chem}</span>
<span class="s2">        end</span>
<span class="s2">        &lt;&gt; pmod = $</span><span class="si">{pres_mod_str}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; theta_Pr = Tinv * (beta_0 - beta_inf + (Ta_0 - Ta_inf) * Tinv) </span><span class="se">\</span>
<span class="s2">            {id=theta_Pr, dep=beta*:kf*:Ta*}</span>
<span class="s2">        &lt;&gt; theta_no_Pr = dci_thd_dT_fac * kf_0 / kf_inf {id=theta_No_Pr, dep=kf*}</span>
<span class="s2">        $</span><span class="si">{dFi_instructions}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; dci_fall_dT = pmod * (-($</span><span class="si">{Pr_str}</span><span class="s2"> * theta_Pr + theta_no_Pr) / </span><span class="se">\</span>
<span class="s2">            ($</span><span class="si">{Pr_str}</span><span class="s2"> + 1) + dFi) {id=dfall_init}</span>
<span class="s2">        if not $</span><span class="si">{fall_type_str}</span><span class="s2"></span>
<span class="s2">            # falloff</span>
<span class="s2">            dci_fall_dT = dci_fall_dT + theta_Pr * pmod + $</span><span class="si">{Fi_str}</span><span class="s2"> * theta_no_Pr / </span><span class="se">\</span>
<span class="s2">                ($</span><span class="si">{Pr_str}</span><span class="s2"> + 1) {id=dfall_up1, dep=dfall_init}</span>
<span class="s2">        end</span>
<span class="s2">        dci_fall_dT = dci_fall_dT * $</span><span class="si">{V_str}</span><span class="s2"> * rop_net </span><span class="se">\</span>
<span class="s2">            {id=dfall_final, dep=dfall_up1}</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="c1"># and jac update insn</span>
    <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
        <span class="s2">&quot;$</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + ($</span><span class="si">{prod_nu_k_str}</span><span class="s2"> - $</span><span class="si">{reac_nu_k_str}</span><span class="s2">) * &quot;</span>
        <span class="s2">&quot;$</span><span class="si">{factor}</span><span class="s2"> {id=jac, dep=$</span><span class="si">{deps}</span><span class="s2">}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">jac_lp</span><span class="p">,</span> <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">spec_k_str</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">spec_k_str</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
        <span class="n">insn</span><span class="o">=</span><span class="n">jac_update_insn</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;dfall_final&#39;</span><span class="p">)</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jac_lp</span><span class="p">)</span>

    <span class="n">rop_net_rev_update</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_update_instruction</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">rop_rev</span><span class="p">,</span>
        <span class="n">Template</span><span class="p">(</span>
            <span class="s1">&#39;rop_net = rop_net - $</span><span class="si">{rop_rev_str}</span><span class="s1"> </span><span class="se">\</span>
<span class="s1">                        {id=rop_net_up, dep=rop_net_init}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span>
            <span class="o">**</span><span class="nb">locals</span><span class="p">()))</span>
    <span class="n">mix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">thd_body_type</span><span class="o">.</span><span class="n">mix</span><span class="p">)</span>
    <span class="n">spec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">thd_body_type</span><span class="o">.</span><span class="n">species</span><span class="p">)</span>
    <span class="c1"># and instructions</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    &lt;&gt; rop_net = $</span><span class="si">{rop_fwd_str}</span><span class="s2"> {id=rop_net_init}</span>
<span class="s2">    $</span><span class="si">{rop_net_rev_update}</span><span class="s2"></span>
<span class="s2">    &lt;&gt; mod = 1 {id=mod_init}</span>
<span class="s2">    if $</span><span class="si">{thd_type_str}</span><span class="s2"> == $</span><span class="si">{mix}</span><span class="s2"> and $</span><span class="si">{thd_spec_last_str}</span><span class="s2"> == $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">        mod = $</span><span class="si">{thd_eff_last_str}</span><span class="s2"> {id=mod_mix, dep=mod_init}</span>
<span class="s2">    end</span>
<span class="s2">    if $</span><span class="si">{thd_type_str}</span><span class="s2"> == $</span><span class="si">{spec}</span><span class="s2"></span>
<span class="s2">        mod = $</span><span class="si">{thd_spec_last_str}</span><span class="s2"> == $</span><span class="si">{ns}</span><span class="s2"> {id=mod_spec, dep=mod_init}</span>
<span class="s2">    end</span>
<span class="s2">    &lt;&gt; dci_thd_dT_fac = -$</span><span class="si">{P_str}</span><span class="s2"> * mod * Ru_inv * Tinv * Tinv$</span><span class="si">{thd_fac}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">        {dep=mod*:rop_net*}</span>
<span class="s2">    $</span><span class="si">{fall_instructions}</span><span class="s2"></span>
<span class="s2">    &lt;&gt; offset = $</span><span class="si">{offset_str}</span><span class="s2"></span>
<span class="s2">    &lt;&gt; offset_next = $</span><span class="si">{offset_next_str}</span><span class="s2"></span>
<span class="s2">    for $</span><span class="si">{k_ind}</span><span class="s2"></span>
<span class="s2">        if $</span><span class="si">{spec_k_str}</span><span class="s2"> != $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">            $</span><span class="si">{jac_update_insn}</span><span class="s2"></span>
<span class="s2">        end</span>
<span class="s2">    end</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="n">can_vectorize</span><span class="p">,</span> <span class="n">vec_spec</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_deep_specializer</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">atomic_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">])</span>

    <span class="n">parameters</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;Ru_inv&#39;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">chem</span><span class="o">.</span><span class="n">RU</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;dci_</span><span class="si">{}</span><span class="s1">_dT&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">name_description</span><span class="p">[</span><span class="n">rxn_type</span><span class="p">]),</span>
        <span class="n">extra_inames</span><span class="o">=</span><span class="n">extra_inames</span><span class="p">,</span>
        <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
        <span class="n">pre_instructions</span><span class="o">=</span><span class="n">pre_instructions</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
        <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
        <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
        <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
        <span class="n">manglers</span><span class="o">=</span><span class="n">manglers</span><span class="p">,</span>
        <span class="n">can_vectorize</span><span class="o">=</span><span class="n">can_vectorize</span><span class="p">,</span>
        <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">vec_spec</span>
    <span class="p">)</span>


<div class="viewcode-block" id="dci_thd_dT"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dci_thd_dT">[docs]</a><span class="k">def</span> <span class="nf">dci_thd_dT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the pressure modification term w.r.t. Temperature</span>
<span class="sd">    for third body reactions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">__dcidT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span>
                                <span class="n">reaction_type</span><span class="o">.</span><span class="n">thd</span><span class="p">)]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="dci_lind_dT"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dci_lind_dT">[docs]</a><span class="k">def</span> <span class="nf">dci_lind_dT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the pressure modification term w.r.t. Temperature</span>
<span class="sd">    for Lindemann falloff reactions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">__dcidT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span>
                                <span class="n">falloff_form</span><span class="o">.</span><span class="n">lind</span><span class="p">)]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="dci_troe_dT"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dci_troe_dT">[docs]</a><span class="k">def</span> <span class="nf">dci_troe_dT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the pressure modification term w.r.t. Temperature</span>
<span class="sd">    for Troe falloff reactions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">__dcidT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span>
                                <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">)]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="dci_sri_dT"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dci_sri_dT">[docs]</a><span class="k">def</span> <span class="nf">dci_sri_dT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the pressure modification term w.r.t. Temperature</span>
<span class="sd">    for SRI falloff reactions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">__dcidT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span>
                                <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">)]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<span class="nd">@ic</span><span class="o">.</span><span class="n">with_conditional_jacobian</span>
<span class="k">def</span> <span class="nf">__dRopidT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">do_ns</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rxn_type</span><span class="o">=</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">elementary</span><span class="p">,</span> <span class="n">maxP</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">maxT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jac_create</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the rate of progress (for all reaction types)</span>
<span class="sd">    with respect to temperature</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    do_ns : bool [False]</span>
<span class="sd">        If True, generate kernel to handle derivatives of the last species&#39;</span>
<span class="sd">        concentration w.r.t. temperature</span>
<span class="sd">    rxn_type : [reaction_type.thd, reaction_type.plog, reaction_type.cheb]</span>
<span class="sd">        The type of reaction to generate fore</span>
<span class="sd">    maxP: int [None]</span>
<span class="sd">        The maximum number of pressure interpolations of any reaction in</span>
<span class="sd">        the mechanism.</span>
<span class="sd">        - For PLOG - the maximum number of pressure interpolations of any</span>
<span class="sd">        reaction in the mechanism.</span>
<span class="sd">        - For CHEB - The maximum degree of temperature polynomials for</span>
<span class="sd">        chebyshev reactions in this mechanism</span>
<span class="sd">    maxT : int [None]</span>
<span class="sd">        The maximum degree of temperature polynomials for chebyshev reactions</span>
<span class="sd">        in this mechanism</span>
<span class="sd">    jac_create: Callable</span>
<span class="sd">        The conditional Jacobian instruction creator from :mod:`instruction_creator`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># indicies</span>
    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># check rxn type</span>
    <span class="k">if</span> <span class="n">rxn_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">,</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">]</span> <span class="ow">and</span> <span class="n">do_ns</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># this is handled by do_ns w / elementary</span>
    <span class="k">elif</span> <span class="n">rxn_type</span> <span class="o">==</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">maxP</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;The maximum # of pressure interpolations must be&#39;</span>
                      <span class="s1">&#39; supplied&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">rxn_type</span> <span class="o">==</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">maxP</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;The maximum chebyshev pressure polynomial degree must &#39;</span>
                      <span class="s1">&#39; be supplied&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">maxT</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;The maximum chebyshev temperature polynomial degree &#39;</span>
                      <span class="s1">&#39; must be supplied&#39;</span><span class="p">)</span>

    <span class="n">num_range_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">elementary</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_simple</span><span class="p">,</span>
                      <span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_plog</span><span class="p">,</span>
                      <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_cheb</span><span class="p">}</span>
    <span class="c1"># get num</span>
    <span class="n">num_range</span> <span class="o">=</span> <span class="n">num_range_dict</span><span class="p">[</span><span class="n">rxn_type</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> <span class="k">else</span>\
        <span class="n">namestore</span><span class="o">.</span><span class="n">num_rxn_has_ns</span>

    <span class="c1"># return an empty kernel if it doesn&#39;t apply</span>
    <span class="k">if</span> <span class="n">num_range</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">num_range</span><span class="o">.</span><span class="n">initializer</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># number of species</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">num_range</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>

    <span class="n">rxn_range_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">elementary</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">simple_map</span><span class="p">,</span>
                      <span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">plog_map</span><span class="p">,</span>
                      <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_map</span><span class="p">}</span>

    <span class="c1"># add map</span>
    <span class="n">rxn_range</span> <span class="o">=</span> <span class="n">rxn_range_dict</span><span class="p">[</span><span class="n">rxn_type</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> <span class="k">else</span>\
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_has_ns</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">rxn_range</span><span class="p">,</span> <span class="n">num_range</span><span class="p">)</span>

    <span class="c1"># rev mask depends on actual reaction index</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
    <span class="c1"># thd_mask depends on actual reaction index</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">thd_mask</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
    <span class="c1"># pres mod is on thd_mask</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">thd_mask</span><span class="p">)</span>
    <span class="c1"># nu&#39;s are on the actual rxn index</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>

    <span class="c1"># specific transforms</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span><span class="p">:</span>
        <span class="c1"># fwd ROP is on actual rxn index</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rop_fwd</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
        <span class="c1"># rev ROP is on rev mask</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">rop_rev</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># kf is on real index</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kf</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
        <span class="c1"># kr is on rev rxn index</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kr</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">)</span>

    <span class="c1"># extra inames</span>
    <span class="n">net_ind</span> <span class="o">=</span> <span class="s1">&#39;net_ind&#39;</span>
    <span class="n">k_ind</span> <span class="o">=</span> <span class="s1">&#39;k_ind&#39;</span>

    <span class="c1"># common variables</span>
    <span class="c1"># temperature</span>
    <span class="n">T_lp</span><span class="p">,</span> <span class="n">T_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">T_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="c1"># Volume</span>
    <span class="n">V_lp</span><span class="p">,</span> <span class="n">V_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">V_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="c1"># get rev / thd mask</span>
    <span class="n">rev_mask_lp</span><span class="p">,</span> <span class="n">rev_mask_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
    <span class="n">thd_mask_lp</span><span class="p">,</span> <span class="n">thd_mask_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_mask</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
    <span class="n">pres_mod_lp</span><span class="p">,</span> <span class="n">pres_mod_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
    <span class="c1"># nu offsets</span>
    <span class="n">nu_offset_lp</span><span class="p">,</span> <span class="n">nu_offset_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">nu_offset_next_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># reac and prod nu for net</span>
    <span class="n">nu_lp</span><span class="p">,</span> <span class="n">net_reac_nu_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_reac_nu</span><span class="p">,</span> <span class="n">net_ind</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">net_ind</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">net_prod_nu_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_prod_nu</span><span class="p">,</span> <span class="n">net_ind</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">net_ind</span><span class="p">)</span>
    <span class="c1"># get species</span>
    <span class="n">spec_lp</span><span class="p">,</span> <span class="n">spec_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec</span><span class="p">,</span> <span class="n">net_ind</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">spec_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec</span><span class="p">,</span> <span class="n">k_ind</span><span class="p">)</span>

    <span class="c1"># add to data</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">T_lp</span><span class="p">,</span> <span class="n">V_lp</span><span class="p">,</span> <span class="n">rev_mask_lp</span><span class="p">,</span> <span class="n">thd_mask_lp</span><span class="p">,</span> <span class="n">pres_mod_lp</span><span class="p">,</span>
                        <span class="n">nu_offset_lp</span><span class="p">,</span> <span class="n">nu_lp</span><span class="p">,</span> <span class="n">spec_lp</span><span class="p">])</span>
    <span class="c1"># create a precomputed instruction generator</span>
    <span class="n">precompute</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">PrecomputedInstructions</span><span class="p">()</span>

    <span class="n">extra_inames</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">net_ind</span><span class="p">,</span> <span class="s1">&#39;offset &lt;= </span><span class="si">{}</span><span class="s1"> &lt; offset_next&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">net_ind</span><span class="p">)),</span>
        <span class="p">(</span><span class="n">k_ind</span><span class="p">,</span> <span class="s1">&#39;offset &lt;= </span><span class="si">{}</span><span class="s1"> &lt; offset_next&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k_ind</span><span class="p">))]</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pre_instructions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">manglers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">preambles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span><span class="p">:</span>
        <span class="c1"># get rxn parameters, these are based on the simple index</span>
        <span class="n">beta_lp</span><span class="p">,</span> <span class="n">beta_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">simple_beta</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
        <span class="n">Ta_lp</span><span class="p">,</span> <span class="n">Ta_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">simple_Ta</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
        <span class="c1"># rop&#39;s &amp; pres mod</span>
        <span class="n">rop_fwd_lp</span><span class="p">,</span> <span class="n">rop_fwd_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">rop_fwd</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">rop_rev_lp</span><span class="p">,</span> <span class="n">rop_rev_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">rop_rev</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="c1"># and finally dBkdT</span>
        <span class="n">dB_lp</span><span class="p">,</span> <span class="n">dBk_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">db</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">spec_str</span><span class="p">)</span>

        <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="n">beta_lp</span><span class="p">,</span> <span class="n">Ta_lp</span><span class="p">,</span> <span class="n">rop_fwd_lp</span><span class="p">,</span> <span class="n">rop_rev_lp</span><span class="p">,</span> <span class="n">dB_lp</span><span class="p">])</span>

        <span class="n">pre_instructions</span> <span class="o">=</span> <span class="p">[</span><span class="n">precompute</span><span class="p">(</span>
            <span class="s1">&#39;Tinv&#39;</span><span class="p">,</span> <span class="n">T_str</span><span class="p">,</span> <span class="s1">&#39;INV&#39;</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">rxn_type</span> <span class="o">==</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">:</span>
            <span class="n">lo_ind</span> <span class="o">=</span> <span class="s1">&#39;lo&#39;</span>
            <span class="n">hi_ind</span> <span class="o">=</span> <span class="s1">&#39;hi&#39;</span>
            <span class="n">param_ind</span> <span class="o">=</span> <span class="s1">&#39;p&#39;</span>
            <span class="c1"># create extra arrays</span>
            <span class="n">P_lp</span><span class="p">,</span> <span class="n">P_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">P_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
            <span class="c1"># number of plog rates per rxn</span>
            <span class="n">plog_num_param_lp</span><span class="p">,</span> <span class="n">plog_num_param_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">plog_num_param</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="c1"># pressure ranges</span>
            <span class="n">plog_params_lp</span><span class="p">,</span> <span class="n">pressure_mid_lo</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">param_ind</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">pressure_mid_hi</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">param_ind</span><span class="p">,</span>
                <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">param_ind</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">pres_lo_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">lo_ind</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">pres_hi_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">hi_ind</span><span class="p">)</span>
            <span class="c1"># arrhenius params</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">beta_lo_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">lo_ind</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">beta_hi_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">hi_ind</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">Ta_lo_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">lo_ind</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">Ta_hi_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">hi_ind</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">pressure_lo</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">pressure_hi</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">plog_params</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="s1">&#39;numP&#39;</span><span class="p">)</span>
            <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">P_lp</span><span class="p">,</span> <span class="n">plog_num_param_lp</span><span class="p">,</span> <span class="n">plog_params_lp</span><span class="p">])</span>

            <span class="c1"># add plog instruction</span>
            <span class="n">pre_instructions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">precompute</span><span class="p">(</span>
                <span class="s1">&#39;logP&#39;</span><span class="p">,</span> <span class="n">P_str</span><span class="p">,</span> <span class="s1">&#39;LOG&#39;</span><span class="p">))</span>

            <span class="n">plog_preloads</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">if</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">is_simd</span><span class="p">:</span>
                <span class="c1"># add some pre-loads for the plog parameters to avoid</span>
                <span class="c1"># precompute avoid errors with lookup of individual SIMD-vector</span>
                <span class="c1"># elements</span>

                <span class="n">plog_preloads</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                with {id_prefix=set_lo, dep=set_lo}</span>
<span class="s2">                    &lt;&gt; p_lo = $</span><span class="si">{pres_lo_str}</span><span class="s2"></span>
<span class="s2">                    &lt;&gt; beta_lo = $</span><span class="si">{beta_lo_str}</span><span class="s2"></span>
<span class="s2">                    &lt;&gt; Ta_lo = $</span><span class="si">{Ta_lo_str}</span><span class="s2"></span>
<span class="s2">                end</span>
<span class="s2">                with {id_prefix=set_hi, dep=set_hi}</span>
<span class="s2">                    &lt;&gt; p_hi = $</span><span class="si">{pres_hi_str}</span><span class="s2"></span>
<span class="s2">                    &lt;&gt; beta_hi = $</span><span class="si">{beta_hi_str}</span><span class="s2"></span>
<span class="s2">                    &lt;&gt; Ta_hi = $</span><span class="si">{Ta_hi_str}</span><span class="s2"></span>
<span class="s2">                end&quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
                <span class="c1"># and update strings</span>
                <span class="n">pres_lo_str</span> <span class="o">=</span> <span class="s1">&#39;p_lo&#39;</span>
                <span class="n">beta_lo_str</span> <span class="o">=</span> <span class="s1">&#39;beta_lo&#39;</span>
                <span class="n">Ta_lo_str</span> <span class="o">=</span> <span class="s1">&#39;Ta_lo&#39;</span>
                <span class="n">pres_hi_str</span> <span class="o">=</span> <span class="s1">&#39;p_hi&#39;</span>
                <span class="n">beta_hi_str</span> <span class="o">=</span> <span class="s1">&#39;beta_hi&#39;</span>
                <span class="n">Ta_hi_str</span> <span class="o">=</span> <span class="s1">&#39;Ta_hi&#39;</span>

            <span class="c1"># and dkf instructions</span>
            <span class="n">dkf_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                &lt;&gt; lo = 0 {id=lo_init}</span>
<span class="s2">                &lt;&gt; hi = numP {id=hi_init}</span>
<span class="s2">                &lt;&gt; numP = $</span><span class="si">{plog_num_param_str}</span><span class="s2"> - 1</span>
<span class="s2">                for $</span><span class="si">{param_ind}</span><span class="s2"></span>
<span class="s2">                    if $</span><span class="si">{param_ind}</span><span class="s2"> &lt;= numP and (logP &gt; $</span><span class="si">{pressure_mid_lo}</span><span class="s2">) and </span><span class="se">\</span>
<span class="s2">                            (logP &lt;= $</span><span class="si">{pressure_mid_hi}</span><span class="s2">)</span>
<span class="s2">                        lo = $</span><span class="si">{param_ind}</span><span class="s2"> {id=set_lo, dep=lo_init}</span>
<span class="s2">                        hi = $</span><span class="si">{param_ind}</span><span class="s2"> + 1 {id=set_hi, dep=hi_init}</span>
<span class="s2">                    end</span>
<span class="s2">                end</span>
<span class="s2">                $</span><span class="si">{plog_preloads}</span><span class="s2"></span>
<span class="s2">                if logP &gt; $</span><span class="si">{pressure_hi}</span><span class="s2"> # out of range above</span>
<span class="s2">                    &lt;&gt; dkf = ($</span><span class="si">{beta_hi_str}</span><span class="s2"> + $</span><span class="si">{Ta_hi_str}</span><span class="s2"> * Tinv) * Tinv </span><span class="se">\</span>
<span class="s2">                        {id=dkf_init_hi, dep=set_*, nosync=dkf_init_lo}</span>
<span class="s2">                else</span>
<span class="s2">                    dkf = ($</span><span class="si">{beta_lo_str}</span><span class="s2"> + $</span><span class="si">{Ta_lo_str}</span><span class="s2"> * Tinv) * Tinv </span><span class="se">\</span>
<span class="s2">                        {id=dkf_init_lo, dep=set_*, nosync=dkf_init_hi}</span>
<span class="s2">                end</span>
<span class="s2">                if logP &gt; $</span><span class="si">{pressure_lo}</span><span class="s2"> and logP &lt;= $</span><span class="si">{pressure_hi}</span><span class="s2"></span>
<span class="s2">                    # not out of range</span>
<span class="s2">                    dkf = dkf + Tinv * (logP - $</span><span class="si">{pres_lo_str}</span><span class="s2">) * </span><span class="se">\</span>
<span class="s2">                    ($</span><span class="si">{beta_hi_str}</span><span class="s2"> - $</span><span class="si">{beta_lo_str}</span><span class="s2"> + </span><span class="se">\</span>
<span class="s2">                        ($</span><span class="si">{Ta_hi_str}</span><span class="s2"> - $</span><span class="si">{Ta_lo_str}</span><span class="s2">) * Tinv) / </span><span class="se">\</span>
<span class="s2">                    ($</span><span class="si">{pres_hi_str}</span><span class="s2"> - $</span><span class="si">{pres_lo_str}</span><span class="s2">) {id=dkf_final, dep=dkf_init*}</span>
<span class="s2">                end</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
            <span class="n">extra_inames</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                <span class="n">param_ind</span><span class="p">,</span> <span class="s1">&#39;0 &lt;= </span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param_ind</span><span class="p">,</span> <span class="n">maxP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">rxn_type</span> <span class="o">==</span> <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">:</span>
            <span class="c1"># max degrees in mechanism</span>
            <span class="n">poly_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">maxP</span><span class="p">,</span> <span class="n">maxT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

            <span class="c1"># extra inames</span>
            <span class="n">pres_poly_ind</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>
            <span class="n">temp_poly_ind</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
            <span class="n">poly_compute_ind</span> <span class="o">=</span> <span class="s1">&#39;p&#39;</span>
            <span class="n">lim_ind</span> <span class="o">=</span> <span class="s1">&#39;dummy&#39;</span>
            <span class="n">extra_inames</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
                <span class="p">(</span><span class="n">pres_poly_ind</span><span class="p">,</span> <span class="s1">&#39;0 &lt;= </span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pres_poly_ind</span><span class="p">,</span> <span class="n">maxP</span><span class="p">)),</span>
                <span class="p">(</span><span class="n">temp_poly_ind</span><span class="p">,</span> <span class="s1">&#39;0 &lt;= </span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">temp_poly_ind</span><span class="p">,</span> <span class="n">maxT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
                <span class="p">(</span><span class="n">poly_compute_ind</span><span class="p">,</span> <span class="s1">&#39;2 &lt;= </span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">poly_compute_ind</span><span class="p">,</span> <span class="n">poly_max</span><span class="p">))])</span>

            <span class="c1"># create arrays</span>

            <span class="n">num_P_lp</span><span class="p">,</span> <span class="n">num_P_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_numP</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">num_T_lp</span><span class="p">,</span> <span class="n">num_T_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_numT</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">params_lp</span><span class="p">,</span> <span class="n">params_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_params</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">temp_poly_ind</span><span class="p">,</span> <span class="n">pres_poly_ind</span><span class="p">,</span>
                <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">temp_poly_ind</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
            <span class="n">plim_lp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_Plim</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">lim_ind</span><span class="p">)</span>
            <span class="n">tlim_lp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_Tlim</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">lim_ind</span><span class="p">)</span>

            <span class="c1"># workspace vars are based only on their polynomial indicies</span>
            <span class="n">pres_poly_lp</span><span class="p">,</span> <span class="n">ppoly_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_pres_poly</span><span class="p">,</span> <span class="n">pres_poly_ind</span><span class="p">)</span>
            <span class="n">temp_poly_lp</span><span class="p">,</span> <span class="n">tpoly_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_temp_poly</span><span class="p">,</span> <span class="n">temp_poly_ind</span><span class="p">)</span>

            <span class="c1"># create temperature and pressure arrays</span>
            <span class="n">P_lp</span><span class="p">,</span> <span class="n">P_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">P_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

            <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">params_lp</span><span class="p">,</span> <span class="n">num_P_lp</span><span class="p">,</span> <span class="n">num_T_lp</span><span class="p">,</span> <span class="n">plim_lp</span><span class="p">,</span> <span class="n">P_lp</span><span class="p">,</span>
                                <span class="n">tlim_lp</span><span class="p">,</span> <span class="n">pres_poly_lp</span><span class="p">,</span> <span class="n">temp_poly_lp</span><span class="p">])</span>

            <span class="c1"># preinstructions</span>
            <span class="n">pre_instructions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span><span class="n">precompute</span><span class="p">(</span><span class="s1">&#39;logP&#39;</span><span class="p">,</span> <span class="n">P_str</span><span class="p">,</span> <span class="s1">&#39;LOG&#39;</span><span class="p">)])</span>

            <span class="c1"># various strings for preindexed limits, params, etc</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">Pmin_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_Plim</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">Pmax_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_Plim</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">Tmin_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_Tlim</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">Tmax_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">cheb_Tlim</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>

            <span class="c1"># the various indexing for the pressure / temperature polynomials</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">ppoly0_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_pres_poly</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">ppoly1_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_pres_poly</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">ppolyp_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_pres_poly</span><span class="p">,</span>
                                                <span class="n">poly_compute_ind</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">ppolypm1_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_pres_poly</span><span class="p">,</span>
                                                  <span class="n">poly_compute_ind</span><span class="p">,</span>
                                                  <span class="n">affine</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">ppolypm2_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_pres_poly</span><span class="p">,</span>
                                                  <span class="n">poly_compute_ind</span><span class="p">,</span>
                                                  <span class="n">affine</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">tpoly0_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_temp_poly</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">tpoly1_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_temp_poly</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">tpolyp_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_temp_poly</span><span class="p">,</span>
                                                <span class="n">poly_compute_ind</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">tpolypm1_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_temp_poly</span><span class="p">,</span>
                                                  <span class="n">poly_compute_ind</span><span class="p">,</span>
                                                  <span class="n">affine</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">tpolypm2_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">cheb_temp_poly</span><span class="p">,</span>
                                                  <span class="n">poly_compute_ind</span><span class="p">,</span>
                                                  <span class="n">affine</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">dkf_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                &lt;&gt;numP = $</span><span class="si">{num_P_str}</span><span class="s2"> {id=plim}</span>
<span class="s2">                &lt;&gt;numT = $</span><span class="si">{num_T_str}</span><span class="s2"> - 1 {id=tlim}</span>
<span class="s2">                &lt;&gt; Tred = (2 * Tinv - $</span><span class="si">{Tmax_str}</span><span class="s2">- $</span><span class="si">{Tmin_str}</span><span class="s2">) / </span><span class="se">\</span>
<span class="s2">                    ($</span><span class="si">{Tmax_str}</span><span class="s2"> - $</span><span class="si">{Tmin_str}</span><span class="s2">)</span>
<span class="s2">                &lt;&gt; Pred = (2 * logP - $</span><span class="si">{Pmax_str}</span><span class="s2"> - $</span><span class="si">{Pmin_str}</span><span class="s2">) / </span><span class="se">\</span>
<span class="s2">                    ($</span><span class="si">{Pmax_str}</span><span class="s2"> - $</span><span class="si">{Pmin_str}</span><span class="s2">)</span>
<span class="s2">                $</span><span class="si">{ppoly0_str}</span><span class="s2"> = 1 {id=ppoly_init1}</span>
<span class="s2">                $</span><span class="si">{ppoly1_str}</span><span class="s2"> = Pred {id=ppoly_init2}</span>
<span class="s2">                $</span><span class="si">{tpoly0_str}</span><span class="s2"> = 1 {id=tpoly_init1}</span>
<span class="s2">                $</span><span class="si">{tpoly1_str}</span><span class="s2"> = 2 * Tred {id=tpoly_init2}</span>

<span class="s2">                # compute polynomial terms</span>
<span class="s2">                for p</span>
<span class="s2">                    if p &lt; numP</span>
<span class="s2">                        $</span><span class="si">{ppolyp_str}</span><span class="s2"> = 2 * Pred * $</span><span class="si">{ppolypm1_str}</span><span class="s2"> - </span><span class="se">\</span>
<span class="s2">                            $</span><span class="si">{ppolypm2_str}</span><span class="s2"> {id=ppoly, dep=plim:ppoly_init*}</span>
<span class="s2">                    end</span>
<span class="s2">                    if p &lt; numT</span>
<span class="s2">                        $</span><span class="si">{tpolyp_str}</span><span class="s2"> = 2 * Tred * $</span><span class="si">{tpolypm1_str}</span><span class="s2"> - </span><span class="se">\</span>
<span class="s2">                            $</span><span class="si">{tpolypm2_str}</span><span class="s2"> {id=tpoly, dep=tlim:tpoly_init*}</span>
<span class="s2">                    end</span>
<span class="s2">                end</span>

<span class="s2">                &lt;&gt; dkf = 0 {id=dkf_init}</span>
<span class="s2">                for m</span>
<span class="s2">                    &lt;&gt;temp = 0 {id=temp_init}</span>
<span class="s2">                    for k</span>
<span class="s2">                        if k &lt; numP</span>
<span class="s2">                            temp = temp + $</span><span class="si">{ppoly_str}</span><span class="s2"> * $</span><span class="si">{params_str}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                                {id=temp, dep=ppoly:tpoly:temp_init}</span>
<span class="s2">                        end</span>
<span class="s2">                    end</span>
<span class="s2">                    if m &lt; numT</span>
<span class="s2">                        dkf = dkf + (m + 1) * $</span><span class="si">{tpoly_str}</span><span class="s2"> * temp </span><span class="se">\</span>
<span class="s2">                            {id=dkf_update, dep=temp:dkf_init}</span>
<span class="s2">                    end</span>
<span class="s2">                end</span>
<span class="s2">                dkf = -dkf * 2 * logten * Tinv * Tinv / ($</span><span class="si">{Tmax_str}</span><span class="s2"> - $</span><span class="si">{Tmin_str}</span><span class="s2">) </span><span class="se">\</span>
<span class="s2">                    {id=dkf, dep=dkf_update}</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
            <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;logten&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dkf_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                <span class="s1">&#39;&lt;&gt; dkf = ($</span><span class="si">{beta_str}</span><span class="s1"> + $</span><span class="si">{Ta_str}</span><span class="s1"> * Tinv) * Tinv {id=dkf}&#39;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

        <span class="c1"># and put together instructions</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        $</span><span class="si">{dkf_instructions}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; dRopidT = $</span><span class="si">{rop_fwd_str}</span><span class="s2"> * dkf {id=init, dep=dkf*}</span>
<span class="s2">        &lt;&gt; ci = 1 {id=ci_init}</span>
<span class="s2">        if $</span><span class="si">{rev_mask_str}</span><span class="s2"> &gt;= 0</span>
<span class="s2">            &lt;&gt; dBk_sum = 0 {id=dBk_init}</span>
<span class="s2">            for $</span><span class="si">{net_ind}</span><span class="s2"></span>
<span class="s2">                dBk_sum = dBk_sum + </span><span class="se">\</span>
<span class="s2">                    ($</span><span class="si">{net_prod_nu_str}</span><span class="s2"> - $</span><span class="si">{net_reac_nu_str}</span><span class="s2">) * $</span><span class="si">{dBk_str}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                    {id=up, dep=dBk_init}</span>
<span class="s2">            end</span>
<span class="s2">            dRopidT = dRopidT - $</span><span class="si">{rop_rev_str}</span><span class="s2"> * </span><span class="se">\</span>
<span class="s2">                (dkf - dBk_sum) {id=rev, dep=init:up}</span>
<span class="s2">        end</span>
<span class="s2">        if $</span><span class="si">{thd_mask_str}</span><span class="s2"> &gt;= 0</span>
<span class="s2">            ci = $</span><span class="si">{pres_mod_str}</span><span class="s2"> {id=ci, dep=ci_init}</span>
<span class="s2">        end</span>
<span class="s2">        dRopidT = dRopidT * ci * $</span><span class="si">{V_str}</span><span class="s2"> {id=Ropi_final, dep=rev:ci*}</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># create kf / kr</span>
        <span class="n">kf_lp</span><span class="p">,</span> <span class="n">kf_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kf</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">kr_lp</span><span class="p">,</span> <span class="n">kr_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kr</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">P_lp</span><span class="p">,</span> <span class="n">P_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">P_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
        <span class="n">conc_lp</span><span class="p">,</span> <span class="n">conc_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">conc_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="s1">&#39;net_spec&#39;</span><span class="p">)</span>

        <span class="c1"># TODO: forward allint to this function</span>
        <span class="c1"># create appropriate power functions</span>
        <span class="n">power_func</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">power_function</span><span class="p">(</span><span class="n">loopy_opts</span><span class="o">.</span><span class="n">lang</span><span class="p">,</span> <span class="n">is_integer_power</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                          <span class="n">guard_nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nu_fwd</span> <span class="o">=</span> <span class="s1">&#39;nu_fwd&#39;</span>
        <span class="n">nu_rev</span> <span class="o">=</span> <span class="s1">&#39;nu_rev&#39;</span>
        <span class="n">pow_conc_fwd</span> <span class="o">=</span> <span class="n">power_func</span><span class="p">(</span><span class="n">conc_str</span><span class="p">,</span> <span class="n">nu_fwd</span><span class="p">)</span>
        <span class="n">pow_conc_rev</span> <span class="o">=</span> <span class="n">power_func</span><span class="p">(</span><span class="n">conc_str</span><span class="p">,</span> <span class="n">nu_rev</span><span class="p">)</span>

        <span class="n">preambles</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lp_pregen</span><span class="o">.</span><span class="n">power_function_preambles</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">power_func</span><span class="p">))</span>
        <span class="n">manglers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lp_pregen</span><span class="o">.</span><span class="n">power_function_manglers</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">power_func</span><span class="p">))</span>

        <span class="c1"># create Ns nu&#39;s</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ns_reac_nu_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_reac_nu</span><span class="p">,</span> <span class="s1">&#39;offset_next&#39;</span><span class="p">,</span>
            <span class="n">affine</span><span class="o">=</span><span class="s1">&#39;offset_next - 2&#39;</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ns_prod_nu_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_prod_nu</span><span class="p">,</span> <span class="s1">&#39;offset_next&#39;</span><span class="p">,</span>
            <span class="n">affine</span><span class="o">=</span><span class="s1">&#39;offset_next - 2&#39;</span><span class="p">)</span>

        <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">kf_lp</span><span class="p">,</span> <span class="n">kr_lp</span><span class="p">,</span> <span class="n">P_lp</span><span class="p">,</span> <span class="n">conc_lp</span><span class="p">])</span>
        <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;Ru&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chem</span><span class="o">.</span><span class="n">RU</span>

        <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        &lt;&gt; kr_i = 0 {id=kr_in}</span>
<span class="s2">        if $</span><span class="si">{rev_mask_str}</span><span class="s2"> &gt;= 0</span>
<span class="s2">            kr_i = $</span><span class="si">{kr_str}</span><span class="s2"> {id=kr_up, dep=kr_in}</span>
<span class="s2">        end</span>
<span class="s2">        &lt;&gt; ci = 1 {id=ci_init}</span>
<span class="s2">        if $</span><span class="si">{thd_mask_str}</span><span class="s2"> &gt;= 0</span>
<span class="s2">            ci = $</span><span class="si">{pres_mod_str}</span><span class="s2"> {id=ci, dep=ci_init}</span>
<span class="s2">        end</span>
<span class="s2">        &lt;&gt; Sns_fwd = $</span><span class="si">{ns_reac_nu_str}</span><span class="s2"> {id=Sns_fwd_init}</span>
<span class="s2">        &lt;&gt; Sns_rev = $</span><span class="si">{ns_prod_nu_str}</span><span class="s2"> {id=Sns_rev_init}</span>
<span class="s2">        for $</span><span class="si">{net_ind}</span><span class="s2"></span>
<span class="s2">            &lt;&gt; $</span><span class="si">{nu_fwd}</span><span class="s2"> = $</span><span class="si">{net_reac_nu_str}</span><span class="s2"> {id=nuf_inner}</span>
<span class="s2">            &lt;&gt; $</span><span class="si">{nu_rev}</span><span class="s2"> = $</span><span class="si">{net_prod_nu_str}</span><span class="s2"> {id=nur_inner}</span>
<span class="s2">            &lt;&gt; net_spec = $</span><span class="si">{spec_str}</span><span class="s2"></span>
<span class="s2">            # handle nu</span>
<span class="s2">            if net_spec == $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">                $</span><span class="si">{nu_fwd}</span><span class="s2"> = $</span><span class="si">{nu_fwd}</span><span class="s2"> - 1 {id=nuf_inner_up, dep=nuf_inner}</span>
<span class="s2">            end</span>
<span class="s2">            Sns_fwd = Sns_fwd * $</span><span class="si">{pow_conc_fwd}</span><span class="s2"> {id=Sns_fwd_up, </span><span class="se">\</span>
<span class="s2">                dep=nuf_inner_up:Sns_fwd_init}</span>
<span class="s2">            if net_spec == $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">                $</span><span class="si">{nu_rev}</span><span class="s2"> = $</span><span class="si">{nu_rev}</span><span class="s2"> - 1 {id=nur_inner_up, dep=nur_inner}</span>
<span class="s2">            end</span>
<span class="s2">            Sns_rev = Sns_rev * $</span><span class="si">{pow_conc_rev}</span><span class="s2"> {id=Sns_rev_up, </span><span class="se">\</span>
<span class="s2">                dep=nur_inner_up:Sns_rev_init}</span>
<span class="s2">        end</span>
<span class="s2">        &lt;&gt; dRopidT = (Sns_rev * kr_i - Sns_fwd * $</span><span class="si">{kf_str}</span><span class="s2">) * </span><span class="se">\</span>
<span class="s2">            $</span><span class="si">{V_str}</span><span class="s2"> * ci * $</span><span class="si">{P_str}</span><span class="s2"> / (Ru * $</span><span class="si">{T_str}</span><span class="s2"> * $</span><span class="si">{T_str}</span><span class="s2">) </span><span class="se">\</span>
<span class="s2">            {id=Ropi_final, dep=Sns*:ci*:kr*}</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="c1"># get nuk&#39;s</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">reac_nu_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_reac_nu</span><span class="p">,</span> <span class="n">k_ind</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">k_ind</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">prod_nu_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_prod_nu</span><span class="p">,</span> <span class="n">k_ind</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">k_ind</span><span class="p">)</span>
    <span class="c1"># and finally jac</span>
    <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
        <span class="s2">&quot;$</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + ($</span><span class="si">{prod_nu_k_str}</span><span class="s2"> - $</span><span class="si">{reac_nu_k_str}</span><span class="s2">) * dRopidT &quot;</span>
        <span class="s2">&quot;{id=jac, dep=$</span><span class="si">{deps}</span><span class="s2">}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">jac_lp</span><span class="p">,</span> <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">spec_k_str</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">spec_k_str</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
        <span class="n">insn</span><span class="o">=</span><span class="n">jac_update_insn</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;Ropi_final&#39;</span><span class="p">)</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jac_lp</span><span class="p">)</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        &lt;&gt; offset = $</span><span class="si">{nu_offset_str}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; offset_next = $</span><span class="si">{nu_offset_next_str}</span><span class="s2"></span>
<span class="s2">        $</span><span class="si">{instructions}</span><span class="s2"></span>
<span class="s2">        for $</span><span class="si">{k_ind}</span><span class="s2"></span>
<span class="s2">            if $</span><span class="si">{spec_k_str}</span><span class="s2"> != $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">                $</span><span class="si">{jac_update_insn}</span><span class="s2"></span>
<span class="s2">            end</span>
<span class="s2">        end</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="n">name_description</span> <span class="o">=</span> <span class="p">{</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">elementary</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                        <span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">:</span> <span class="s1">&#39;_plog&#39;</span><span class="p">,</span>
                        <span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">:</span> <span class="s1">&#39;_cheb&#39;</span><span class="p">}</span>

    <span class="n">can_vectorize</span><span class="p">,</span> <span class="n">vec_spec</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_deep_specializer</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">atomic_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;dRopi</span><span class="si">{}</span><span class="s1">_dT</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">name_description</span><span class="p">[</span><span class="n">rxn_type</span><span class="p">],</span>
        <span class="s1">&#39;_ns&#39;</span> <span class="k">if</span> <span class="n">do_ns</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
        <span class="n">extra_inames</span><span class="o">=</span><span class="n">extra_inames</span><span class="p">,</span>
        <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
        <span class="n">pre_instructions</span><span class="o">=</span><span class="n">pre_instructions</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
        <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
        <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
        <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
        <span class="n">can_vectorize</span><span class="o">=</span><span class="n">can_vectorize</span><span class="p">,</span>
        <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">vec_spec</span><span class="p">,</span>
        <span class="n">preambles</span><span class="o">=</span><span class="n">preambles</span><span class="p">,</span>
        <span class="n">manglers</span><span class="o">=</span><span class="n">manglers</span><span class="p">,</span>
        <span class="c1"># expected vectorized scatter load instructions for plog parameters</span>
        <span class="c1"># with wide vectorization (pressure non-constant between vector-lanes)</span>
        <span class="n">silenced_warnings</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vectorize_failed&#39;</span><span class="p">]</span>
    <span class="p">)</span>


<div class="viewcode-block" id="dRopidT"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dRopidT">[docs]</a><span class="k">def</span> <span class="nf">dRopidT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the rate of progress (for non-pressure dependent reaction</span>
<span class="sd">    types) with respect to temperature</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See :meth:`pyjac.core.create_jacobian.__dRopidT`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>
<span class="sd">    maxP: int [None]</span>
<span class="sd">        The maximum number of pressure interpolations of any reaction in</span>
<span class="sd">        the mechanism.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">__dRopidT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span>
                                  <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">do_ns</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                        <span class="n">__dRopidT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span>
                                  <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">do_ns</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="dRopi_plog_dT"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dRopi_plog_dT">[docs]</a><span class="k">def</span> <span class="nf">dRopi_plog_dT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxP</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the rate of progress for PLOG reactions</span>
<span class="sd">    with respect to temperature</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See :meth:`pyjac.core.create_jacobian.__dRopidT`</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>
<span class="sd">    maxP: int [None]</span>
<span class="sd">        The maximum number of pressure interpolations of any reaction in</span>
<span class="sd">        the mechanism.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">__dRopidT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span>
                                  <span class="n">rxn_type</span><span class="o">=</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">plog</span><span class="p">,</span>
                                  <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">do_ns</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">maxP</span><span class="o">=</span><span class="n">maxP</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="dRopi_cheb_dT"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dRopi_cheb_dT">[docs]</a><span class="k">def</span> <span class="nf">dRopi_cheb_dT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxP</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">maxT</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the rate of progress for Chebyshev reactions</span>
<span class="sd">    with respect to temperature</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See :meth:`pyjac.core.create_jacobian.__dRopidT`</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>
<span class="sd">    maxP : int [None]</span>
<span class="sd">        The maximum degree of pressure polynomials for chebyshev reactions in</span>
<span class="sd">        this mechanism</span>
<span class="sd">    maxT : int [None]</span>
<span class="sd">        The maximum degree of temperature polynomials for chebyshev reactions</span>
<span class="sd">        in this mechanism</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">__dRopidT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span>
                                  <span class="n">rxn_type</span><span class="o">=</span><span class="n">reaction_type</span><span class="o">.</span><span class="n">cheb</span><span class="p">,</span>
                                  <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">do_ns</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">maxP</span><span class="o">=</span><span class="n">maxP</span><span class="p">,</span> <span class="n">maxT</span><span class="o">=</span><span class="n">maxT</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="thermo_temperature_derivative"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.thermo_temperature_derivative">[docs]</a><span class="k">def</span> <span class="nf">thermo_temperature_derivative</span><span class="p">(</span><span class="n">nicename</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span>
                                  <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the concentration weighted specific energy sum.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nicename : [&#39;dcp&#39;, &#39;dcv&#39;, &#39;db&#39;]</span>
<span class="sd">        The polynomial derivative to calculate</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">rate</span><span class="o">.</span><span class="n">polyfit_kernel_gen</span><span class="p">(</span><span class="n">nicename</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span></div>


<div class="viewcode-block" id="dEdot_dnj"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dEdot_dnj">[docs]</a><span class="nd">@ic</span><span class="o">.</span><span class="n">with_conditional_jacobian</span>
<span class="k">def</span> <span class="nf">dEdot_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jac_create</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the derivative of the extra variable (i.e. V or P depending on conp/conv)</span>
<span class="sd">    w.r.t. the molar variables</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>
<span class="sd">    jac_create: Callable</span>
<span class="sd">        The conditional Jacobian instruction creator from :mod:`instruction_creator`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># create arrays</span>
    <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs_no_ns</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>

    <span class="n">ns</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># k loop is _only_ over non-zero dnk/dnj deriviatives</span>
    <span class="c1"># note that net_notzero_specs does not include NS by rule</span>
    <span class="n">i_spec_k</span> <span class="o">=</span> <span class="s1">&#39;i_spec_k&#39;</span>
    <span class="n">extra_inames</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i_spec_k</span><span class="p">,</span> <span class="s1">&#39;0 &lt;= i_spec_k &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">net_nonzero_spec</span><span class="o">.</span><span class="n">size</span><span class="p">))]</span>
    <span class="n">nonzero_lp</span><span class="p">,</span> <span class="n">spec_k</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">net_nonzero_spec</span><span class="p">,</span> <span class="n">i_spec_k</span><span class="p">)</span>

    <span class="n">mw_lp</span><span class="p">,</span> <span class="n">mw_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">mw_post_arr</span><span class="p">,</span> <span class="n">spec_k</span><span class="p">)</span>
    <span class="n">V_lp</span><span class="p">,</span> <span class="n">V_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">V_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="c1"># dnk/dnj jacobian set</span>
    <span class="n">dnkdnj_insn</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
        <span class="s2">&quot;sum = sum + (1 - $</span><span class="si">{mw_str}</span><span class="s2">) * $</span><span class="si">{jac_str}</span><span class="s2"> {id=sum, dep=$</span><span class="si">{deps}</span><span class="s2">}&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">jac_lp</span><span class="p">,</span> <span class="n">dnkdnj_insn</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">spec_k</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="p">{</span>
            <span class="n">var_name</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">spec_k</span><span class="p">:</span> <span class="mi">2</span>
        <span class="p">},</span> <span class="n">insn</span><span class="o">=</span><span class="n">dnkdnj_insn</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;*:init&#39;</span><span class="p">)</span>
    <span class="c1"># and the dedot / dnj instruction</span>
    <span class="n">dedotdnj_insn</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
        <span class="s2">&quot;$</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + $</span><span class="si">{T_str}</span><span class="s2"> * Ru * sum / $</span><span class="si">{fixed_var_str}</span><span class="s2"> + &quot;</span>
        <span class="s2">&quot;$</span><span class="si">{extra_var_str}</span><span class="s2"> * $</span><span class="si">{dTdot_dnj_str}</span><span class="s2"> / $</span><span class="si">{T_str}</span><span class="s2"> &quot;</span>
        <span class="s2">&quot;{id=jac, dep=$</span><span class="si">{deps}</span><span class="s2">, nosync=sum}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">dedotdnj_insn</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="p">{</span>
            <span class="n">var_name</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">},</span> <span class="n">insn</span><span class="o">=</span><span class="n">dedotdnj_insn</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">entry_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># and finally do a simple string creation for dTdot / dnj</span>
    <span class="c1"># NOTE: do not precompute index here as 1. it&#39;s only called once</span>
    <span class="c1"># 2. it has to exist by defn and 3. we haven&#39;t trained the creator to hanle</span>
    <span class="c1"># multiple indicies</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">dTdot_dnj_str</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="p">{</span>
            <span class="n">var_name</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">},</span> <span class="n">entry_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">index_insn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">P_lp</span><span class="p">,</span> <span class="n">P_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">P_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">T_lp</span><span class="p">,</span> <span class="n">T_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">T_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">mw_lp</span><span class="p">,</span> <span class="n">V_lp</span><span class="p">,</span> <span class="n">P_lp</span><span class="p">,</span> <span class="n">T_lp</span><span class="p">,</span> <span class="n">jac_lp</span><span class="p">,</span> <span class="n">nonzero_lp</span><span class="p">])</span>

    <span class="n">extra_var_str</span> <span class="o">=</span> <span class="n">V_str</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="n">P_str</span>
    <span class="n">fixed_var_str</span> <span class="o">=</span> <span class="n">P_str</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="n">V_str</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    &lt;&gt; sum = 0 {id=init}</span>
<span class="s2">    for $</span><span class="si">{i_spec_k}</span><span class="s2"></span>
<span class="s2">        $</span><span class="si">{dnkdnj_insn}</span><span class="s2"></span>
<span class="s2">    end</span>
<span class="s2">    $</span><span class="si">{dedotdnj_insn}</span><span class="s2"></span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">()))</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="n">can_vectorize</span><span class="p">,</span> <span class="n">vec_spec</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_deep_specializer</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">atomic_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;d</span><span class="si">{}</span><span class="s1">dot_dnj&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;V&#39;</span> <span class="k">if</span> <span class="n">conp</span> <span class="k">else</span> <span class="s1">&#39;P&#39;</span><span class="p">),</span>
                          <span class="n">extra_inames</span><span class="o">=</span><span class="n">extra_inames</span><span class="p">,</span>
                          <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
                          <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
                          <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
                          <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
                          <span class="n">parameters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Ru&#39;</span><span class="p">:</span> <span class="n">chem</span><span class="o">.</span><span class="n">RU</span><span class="p">},</span>
                          <span class="n">can_vectorize</span><span class="o">=</span><span class="n">can_vectorize</span><span class="p">,</span>
                          <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">vec_spec</span>
                          <span class="p">)</span></div>


<div class="viewcode-block" id="dTdot_dnj"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dTdot_dnj">[docs]</a><span class="nd">@ic</span><span class="o">.</span><span class="n">with_conditional_jacobian</span>
<span class="k">def</span> <span class="nf">dTdot_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jac_create</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the partial derivatives of dT/dt with respect to the molar species</span>
<span class="sd">    quanities</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>
<span class="sd">    jac_create: Callable</span>
<span class="sd">        The conditional Jacobian instruction creator from :mod:`instruction_creator`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># create arrays</span>
    <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs_no_ns</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>

    <span class="n">ns</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># k loop is _only_ over non-zero dnk/dnj deriviatives</span>
    <span class="c1"># note that net_notzero_specs does not include NS by rule</span>
    <span class="n">i_spec_k</span> <span class="o">=</span> <span class="s1">&#39;i_spec_k&#39;</span>
    <span class="n">extra_inames</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i_spec_k</span><span class="p">,</span> <span class="s1">&#39;0 &lt;= i_spec_k &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">net_nonzero_spec</span><span class="o">.</span><span class="n">size</span><span class="p">))]</span>
    <span class="n">nonzero_lp</span><span class="p">,</span> <span class="n">spec_k</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">net_nonzero_spec</span><span class="p">,</span> <span class="n">i_spec_k</span><span class="p">)</span>
    <span class="n">spec_heat_lp</span><span class="p">,</span> <span class="n">spec_heat_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_heat</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">spec_heat_ns_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_heat_ns</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">energy_lp</span><span class="p">,</span> <span class="n">energy_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_energy</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">spec_k</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">energy_ns_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_energy_ns</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">spec_heat_tot_lp</span><span class="p">,</span> <span class="n">spec_heat_total_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_heat_total</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">mw_lp</span><span class="p">,</span> <span class="n">mw_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">mw_post_arr</span><span class="p">,</span> <span class="n">spec_k</span><span class="p">)</span>
    <span class="n">V_lp</span><span class="p">,</span> <span class="n">V_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">V_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>
    <span class="n">T_dot_lp</span><span class="p">,</span> <span class="n">T_dot_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">T_dot</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="c1"># start creating the Jacobian</span>

    <span class="c1"># species jacobian sum</span>
    <span class="n">species_jac_insn</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;sum = sum + ($</span><span class="si">{energy_k_str}</span><span class="s2"> - $</span><span class="si">{energy_ns_str}</span><span class="s2"> * &quot;</span>
                        <span class="s2">&quot;$</span><span class="si">{mw_str}</span><span class="s2">) * $</span><span class="si">{jac_str}</span><span class="s2"> {id=sum, dep=$</span><span class="si">{deps}</span><span class="s2">}&quot;</span><span class="p">)</span>
    <span class="n">jac_lp</span><span class="p">,</span> <span class="n">species_jac_insn</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">spec_k</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="p">{</span>
            <span class="n">var_name</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">spec_k</span><span class="p">:</span> <span class="mi">2</span>
        <span class="p">},</span> <span class="n">insn</span><span class="o">=</span><span class="n">species_jac_insn</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;*:init&#39;</span><span class="p">)</span>

    <span class="c1"># dTdot/dnj jacobian set</span>
    <span class="n">tdot_jac_insn</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;$</span><span class="si">{jac_str}</span><span class="s2"> = -(sum + $</span><span class="si">{T_dot_str}</span><span class="s2"> * &quot;</span>
        <span class="s2">&quot;($</span><span class="si">{spec_heat_k_str}</span><span class="s2"> - $</span><span class="si">{spec_heat_ns_str}</span><span class="s2">)) / &quot;</span>
        <span class="s2">&quot;($</span><span class="si">{V_str}</span><span class="s2"> * $</span><span class="si">{spec_heat_total_str}</span><span class="s2">) {id=jac, dep=$</span><span class="si">{deps}</span><span class="s2">, nosync=sum}&quot;</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">tdot_jac_insn</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="p">{</span>
            <span class="n">var_name</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">},</span> <span class="n">entry_exists</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">insn</span><span class="o">=</span><span class="n">tdot_jac_insn</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>

    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">spec_heat_lp</span><span class="p">,</span> <span class="n">energy_lp</span><span class="p">,</span> <span class="n">spec_heat_tot_lp</span><span class="p">,</span> <span class="n">mw_lp</span><span class="p">,</span>
                        <span class="n">V_lp</span><span class="p">,</span> <span class="n">T_dot_lp</span><span class="p">,</span> <span class="n">jac_lp</span><span class="p">,</span> <span class="n">nonzero_lp</span><span class="p">])</span>

    <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    &lt;&gt; sum = 0 {id=init}</span>
<span class="s2">    for $</span><span class="si">{i_spec_k}</span><span class="s2"></span>
<span class="s2">        $</span><span class="si">{species_jac_insn}</span><span class="s2"></span>
<span class="s2">    end</span>
<span class="s2">    $</span><span class="si">{tdot_jac_insn}</span><span class="s2"></span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">()))</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="n">can_vectorize</span><span class="p">,</span> <span class="n">vec_spec</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_deep_specializer</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">init_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;dTdot_dnj&#39;</span><span class="p">,</span>
                          <span class="n">extra_inames</span><span class="o">=</span><span class="n">extra_inames</span><span class="p">,</span>
                          <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
                          <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
                          <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
                          <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
                          <span class="n">can_vectorize</span><span class="o">=</span><span class="n">can_vectorize</span><span class="p">,</span>
                          <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">vec_spec</span>
                          <span class="p">)</span></div>


<div class="viewcode-block" id="total_specific_energy"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.total_specific_energy">[docs]</a><span class="k">def</span> <span class="nf">total_specific_energy</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    the concentration weighted specific energy sum.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    conp : bool [True]</span>
<span class="sd">        If supplied, True for constant pressure jacobian. False for constant</span>
<span class="sd">        volume [Default: True]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># create arrays</span>
    <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>

    <span class="n">spec_heat_lp</span><span class="p">,</span> <span class="n">spec_heat_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_heat</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
    <span class="n">conc_lp</span><span class="p">,</span> <span class="n">conc_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">conc_arr</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
    <span class="n">spec_heat_tot_lp</span><span class="p">,</span> <span class="n">spec_heat_total_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">spec_heat_total</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">spec_heat_lp</span><span class="p">,</span> <span class="n">conc_lp</span><span class="p">,</span> <span class="n">spec_heat_tot_lp</span><span class="p">])</span>

    <span class="n">barrier</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_barrier</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">local_memory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s1">&#39;break&#39;</span><span class="p">,</span> <span class="n">dep</span><span class="o">=</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
    <span class="n">pre_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        &lt;&gt;spec_tot = 0 {id=spec_init}</span>
<span class="s2">        $</span><span class="si">{spec_heat_total_str}</span><span class="s2"> = 0 {id=init}</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        spec_tot = spec_tot + $</span><span class="si">{spec_heat_str}</span><span class="s2"> * $</span><span class="si">{conc_str}</span><span class="s2"> {id=update, </span><span class="se">\</span>
<span class="s2">            dep=spec_init}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">post_instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        $</span><span class="si">{barrier}</span><span class="s2"></span>
<span class="s2">        $</span><span class="si">{spec_heat_total_str}</span><span class="s2"> = $</span><span class="si">{spec_heat_total_str}</span><span class="s2"> + spec_tot </span><span class="se">\</span>
<span class="s2">            {id=sum, dep=update:init:break, nosync=init}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="n">can_vectorize</span><span class="p">,</span> <span class="n">vec_spec</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_deep_specializer</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">atomic_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sum&#39;</span><span class="p">],</span> <span class="n">init_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;init&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_total&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">spec_heat</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                          <span class="n">pre_instructions</span><span class="o">=</span><span class="p">[</span><span class="n">pre_instructions</span><span class="p">],</span>
                          <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
                          <span class="n">post_instructions</span><span class="o">=</span><span class="p">[</span><span class="n">post_instructions</span><span class="p">],</span>
                          <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
                          <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
                          <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
                          <span class="n">can_vectorize</span><span class="o">=</span><span class="n">can_vectorize</span><span class="p">,</span>
                          <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">vec_spec</span>
                          <span class="p">)</span></div>


<span class="nd">@ic</span><span class="o">.</span><span class="n">with_conditional_jacobian</span>
<span class="k">def</span> <span class="nf">__dci_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">do_ns</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fall_type</span><span class="o">=</span><span class="n">falloff_form</span><span class="o">.</span><span class="n">none</span><span class="p">,</span>
              <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jac_create</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    derivatives of the third body concentrations / falloff blending factors</span>
<span class="sd">    with respect to the molar quantity of a species</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is method is split into two kernels, the first handles derivatives of</span>
<span class="sd">    reactions with respect to the third body species in the reaction,</span>
<span class="sd">    that is if reaction `i` contains species `k, k+1...k+n`, and third body</span>
<span class="sd">    species `j, j+1... j+m`, it will consider the derivative of</span>
<span class="sd">    species `k` with respect to `j, j+1...j+m`, and so on with `k+1`,etc.</span>

<span class="sd">    The second kernel handles reactions where the last species in the mechanism</span>
<span class="sd">    has a non-default (non-unity) third body efficiency.</span>
<span class="sd">    In this case, using the strict formulation results in non-zero derivatives</span>
<span class="sd">    for _all_ species in the mechanism due to the conservation of mass</span>
<span class="sd">    formulation of the last species. That is, it will compute the derivative of</span>
<span class="sd">    `k` w.r.t species `1, 2, ... Ns - 1` where Ns is the last species in the</span>
<span class="sd">    mechanism.</span>

<span class="sd">    This second kernel may be turned off to increase sparsity (at the expense)</span>
<span class="sd">    of an incorrect jacobian.  This is often desired for implicit integrators</span>
<span class="sd">    which often only need an approximation to the Jacobian anyways.</span>

<span class="sd">    Additionally, we use a trick here to simplify the these methods for the</span>
<span class="sd">    strict formulation.  Namely, we _assume_ that the third body efficiency of</span>
<span class="sd">    the last species is unity in the first kernel.  In the second kernel, we</span>
<span class="sd">    then update the derivative of _all_ species assuming the third body species</span>
<span class="sd">    efficiency of a species `j` is unity.  By doing so, we obtain the correct</span>
<span class="sd">    multiplier ($\alpha_{i,j} - \alpha_{i, N_s}$) in all cases, and we save</span>
<span class="sd">    ourselves a fair bit of complicated indexing / looping.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    allint : dict</span>
<span class="sd">        Contains keys &#39;fwd&#39;, &#39;rev&#39; and &#39;net&#39;, with booleans corresponding to</span>
<span class="sd">        whether all nu values for that direction are integers.</span>
<span class="sd">        If True, powers of concentrations will be evaluated using</span>
<span class="sd">        multiplications</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    jac_create: Callable</span>
<span class="sd">        The conditional Jacobian instruction creator from :mod:`instruction_creator`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">fall_type</span> <span class="o">==</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">none</span><span class="p">:</span>
        <span class="n">our_inds</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_thd_only</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> \
            <span class="k">else</span> <span class="n">namestore</span><span class="o">.</span><span class="n">thd_only_ns_inds</span>
        <span class="n">rxn_range</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">thd_only_map</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> \
            <span class="k">else</span> <span class="n">namestore</span><span class="o">.</span><span class="n">thd_only_ns_map</span>
        <span class="n">thd_range</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">thd_only_map</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> \
            <span class="k">else</span> <span class="n">namestore</span><span class="o">.</span><span class="n">thd_only_ns_map</span>
        <span class="n">map_onto</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">thd_map</span>
    <span class="k">elif</span> <span class="n">fall_type</span> <span class="o">==</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">:</span>
        <span class="n">our_inds</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_sri</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> \
            <span class="k">else</span> <span class="n">namestore</span><span class="o">.</span><span class="n">sri_ns_inds</span>
        <span class="n">rxn_range</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">sri_map</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> \
            <span class="k">else</span> <span class="n">namestore</span><span class="o">.</span><span class="n">sri_has_ns</span>
        <span class="n">thd_range</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">fall_to_thd_map</span>
        <span class="n">map_onto</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">fall_map</span>
    <span class="k">elif</span> <span class="n">fall_type</span> <span class="o">==</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">:</span>
        <span class="n">our_inds</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_troe</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> \
            <span class="k">else</span> <span class="n">namestore</span><span class="o">.</span><span class="n">troe_ns_inds</span>
        <span class="n">rxn_range</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">troe_map</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> \
            <span class="k">else</span> <span class="n">namestore</span><span class="o">.</span><span class="n">troe_has_ns</span>
        <span class="n">thd_range</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">fall_to_thd_map</span>
        <span class="n">map_onto</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">fall_map</span>
    <span class="k">elif</span> <span class="n">fall_type</span> <span class="o">==</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">lind</span><span class="p">:</span>
        <span class="n">our_inds</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_lind</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> \
            <span class="k">else</span> <span class="n">namestore</span><span class="o">.</span><span class="n">lind_ns_inds</span>
        <span class="n">rxn_range</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">lind_map</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> \
            <span class="k">else</span> <span class="n">namestore</span><span class="o">.</span><span class="n">lind_has_ns</span>
        <span class="n">thd_range</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">fall_to_thd_map</span>
        <span class="n">map_onto</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">fall_map</span>

    <span class="n">knl_name</span> <span class="o">=</span> <span class="s1">&#39;dci_</span><span class="si">{}</span><span class="s1">_dnj</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="p">{</span><span class="n">falloff_form</span><span class="o">.</span><span class="n">none</span><span class="p">:</span> <span class="s1">&#39;thd&#39;</span><span class="p">,</span>
         <span class="n">falloff_form</span><span class="o">.</span><span class="n">lind</span><span class="p">:</span> <span class="s1">&#39;lind&#39;</span><span class="p">,</span>
         <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">:</span> <span class="s1">&#39;sri&#39;</span><span class="p">,</span>
         <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">:</span> <span class="s1">&#39;troe&#39;</span>
         <span class="p">}[</span><span class="n">fall_type</span><span class="p">],</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> <span class="k">else</span> <span class="s1">&#39;_ns&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">rxn_range</span><span class="o">.</span><span class="n">initializer</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="c1"># can&#39;t create kernel from empty reaction range</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># main loop is over third body rxns (including falloff / chemically</span>
    <span class="c1"># activated)</span>
    <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>

    <span class="c1"># indicies</span>
    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">fall_type</span> <span class="o">!=</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">none</span><span class="p">:</span>
        <span class="c1"># the fall to third map depending on the reaction range</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">thd_range</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>

    <span class="c1"># and from the fall / third index to the actual reaction index</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">map_onto</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>

    <span class="c1"># the third body parameters map into the rxn_range</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">thd_offset</span><span class="p">,</span> <span class="n">thd_range</span><span class="p">)</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">thd_type</span><span class="p">,</span> <span class="n">thd_range</span><span class="p">)</span>

    <span class="c1"># while the net offsets map onto the map_onto range</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rop_fwd</span><span class="p">,</span> <span class="n">map_onto</span><span class="p">)</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">map_onto</span><span class="p">)</span>

    <span class="c1"># and the reverse rop needs a map onto the rev mask</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">,</span> <span class="n">map_onto</span><span class="p">)</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">rop_rev</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">)</span>

    <span class="c1"># falloff transforms</span>
    <span class="k">if</span> <span class="n">fall_type</span> <span class="o">!=</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">none</span><span class="p">:</span>
        <span class="c1"># pr is on the falloff index</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Pr</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
        <span class="c1"># while the pressure modification term is indexed by the third body</span>
        <span class="c1"># index</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">fall_to_thd_map</span><span class="p">)</span>
        <span class="c1"># kf is on the real reaction index</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kf</span><span class="p">,</span> <span class="n">map_onto</span><span class="p">)</span>
        <span class="c1"># Fi is indexed on the falloff index</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Fi</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
        <span class="c1"># kf_fall is on the falloff reaction index</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kf_fall</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>
        <span class="c1"># and the falloff type is on the falloff index</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">fall_type</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fall_type</span> <span class="o">==</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">:</span>
            <span class="c1"># get the sri arrays, keyed on the SRI index</span>
            <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">sri_a</span><span class="p">,</span> <span class="n">our_inds</span><span class="p">)</span>
            <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">sri_b</span><span class="p">,</span> <span class="n">our_inds</span><span class="p">)</span>
            <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">sri_c</span><span class="p">,</span> <span class="n">our_inds</span><span class="p">)</span>
            <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">X_sri</span><span class="p">,</span> <span class="n">our_inds</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fall_type</span> <span class="o">==</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">:</span>
            <span class="c1"># get the troe arrays, keyed on the troe index</span>
            <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Atroe</span><span class="p">,</span> <span class="n">our_inds</span><span class="p">)</span>
            <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Btroe</span><span class="p">,</span> <span class="n">our_inds</span><span class="p">)</span>
            <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Fcent</span><span class="p">,</span> <span class="n">our_inds</span><span class="p">)</span>

    <span class="c1"># third body efficiencies, types and offsets</span>
    <span class="n">thd_offset_lp</span><span class="p">,</span> <span class="n">thd_offset_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_offset</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">thd_offset_next_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_offset</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Ns efficiency is the last efficiency of this reaction</span>
    <span class="c1"># hence, we can simply take the next reaction and subtract 1</span>
    <span class="n">thd_eff_ns_lp</span><span class="p">,</span> <span class="n">thd_eff_ns_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_eff</span><span class="p">,</span> <span class="n">thd_offset_next_str</span><span class="p">,</span> <span class="n">affine</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># third body type is on main loop</span>
    <span class="n">thd_type_lp</span><span class="p">,</span> <span class="n">thd_type_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_type</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>

    <span class="c1"># efficiencies / species are on the inner loop</span>
    <span class="n">spec_k</span> <span class="o">=</span> <span class="s1">&#39;spec_k&#39;</span>
    <span class="n">spec_j</span> <span class="o">=</span> <span class="s1">&#39;spec_j&#39;</span>
    <span class="n">spec_j_ind</span> <span class="o">=</span> <span class="s1">&#39;spec_j_ind&#39;</span>
    <span class="n">spec_k_ind</span> <span class="o">=</span> <span class="s1">&#39;spec_k_ind&#39;</span>

    <span class="c1"># third body eff of species j</span>
    <span class="n">thd_eff_lp</span><span class="p">,</span> <span class="n">thd_eff_j_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_eff</span><span class="p">,</span> <span class="n">spec_j_ind</span><span class="p">)</span>

    <span class="c1"># species j</span>
    <span class="n">thd_spec_lp</span><span class="p">,</span> <span class="n">spec_j_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">thd_spec</span><span class="p">,</span> <span class="n">spec_j_ind</span><span class="p">)</span>

    <span class="c1"># get net species</span>
    <span class="n">rxn_to_spec_offsets_lp</span><span class="p">,</span> <span class="n">rxn_to_spec_offsets_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">rxn_to_spec_offsets_next_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># species &#39;k&#39; is on k loop</span>
    <span class="n">specs_lp</span><span class="p">,</span> <span class="n">spec_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec</span><span class="p">,</span> <span class="n">spec_k_ind</span><span class="p">)</span>
    <span class="c1"># get product nu</span>
    <span class="n">nu_lp</span><span class="p">,</span> <span class="n">prod_nu_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_prod_nu</span><span class="p">,</span> <span class="n">spec_k_ind</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">spec_k_ind</span><span class="p">)</span>
    <span class="c1"># and reac nu</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">reac_nu_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_reac_nu</span><span class="p">,</span> <span class="n">spec_k_ind</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">spec_k_ind</span><span class="p">)</span>

    <span class="n">jac_map</span> <span class="o">=</span> <span class="p">(</span><span class="n">spec_k</span><span class="p">,</span> <span class="n">spec_j</span><span class="p">)</span>

    <span class="c1"># rop</span>
    <span class="n">rop_fwd_lp</span><span class="p">,</span> <span class="n">rop_fwd_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rop_fwd</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
    <span class="n">rop_rev_lp</span><span class="p">,</span> <span class="n">rop_rev_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rop_rev</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
    <span class="n">rev_mask_lp</span><span class="p">,</span> <span class="n">rev_mask_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>

    <span class="c1"># update data and extra inames</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">thd_offset_lp</span><span class="p">,</span> <span class="n">thd_eff_ns_lp</span><span class="p">,</span> <span class="n">thd_type_lp</span><span class="p">,</span> <span class="n">thd_eff_lp</span><span class="p">,</span>
                        <span class="n">thd_spec_lp</span><span class="p">,</span> <span class="n">rxn_to_spec_offsets_lp</span><span class="p">,</span> <span class="n">specs_lp</span><span class="p">,</span> <span class="n">nu_lp</span><span class="p">,</span>
                        <span class="n">rop_fwd_lp</span><span class="p">,</span> <span class="n">rop_rev_lp</span><span class="p">,</span> <span class="n">rev_mask_lp</span><span class="p">])</span>

    <span class="n">parameters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">manglers</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">fall_update</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="c1"># if we have a falloff term, need to calcule the dFi</span>
    <span class="k">if</span> <span class="n">fall_type</span> <span class="o">!=</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">none</span><span class="p">:</span>
        <span class="c1"># add entries needed by all falloff reactions</span>
        <span class="n">Pr_lp</span><span class="p">,</span> <span class="n">Pr_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Pr</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">Fi_lp</span><span class="p">,</span> <span class="n">Fi_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">Fi</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">pres_mod_lp</span><span class="p">,</span> <span class="n">pres_mod_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">kf_lp</span><span class="p">,</span> <span class="n">kf_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kf</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">kf_fall_lp</span><span class="p">,</span> <span class="n">kf_fall_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">kf_fall</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
        <span class="n">fall_type_lp</span><span class="p">,</span> <span class="n">fall_type_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">fall_type</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
        <span class="c1"># update data</span>
        <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Pr_lp</span><span class="p">,</span> <span class="n">pres_mod_lp</span><span class="p">,</span> <span class="n">kf_lp</span><span class="p">,</span> <span class="n">kf_fall_lp</span><span class="p">,</span> <span class="n">fall_type_lp</span><span class="p">,</span> <span class="n">Fi_lp</span><span class="p">])</span>

        <span class="c1"># handle type specific parameters</span>
        <span class="k">if</span> <span class="n">fall_type</span> <span class="o">==</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">:</span>
            <span class="n">sri_a_lp</span><span class="p">,</span> <span class="n">sri_a_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">sri_a</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">sri_b_lp</span><span class="p">,</span> <span class="n">sri_b_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">sri_b</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">sri_c_lp</span><span class="p">,</span> <span class="n">sri_c_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">sri_c</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="n">sri_X_lp</span><span class="p">,</span> <span class="n">sri_X_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">X_sri</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

            <span class="c1"># and the temperature</span>
            <span class="n">T_lp</span><span class="p">,</span> <span class="n">T_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">T_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">)</span>

            <span class="c1"># add data, and put together falloff string</span>
            <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">sri_a_lp</span><span class="p">,</span> <span class="n">sri_b_lp</span><span class="p">,</span> <span class="n">sri_c_lp</span><span class="p">,</span> <span class="n">sri_X_lp</span><span class="p">,</span> <span class="n">T_lp</span><span class="p">])</span>

            <span class="n">dFi</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &lt;&gt; dFi = -2 * ${sri_X_str} * ${sri_X_str} * log(${sri_a_str} * \</span>
<span class="sd">           exp(-${sri_b_str} / ${T_str}) + exp(-${T_str} / ${sri_c_str})) * \</span>
<span class="sd">           log(fmax(1e-300d, ${Pr_str})) / \</span>
<span class="sd">           (fmax(1e-300d, ${Pr_str}) * logtensquared) {id=dFi}</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
                <span class="n">sri_X_str</span><span class="o">=</span><span class="n">sri_X_str</span><span class="p">,</span>
                <span class="n">sri_a_str</span><span class="o">=</span><span class="n">sri_a_str</span><span class="p">,</span>
                <span class="n">sri_b_str</span><span class="o">=</span><span class="n">sri_b_str</span><span class="p">,</span>
                <span class="n">sri_c_str</span><span class="o">=</span><span class="n">sri_c_str</span><span class="p">,</span>
                <span class="n">T_str</span><span class="o">=</span><span class="n">T_str</span><span class="p">,</span>
                <span class="n">Pr_str</span><span class="o">=</span><span class="n">Pr_str</span>
            <span class="p">)</span>

            <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;logtensquared&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">manglers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lp_pregen</span><span class="o">.</span><span class="n">fmax</span><span class="p">())</span>

        <span class="k">elif</span> <span class="n">fall_type</span> <span class="o">==</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">:</span>
            <span class="n">Atroe_lp</span><span class="p">,</span> <span class="n">Atroe_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">Atroe</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
            <span class="n">Btroe_lp</span><span class="p">,</span> <span class="n">Btroe_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">Btroe</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>
            <span class="n">Fcent_lp</span><span class="p">,</span> <span class="n">Fcent_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
                <span class="n">namestore</span><span class="o">.</span><span class="n">Fcent</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

            <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">Atroe_lp</span><span class="p">,</span> <span class="n">Btroe_lp</span><span class="p">,</span> <span class="n">Fcent_lp</span><span class="p">])</span>

            <span class="n">dFi</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &lt;&gt; dFi = ${Atroe_str} * ${Atroe_str} + ${Btroe_str} * ${Btroe_str} \</span>
<span class="sd">            {id=dFi_init}</span>
<span class="sd">        dFi = -2 * ${Atroe_str} * ${Btroe_str} * \</span>
<span class="sd">        (0.14 * ${Atroe_str} + ${Btroe_str}) * log(fmax(${Fcent_str}, 1e-300d)) / \</span>
<span class="sd">        (fmax(${Pr_str}, 1e-300d) * dFi * dFi * logten) {id=dFi, dep=dFi_init}</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
                <span class="n">Atroe_str</span><span class="o">=</span><span class="n">Atroe_str</span><span class="p">,</span>
                <span class="n">Btroe_str</span><span class="o">=</span><span class="n">Btroe_str</span><span class="p">,</span>
                <span class="n">Fcent_str</span><span class="o">=</span><span class="n">Fcent_str</span><span class="p">,</span>
                <span class="n">Pr_str</span><span class="o">=</span><span class="n">Pr_str</span>
            <span class="p">)</span>
            <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;logten&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">manglers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lp_pregen</span><span class="o">.</span><span class="n">fmax</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># lindeman</span>
            <span class="n">dFi</span> <span class="o">=</span> <span class="s1">&#39;&lt;&gt; dFi = 0d {id=dFi}&#39;</span>

        <span class="c1"># finally handle the falloff vs chemically activated updater</span>
        <span class="n">fall_update</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        $</span><span class="si">{dFi}</span><span class="s2"></span>

<span class="s2">        # set parameters for both</span>
<span class="s2">        &lt;&gt; Fi_fac = dFi {id=dFi_fac_init, dep=dFi}</span>
<span class="s2">        if $</span><span class="si">{fall_type_str}</span><span class="s2"></span>
<span class="s2">            # chemically activated</span>
<span class="s2">            &lt;&gt;k0 = $</span><span class="si">{kf_str}</span><span class="s2"> {id=kf_chem, nosync=kf_fall}</span>
<span class="s2">            &lt;&gt;kinf = $</span><span class="si">{kf_fall_str}</span><span class="s2"> {id=kinf_chem, nosync=kinf_fall}</span>
<span class="s2">        else</span>
<span class="s2">            # fall-off</span>
<span class="s2">            kinf = $</span><span class="si">{kf_str}</span><span class="s2"> {id=kinf_fall, nosync=kinf_chem}</span>
<span class="s2">            k0 = $</span><span class="si">{kf_fall_str}</span><span class="s2"> {id=kf_fall, nosync=kf_chem}</span>
<span class="s2">            Fi_fac = $</span><span class="si">{Pr_str}</span><span class="s2"> * Fi_fac + 1 {id=dFi_fac_up, dep=dFi_fac_init}</span>
<span class="s2">        end</span>

<span class="s2">        # and update dFi</span>
<span class="s2">        dFi =  k0 * ($</span><span class="si">{Fi_str}</span><span class="s2"> * Fi_fac - $</span><span class="si">{pres_mod_str}</span><span class="s2">) / </span><span class="se">\</span>
<span class="s2">            (kinf * ($</span><span class="si">{Pr_str}</span><span class="s2"> + 1)) {id=fall, dep=kf_*:kinf_*:dFi_fac_*}</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
            <span class="n">dFi</span><span class="o">=</span><span class="n">dFi</span><span class="p">,</span>
            <span class="n">fall_type_str</span><span class="o">=</span><span class="n">fall_type_str</span><span class="p">,</span>
            <span class="n">kf_str</span><span class="o">=</span><span class="n">kf_str</span><span class="p">,</span>
            <span class="n">kf_fall_str</span><span class="o">=</span><span class="n">kf_fall_str</span><span class="p">,</span>
            <span class="n">Pr_str</span><span class="o">=</span><span class="n">Pr_str</span><span class="p">,</span>
            <span class="n">Fi_str</span><span class="o">=</span><span class="n">Fi_str</span><span class="p">,</span>
            <span class="n">pres_mod_str</span><span class="o">=</span><span class="n">pres_mod_str</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># use a no-op to simplify the dependencies</span>
        <span class="n">fall_update</span> <span class="o">=</span> <span class="s1">&#39;... nop {id=fall}&#39;</span>

    <span class="c1"># create the jacobian update</span>
    <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
        <span class="s2">&quot;$</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + nu_k * dci * ropi$</span><span class="si">{fall_mul_str}</span><span class="s2"> &quot;</span>
        <span class="s2">&quot;{id=jac, dep=$</span><span class="si">{deps}</span><span class="s2">}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span>
        <span class="n">fall_mul_str</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39; * dFi &#39;</span> <span class="k">if</span> <span class="n">fall_type</span> <span class="o">!=</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">none</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
    <span class="c1"># and jacobian</span>
    <span class="n">jac_lp</span><span class="p">,</span> <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="o">*</span><span class="n">jac_map</span><span class="p">,</span>
        <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">jac_map</span><span class="p">},</span> <span class="n">insn</span><span class="o">=</span><span class="n">jac_update_insn</span><span class="p">,</span>
        <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;fall:spec_k:ropi_up&#39;</span>
    <span class="p">)</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jac_lp</span><span class="p">)</span>
    <span class="c1"># update the subtitution args</span>
    <span class="n">subs</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">subs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;ns&#39;</span><span class="p">:</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                 <span class="s1">&#39;mix&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">thd_body_type</span><span class="o">.</span><span class="n">mix</span><span class="p">),</span>
                 <span class="s1">&#39;species&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">thd_body_type</span><span class="o">.</span><span class="n">species</span><span class="p">)})</span>
    <span class="n">extra_inames</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">spec_k_ind</span><span class="p">,</span> <span class="s1">&#39;rxn_off &lt;= </span><span class="si">{}</span><span class="s1"> &lt; rxn_off_next&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec_k_ind</span><span class="p">))]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span><span class="p">:</span>
        <span class="n">extra_inames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span><span class="n">spec_j_ind</span><span class="p">,</span> <span class="s1">&#39;thd_off &lt;= </span><span class="si">{}</span><span class="s1"> &lt; thd_off_next&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec_j_ind</span><span class="p">)))</span>

        <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        &lt;&gt; thd_off = $</span><span class="si">{thd_offset_str}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; thd_off_next = $</span><span class="si">{thd_offset_next_str}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; rxn_off = $</span><span class="si">{rxn_to_spec_offsets_str}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; rxn_off_next = $</span><span class="si">{rxn_to_spec_offsets_next_str}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; ropi = $</span><span class="si">{rop_fwd_str}</span><span class="s2"> {id=ropi}</span>
<span class="s2">        if $</span><span class="si">{rev_mask_str}</span><span class="s2"> &gt;= 0</span>
<span class="s2">            ropi = ropi - $</span><span class="si">{rop_rev_str}</span><span class="s2"> {id=ropi_up, dep=ropi}</span>
<span class="s2">        end</span>
<span class="s2">        $</span><span class="si">{fall_update}</span><span class="s2"> # insert falloff form if necessary</span>
<span class="s2">        for $</span><span class="si">{spec_j_ind}</span><span class="s2"></span>
<span class="s2">            &lt;&gt; spec_j = $</span><span class="si">{spec_j_str}</span><span class="s2"></span>
<span class="s2">            if $</span><span class="si">{spec_j}</span><span class="s2"> != $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">                &lt;&gt; dci = 0 {id=ci_init}</span>
<span class="s2">                if $</span><span class="si">{thd_type_str}</span><span class="s2"> == $</span><span class="si">{mix}</span><span class="s2"></span>
<span class="s2">                    # here we assume the last species has an efficiency of 1</span>
<span class="s2">                    # if this is not true, it will be fixed in the Ns kernel</span>
<span class="s2">                    dci = $</span><span class="si">{thd_eff_j_str}</span><span class="s2"> - 1.0 {id=ci_up, dep=ci_init}</span>
<span class="s2">                end</span>
<span class="s2">                if $</span><span class="si">{thd_type_str}</span><span class="s2"> == $</span><span class="si">{species}</span><span class="s2"></span>
<span class="s2">                    # if we get here, delta(j, m) is true by default</span>
<span class="s2">                    # hence derivative is one</span>
<span class="s2">                    dci = 1d {id=ci_up2, dep=ci_init}</span>
<span class="s2">                end</span>
<span class="s2">                for $</span><span class="si">{spec_k_ind}</span><span class="s2"></span>
<span class="s2">                    if $</span><span class="si">{spec_k_str}</span><span class="s2"> != $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">                        &lt;&gt; $</span><span class="si">{spec_k}</span><span class="s2"> = $</span><span class="si">{spec_k_str}</span><span class="s2"> {id=spec_k}</span>
<span class="s2">                        &lt;&gt; nu_k= $</span><span class="si">{prod_nu_k_str}</span><span class="s2"> - $</span><span class="si">{reac_nu_k_str}</span><span class="s2"></span>
<span class="s2">                        $</span><span class="si">{jac_update_insn}</span><span class="s2"></span>
<span class="s2">                    end</span>
<span class="s2">                end</span>
<span class="s2">            end</span>
<span class="s2">        end</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="n">subs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extra_inames</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">spec_j</span><span class="p">,</span> <span class="s1">&#39;0 &lt;= </span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">spec_j</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>

        <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        &lt;&gt; rxn_off = $</span><span class="si">{rxn_to_spec_offsets_str}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; rxn_off_next = $</span><span class="si">{rxn_to_spec_offsets_next_str}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; ns_thd_eff = $</span><span class="si">{thd_eff_ns_str}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; ropi = $</span><span class="si">{rop_fwd_str}</span><span class="s2"> {id=ropi}</span>
<span class="s2">        if $</span><span class="si">{rev_mask_str}</span><span class="s2"> &gt;= 0</span>
<span class="s2">            ropi = ropi - $</span><span class="si">{rop_rev_str}</span><span class="s2"> {id=ropi_up, dep=ropi}</span>
<span class="s2">        end</span>
<span class="s2">        &lt;&gt; dci = 0 {id=ci_init}</span>
<span class="s2">        $</span><span class="si">{fall_update}</span><span class="s2"> # insert falloff form if necessary</span>
<span class="s2">        if $</span><span class="si">{thd_type_str}</span><span class="s2"> == $</span><span class="si">{mix}</span><span class="s2"></span>
<span class="s2">            # non-specified species have a efficiency of 1.0</span>
<span class="s2">            # and we have already deducted an efficiency of 1.0 from the</span>
<span class="s2">            # specified species</span>
<span class="s2">            # Hence, this formulation accounts for both parts of </span><span class="se">\a</span><span class="s2">lpha_j - </span><span class="se">\a</span><span class="s2">lpha_ns</span>
<span class="s2">            dci = 1.0 - ns_thd_eff {id=ci_up, dep=ci_init}</span>
<span class="s2">        end</span>
<span class="s2">        if $</span><span class="si">{thd_type_str}</span><span class="s2"> == $</span><span class="si">{species}</span><span class="s2"></span>
<span class="s2">            dci = -1.0d {id=ci_up2, dep=ci_init}</span>
<span class="s2">        end</span>
<span class="s2">        for $</span><span class="si">{spec_k_ind}</span><span class="s2"></span>
<span class="s2">            &lt;&gt; $</span><span class="si">{spec_k}</span><span class="s2"> = $</span><span class="si">{spec_k_str}</span><span class="s2"> {id=spec_k}</span>
<span class="s2">            &lt;&gt; nu_k= $</span><span class="si">{prod_nu_k_str}</span><span class="s2"> - $</span><span class="si">{reac_nu_k_str}</span><span class="s2"></span>
<span class="s2">            if $</span><span class="si">{spec_k}</span><span class="s2"> != $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">                for $</span><span class="si">{spec_j}</span><span class="s2"></span>
<span class="s2">                    $</span><span class="si">{jac_update_insn}</span><span class="s2"></span>
<span class="s2">                end</span>
<span class="s2">            end</span>
<span class="s2">        end</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="n">subs</span><span class="p">)</span>

    <span class="n">inames</span><span class="p">,</span> <span class="n">ranges</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">extra_inames</span><span class="p">)</span>
    <span class="c1"># join inames</span>
    <span class="n">extra_inames</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inames</span><span class="p">),</span> <span class="s1">&#39; and &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ranges</span><span class="p">))]</span>

    <span class="n">can_vectorize</span><span class="p">,</span> <span class="n">vec_spec</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_deep_specializer</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">atomic_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">knl_name</span><span class="p">,</span>
                          <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
                          <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
                          <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
                          <span class="n">extra_inames</span><span class="o">=</span><span class="n">extra_inames</span><span class="p">,</span>
                          <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
                          <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
                          <span class="n">manglers</span><span class="o">=</span><span class="n">manglers</span><span class="p">,</span>
                          <span class="n">can_vectorize</span><span class="o">=</span><span class="n">can_vectorize</span><span class="p">,</span>
                          <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">vec_spec</span>
                          <span class="p">)</span>


<div class="viewcode-block" id="dci_thd_dnj"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dci_thd_dnj">[docs]</a><span class="k">def</span> <span class="nf">dci_thd_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    derivatives of the pressure modification term of third body reactions</span>
<span class="sd">    with respect to the molar quantity of a species</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See :meth:`pyjac.core.create_jacobian.__dci_dnj`</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    allint : dict</span>
<span class="sd">        Contains keys &#39;fwd&#39;, &#39;rev&#39; and &#39;net&#39;, with booleans corresponding to</span>
<span class="sd">        whether all nu values for that direction are integers.</span>
<span class="sd">        If True, powers of concentrations will be evaluated using</span>
<span class="sd">        multiplications</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">infos</span> <span class="o">=</span> <span class="p">[</span><span class="n">__dci_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)]</span>
    <span class="n">ns_info</span> <span class="o">=</span> <span class="n">__dci_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ns_info</span><span class="p">:</span>
        <span class="n">infos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ns_info</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">infos</span></div>


<div class="viewcode-block" id="dci_lind_dnj"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dci_lind_dnj">[docs]</a><span class="k">def</span> <span class="nf">dci_lind_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    derivatives of the pressure modification term of Lindemann falloff</span>
<span class="sd">    reactions with respect to the molar quantity of a species</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See :meth:`pyjac.core.create_jacobian.__dci_dnj`</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    allint : dict</span>
<span class="sd">        Contains keys &#39;fwd&#39;, &#39;rev&#39; and &#39;net&#39;, with booleans corresponding to</span>
<span class="sd">        whether all nu values for that direction are integers.</span>
<span class="sd">        If True, powers of concentrations will be evaluated using</span>
<span class="sd">        multiplications</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">infos</span> <span class="o">=</span> <span class="p">[</span><span class="n">__dci_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">lind</span><span class="p">,</span>
                       <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)]</span>
    <span class="n">ns_info</span> <span class="o">=</span> <span class="n">__dci_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">lind</span><span class="p">,</span>
                        <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ns_info</span><span class="p">:</span>
        <span class="n">infos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ns_info</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">infos</span></div>


<div class="viewcode-block" id="dci_sri_dnj"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dci_sri_dnj">[docs]</a><span class="k">def</span> <span class="nf">dci_sri_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    derivatives of the pressure modification term of SRI falloff</span>
<span class="sd">    reactions with respect to the molar quantity of a species</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See :meth:`pyjac.core.create_jacobian.__dci_dnj`</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    allint : dict</span>
<span class="sd">        Contains keys &#39;fwd&#39;, &#39;rev&#39; and &#39;net&#39;, with booleans corresponding to</span>
<span class="sd">        whether all nu values for that direction are integers.</span>
<span class="sd">        If True, powers of concentrations will be evaluated using</span>
<span class="sd">        multiplications</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">infos</span> <span class="o">=</span> <span class="p">[</span><span class="n">__dci_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">,</span>
                       <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)]</span>
    <span class="n">ns_info</span> <span class="o">=</span> <span class="n">__dci_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">sri</span><span class="p">,</span>
                        <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ns_info</span><span class="p">:</span>
        <span class="n">infos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ns_info</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">infos</span></div>


<div class="viewcode-block" id="dci_troe_dnj"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dci_troe_dnj">[docs]</a><span class="k">def</span> <span class="nf">dci_troe_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    derivatives of the pressure modification term of Troe falloff</span>
<span class="sd">    reactions with respect to the molar quantity of a species</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See :meth:`pyjac.core.create_jacobian.__dci_dnj`</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    allint : dict</span>
<span class="sd">        Contains keys &#39;fwd&#39;, &#39;rev&#39; and &#39;net&#39;, with booleans corresponding to</span>
<span class="sd">        whether all nu values for that direction are integers.</span>
<span class="sd">        If True, powers of concentrations will be evaluated using</span>
<span class="sd">        multiplications</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">infos</span> <span class="o">=</span> <span class="p">[</span><span class="n">__dci_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">,</span>
                       <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)]</span>
    <span class="n">ns_info</span> <span class="o">=</span> <span class="n">__dci_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">falloff_form</span><span class="o">.</span><span class="n">troe</span><span class="p">,</span>
                        <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ns_info</span><span class="p">:</span>
        <span class="n">infos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ns_info</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">infos</span></div>


<span class="nd">@ic</span><span class="o">.</span><span class="n">with_conditional_jacobian</span>
<span class="k">def</span> <span class="nf">__dropidnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">allint</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">do_ns</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">jac_create</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates instructions, kernel arguements, and data for calculating</span>
<span class="sd">    derivatives of the Rate of Progress with respect to the molar quantity of</span>
<span class="sd">    a species</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is method is split into two kernels, the first handles derivatives of</span>
<span class="sd">    reactions with respect to the species in the reaction, that is if reaction</span>
<span class="sd">    `i` contains species `k, k+1...k+n`, it will consider the derivative of</span>
<span class="sd">    species `k` with respect to `k, k+1, k+2... k+n`, and so on with `k+1`,etc.</span>

<span class="sd">    The second kernel handles reactions where the last species in the mechanism</span>
<span class="sd">    is present in the reaction.  In this case, using the strict formulation</span>
<span class="sd">    results in non-zero derivatives for _all_ species in the mechanism due to</span>
<span class="sd">    the conservation of mass formulation of the last species. That is, it will</span>
<span class="sd">    compute the derivative of `k` w.r.t species `1, 2, ... Ns - 1` where Ns is</span>
<span class="sd">    the last species in the mechanism.</span>

<span class="sd">    This second kernel may be turned off to increase sparsity (at the expense)</span>
<span class="sd">    of an incorrect jacobian.  This is often desired for implicit integrators</span>
<span class="sd">    which often only need an approximation to the Jacobian anyways.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    allint : dict</span>
<span class="sd">        Contains keys &#39;fwd&#39;, &#39;rev&#39; and &#39;net&#39;, with booleans corresponding to</span>
<span class="sd">        whether all nu values for that direction are integers.</span>
<span class="sd">        If True, powers of concentrations will be evaluated using</span>
<span class="sd">        multiplications</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    jac_create: Callable</span>
<span class="sd">        The conditional Jacobian instruction creator from :mod:`instruction_creator`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spec_j</span> <span class="o">=</span> <span class="s1">&#39;spec_j&#39;</span>
    <span class="n">spec_k</span> <span class="o">=</span> <span class="s1">&#39;spec_k&#39;</span>
    <span class="n">net_ind_k</span> <span class="o">=</span> <span class="s1">&#39;net_ind_k&#39;</span>
    <span class="n">net_ind_j</span> <span class="o">=</span> <span class="s1">&#39;net_ind_j&#39;</span>

    <span class="n">net_ind_inner</span> <span class="o">=</span> <span class="s1">&#39;net_ind_inner&#39;</span>
    <span class="n">spec_inner</span> <span class="o">=</span> <span class="s1">&#39;spec_inner&#39;</span>
    <span class="n">inner_inds</span> <span class="o">=</span> <span class="p">(</span><span class="n">net_ind_j</span><span class="p">,</span> <span class="n">net_ind_inner</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> <span class="k">else</span> <span class="p">(</span>
        <span class="n">net_ind_inner</span><span class="p">,)</span>

    <span class="n">jac_map</span> <span class="o">=</span> <span class="p">(</span><span class="n">spec_k</span><span class="p">,</span> <span class="n">spec_j</span><span class="p">)</span>

    <span class="c1"># indicies</span>
    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="n">rxn_range</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_reacs</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span> <span class="k">else</span> <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_has_ns</span>
    <span class="k">if</span> <span class="n">do_ns</span> <span class="ow">and</span> <span class="n">rxn_range</span><span class="o">.</span><span class="n">initializer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">rxn_range</span><span class="o">.</span><span class="n">initializer</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>
    <span class="c1"># get net offsets</span>

    <span class="c1"># may need offset on all arrays on the main loop if do_ns,</span>
    <span class="c1"># hence check for transforms</span>
    <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">do_ns</span><span class="p">:</span>
        <span class="c1"># check for transform on forward</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">kf</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>

        <span class="c1"># and reverse</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>

        <span class="c1"># check and add transforms for pressure mod</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">thd_mask</span><span class="p">,</span> <span class="n">rxn_range</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># add default transforms</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">kr</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">)</span>
        <span class="n">mapstore</span><span class="o">.</span><span class="n">check_and_add_transform</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">thd_mask</span><span class="p">)</span>

    <span class="n">rxn_to_spec_offsets_lp</span><span class="p">,</span> <span class="n">rxn_to_spec_offsets_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">rxn_to_spec_offsets_next_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_offsets</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># get net species</span>
    <span class="n">net_specs_lp</span><span class="p">,</span> <span class="n">net_spec_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec</span><span class="p">,</span> <span class="n">net_ind_k</span><span class="p">)</span>

    <span class="c1"># get product nu</span>
    <span class="n">net_nu_lp</span><span class="p">,</span> <span class="n">prod_nu_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_prod_nu</span><span class="p">,</span> <span class="n">net_ind_k</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">net_ind_k</span><span class="p">)</span>
    <span class="c1"># and reac nu</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">reac_nu_k_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_reac_nu</span><span class="p">,</span> <span class="n">net_ind_k</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">net_ind_k</span><span class="p">)</span>

    <span class="c1"># Check for forward / rev / third body maps with/without NS</span>
    <span class="n">rev_mask_lp</span><span class="p">,</span> <span class="n">rev_mask_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
    <span class="n">kr_lp</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pres_mod_lp</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">do_ns</span><span class="p">:</span>
        <span class="c1"># create mask string and use as kr index</span>
        <span class="n">rev_mask_lp</span><span class="p">,</span> <span class="n">rev_mask_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
        <span class="n">kr_lp</span><span class="p">,</span> <span class="n">kr_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">kr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">rev_mask_str</span><span class="p">)</span>

        <span class="c1"># create mask string and use as pmod index</span>
        <span class="n">pmod_mask_lp</span><span class="p">,</span> <span class="n">pmod_mask_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">thd_mask</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
        <span class="n">pres_mod_lp</span><span class="p">,</span> <span class="n">pres_mod_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">pmod_mask_str</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># default creators:</span>
        <span class="n">rev_mask_lp</span><span class="p">,</span> <span class="n">rev_mask_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">rev_mask</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
        <span class="n">kr_lp</span><span class="p">,</span> <span class="n">kr_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">kr</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

        <span class="n">pmod_mask_lp</span><span class="p">,</span> <span class="n">pmod_mask_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">thd_mask</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
        <span class="n">pres_mod_lp</span><span class="p">,</span> <span class="n">pres_mod_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
            <span class="n">namestore</span><span class="o">.</span><span class="n">pres_mod</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

    <span class="c1"># get fwd / rev rates</span>

    <span class="n">kf_lp</span><span class="p">,</span> <span class="n">kf_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">kf</span><span class="p">,</span> <span class="o">*</span><span class="n">default_inds</span><span class="p">)</span>

    <span class="c1"># next we need the forward / reverse nu&#39;s and species</span>
    <span class="n">specs_lp</span><span class="p">,</span> <span class="n">spec_j_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec</span><span class="p">,</span> <span class="n">net_ind_j</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">spec_inner_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec</span><span class="p">,</span> <span class="n">net_ind_inner</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">spec_j_prod_nu_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_prod_nu</span><span class="p">,</span> <span class="n">net_ind_j</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">net_ind_j</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">spec_j_reac_nu_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_reac_nu</span><span class="p">,</span> <span class="n">net_ind_j</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">net_ind_j</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">inner_prod_nu_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_prod_nu</span><span class="p">,</span> <span class="n">net_ind_inner</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">net_ind_inner</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">inner_reac_nu_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">rxn_to_spec_reac_nu</span><span class="p">,</span> <span class="n">net_ind_inner</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="n">net_ind_inner</span><span class="p">)</span>

    <span class="c1"># finally, we need the concentrations for the fwd / rev loops</span>
    <span class="n">conc_lp</span><span class="p">,</span> <span class="n">conc_inner_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span>
        <span class="n">namestore</span><span class="o">.</span><span class="n">conc_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">spec_inner</span><span class="p">)</span>

    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">rxn_to_spec_offsets_lp</span><span class="p">,</span> <span class="n">net_specs_lp</span><span class="p">,</span> <span class="n">net_nu_lp</span><span class="p">,</span>
                        <span class="n">pres_mod_lp</span><span class="p">,</span> <span class="n">kf_lp</span><span class="p">,</span> <span class="n">kr_lp</span><span class="p">,</span> <span class="n">conc_lp</span><span class="p">,</span>
                        <span class="n">pmod_mask_lp</span><span class="p">,</span> <span class="n">rev_mask_lp</span><span class="p">])</span>

    <span class="c1"># now start creating the instructions</span>

    <span class="n">extra_inames</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">net_ind_k</span><span class="p">,</span>
         <span class="s1">&#39;net_offset &lt;= </span><span class="si">{}</span><span class="s1"> &lt; net_offset_next&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">net_ind_k</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">inner_inds</span><span class="p">:</span>
        <span class="n">extra_inames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;inner_offset &lt;= </span><span class="si">{}</span><span class="s1"> &lt; inner_offset_next&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ind</span><span class="p">)))</span>

    <span class="c1"># get the appropriate power function and calls</span>
    <span class="n">power_func</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">power_function</span><span class="p">(</span><span class="n">loopy_opts</span><span class="o">.</span><span class="n">lang</span><span class="p">,</span> <span class="n">is_integer_power</span><span class="o">=</span><span class="n">allint</span><span class="p">,</span>
                                      <span class="n">guard_nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nu_fwd</span> <span class="o">=</span> <span class="s1">&#39;nu_fwd&#39;</span>
    <span class="n">nu_rev</span> <span class="o">=</span> <span class="s1">&#39;nu_rev&#39;</span>
    <span class="n">pow_conc_fwd</span> <span class="o">=</span> <span class="n">power_func</span><span class="p">(</span><span class="n">conc_inner_str</span><span class="p">,</span> <span class="n">nu_fwd</span><span class="p">)</span>
    <span class="n">pow_conc_rev</span> <span class="o">=</span> <span class="n">power_func</span><span class="p">(</span><span class="n">conc_inner_str</span><span class="p">,</span> <span class="n">nu_rev</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">do_ns</span><span class="p">:</span>
        <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;$</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + (kf_i * Sj_fwd - kr_i * Sj_rev)&quot;</span>
            <span class="s2">&quot;* ci * nu_k {id=jac, dep=$</span><span class="si">{deps}</span><span class="s2">}&quot;</span><span class="p">)</span>

        <span class="c1"># and finally the jacobian</span>
        <span class="n">jac_lp</span><span class="p">,</span> <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
            <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="o">*</span><span class="n">jac_map</span><span class="p">,</span>
            <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">jac_map</span><span class="p">},</span>
            <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;Sj_fwd_up:Sj_rev_up:ci_up:nu_k:spec_k:kf:kr2&#39;</span><span class="p">,</span> <span class="n">insn</span><span class="o">=</span><span class="n">jac_update_insn</span>
        <span class="p">)</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            for $</span><span class="si">{net_ind_j}</span><span class="s2"></span>
<span class="s2">                &lt;&gt; $</span><span class="si">{spec_j}</span><span class="s2"> = $</span><span class="si">{spec_j_str}</span><span class="s2"> {id=spec_j}</span>
<span class="s2">                if $</span><span class="si">{spec_j}</span><span class="s2"> != $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">                    &lt;&gt; Sj_fwd = $</span><span class="si">{spec_j_reac_nu_str}</span><span class="s2"> {id=Sj_fwd_init}</span>
<span class="s2">                    &lt;&gt; Sj_rev = $</span><span class="si">{spec_j_prod_nu_str}</span><span class="s2"> {id=Sj_rev_init}</span>
<span class="s2">                    for $</span><span class="si">{net_ind_inner}</span><span class="s2"></span>
<span class="s2">                        &lt;&gt; $</span><span class="si">{nu_fwd}</span><span class="s2"> = $</span><span class="si">{inner_reac_nu_str}</span><span class="s2"> {id=nuf_inner}</span>
<span class="s2">                        &lt;&gt; $</span><span class="si">{nu_rev}</span><span class="s2"> = $</span><span class="si">{inner_prod_nu_str}</span><span class="s2"> {id=nur_inner}</span>
<span class="s2">                        &lt;&gt; $</span><span class="si">{spec_inner}</span><span class="s2"> = $</span><span class="si">{spec_inner_str}</span><span class="s2"></span>
<span class="s2">                        # handle nu</span>
<span class="s2">                        if $</span><span class="si">{spec_inner}</span><span class="s2"> == $</span><span class="si">{spec_j}</span><span class="s2"></span>
<span class="s2">                            $</span><span class="si">{nu_fwd}</span><span class="s2"> = $</span><span class="si">{nu_fwd}</span><span class="s2"> - 1 </span><span class="se">\</span>
<span class="s2">                                {id=nuf_inner_up, dep=nuf_inner}</span>
<span class="s2">                        end</span>
<span class="s2">                        if $</span><span class="si">{spec_inner}</span><span class="s2"> == $</span><span class="si">{spec_j}</span><span class="s2"></span>
<span class="s2">                            $</span><span class="si">{nu_rev}</span><span class="s2"> = $</span><span class="si">{nu_rev}</span><span class="s2"> - 1 </span><span class="se">\</span>
<span class="s2">                                {id=nur_inner_up, dep=nur_inner}</span>
<span class="s2">                        end</span>
<span class="s2">                        Sj_fwd = Sj_fwd * $</span><span class="si">{pow_conc_fwd}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                            {id=Sj_fwd_up, dep=Sj_fwd_init:nuf_inner_up}</span>
<span class="s2">                        Sj_rev = Sj_rev * $</span><span class="si">{pow_conc_rev}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                            {id=Sj_rev_up, dep=Sj_rev_init:nur_inner_up}</span>
<span class="s2">                    end</span>
<span class="s2">                    # and update Jacobian</span>
<span class="s2">                    $</span><span class="si">{jac_update_insn}</span><span class="s2"></span>
<span class="s2">                end</span>
<span class="s2">            end</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;$</span><span class="si">{jac_str}</span><span class="s2"> = $</span><span class="si">{jac_str}</span><span class="s2"> + jac_updater &quot;</span>
                           <span class="s2">&quot;{id=jac, dep=$</span><span class="si">{deps}</span><span class="s2">}&quot;</span><span class="p">)</span>
        <span class="c1"># and finally the jacobian</span>
        <span class="n">jac_lp</span><span class="p">,</span> <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
            <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="o">*</span><span class="n">jac_map</span><span class="p">,</span>
            <span class="n">affine</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">jac_map</span><span class="p">},</span> <span class="n">insn</span><span class="o">=</span><span class="n">jac_update_insn</span>
        <span class="p">)</span>
        <span class="n">extra_inames</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">spec_j</span><span class="p">,</span> <span class="s1">&#39;0 &lt;= </span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">spec_j</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">num_specs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            &lt;&gt; Sns_fwd = 1.0d {id=Sns_fwd_init}</span>
<span class="s2">            &lt;&gt; Sns_rev = 1.0d {id=Sns_rev_init}</span>
<span class="s2">            for $</span><span class="si">{net_ind_inner}</span><span class="s2"></span>
<span class="s2">                &lt;&gt; $</span><span class="si">{nu_fwd}</span><span class="s2"> = $</span><span class="si">{inner_reac_nu_str}</span><span class="s2"> {id=nuf_inner}</span>
<span class="s2">                &lt;&gt; $</span><span class="si">{nu_rev}</span><span class="s2"> = $</span><span class="si">{inner_prod_nu_str}</span><span class="s2"> {id=nur_inner}</span>
<span class="s2">                &lt;&gt; $</span><span class="si">{spec_inner}</span><span class="s2"> = $</span><span class="si">{spec_inner_str}</span><span class="s2"></span>
<span class="s2">                # handle nu</span>
<span class="s2">                if $</span><span class="si">{spec_inner}</span><span class="s2"> == $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">                    Sns_fwd = Sns_fwd * nu_fwd {id=Sns_fwd_up, dep=Sns_fwd_init}</span>
<span class="s2">                    $</span><span class="si">{nu_fwd}</span><span class="s2"> = $</span><span class="si">{nu_fwd}</span><span class="s2"> - 1 </span><span class="se">\</span>
<span class="s2">                        {id=nuf_inner_up, dep=nuf_inner:Sns_fwd_up}</span>
<span class="s2">                end</span>
<span class="s2">                Sns_fwd = Sns_fwd * $</span><span class="si">{pow_conc_fwd}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                    {id=Sns_fwd_up2, dep=Sns_fwd_up:nuf_inner_up}</span>
<span class="s2">                if $</span><span class="si">{spec_inner}</span><span class="s2"> == $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">                    Sns_rev = Sns_rev * nu_rev {id=Sns_rev_up, dep=Sns_rev_init}</span>
<span class="s2">                    $</span><span class="si">{nu_rev}</span><span class="s2"> = $</span><span class="si">{nu_rev}</span><span class="s2"> - 1 </span><span class="se">\</span>
<span class="s2">                        {id=nur_inner_up, dep=nur_inner:Sns_rev_up}</span>
<span class="s2">                end</span>
<span class="s2">                Sns_rev = Sns_rev * $</span><span class="si">{pow_conc_rev}</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                    {id=Sns_rev_up2, dep=Sns_rev_up:nur_inner_up}</span>
<span class="s2">            end</span>
<span class="s2">            # and update Jacobian for all species in this row</span>
<span class="s2">            &lt;&gt; jac_updater =  (kr_i * Sns_rev - kf_i * Sns_fwd) * ci * nu_k </span><span class="se">\</span>
<span class="s2">                {id=jac_up, dep=Sns_fwd_up*:Sns_rev_up*:ci_up:nu_k:spec_k:kf:kr*}</span>
<span class="s2">            for $</span><span class="si">{spec_j}</span><span class="s2"></span>
<span class="s2">                $</span><span class="si">{jac_update_insn}</span><span class="s2"></span>
<span class="s2">            end</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">kernel_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jac_lp</span><span class="p">)</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        # loop over all species in reaction</span>
<span class="s2">        &lt;&gt; ci = 1.0d {id=ci_set}</span>
<span class="s2">        if $</span><span class="si">{pmod_mask_str}</span><span class="s2"> &gt;= 0</span>
<span class="s2">            ci = $</span><span class="si">{pres_mod_str}</span><span class="s2"> {id=ci_up, dep=ci_set}</span>
<span class="s2">        end</span>
<span class="s2">        &lt;&gt; kf_i = $</span><span class="si">{kf_str}</span><span class="s2"> {id=kf}</span>
<span class="s2">        &lt;&gt; kr_i = 0.0d {id=kr}</span>
<span class="s2">        if $</span><span class="si">{rev_mask_str}</span><span class="s2"> &gt;= 0</span>
<span class="s2">            kr_i = $</span><span class="si">{kr_str}</span><span class="s2"> {id=kr2, dep=kr}</span>
<span class="s2">        end</span>

<span class="s2">        &lt;&gt; net_offset = $</span><span class="si">{rxn_to_spec_offsets_str}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; net_offset_next = $</span><span class="si">{rxn_to_spec_offsets_next_str}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; inner_offset = $</span><span class="si">{rxn_to_spec_offsets_str}</span><span class="s2"></span>
<span class="s2">        &lt;&gt; inner_offset_next = $</span><span class="si">{rxn_to_spec_offsets_next_str}</span><span class="s2"></span>
<span class="s2">        # loop over net species</span>
<span class="s2">        for $</span><span class="si">{net_ind_k}</span><span class="s2"></span>
<span class="s2">            # get species and nu k</span>
<span class="s2">            &lt;&gt; $</span><span class="si">{spec_k}</span><span class="s2"> = $</span><span class="si">{net_spec_k_str}</span><span class="s2"> {id=spec_k}</span>
<span class="s2">            if $</span><span class="si">{spec_k}</span><span class="s2"> != $</span><span class="si">{ns}</span><span class="s2"></span>
<span class="s2">                &lt;&gt; nu_k = $</span><span class="si">{prod_nu_k_str}</span><span class="s2"> - $</span><span class="si">{reac_nu_k_str}</span><span class="s2"> {id=nu_k}</span>
<span class="s2">                # put in inner</span>
<span class="s2">                $</span><span class="si">{inner}</span><span class="s2"></span>
<span class="s2">            end</span>
<span class="s2">        end</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="n">inner</span><span class="o">=</span><span class="n">inner</span><span class="p">)</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
        <span class="n">ns</span><span class="o">=</span><span class="n">namestore</span><span class="o">.</span><span class="n">num_specs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="o">**</span><span class="nb">locals</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="n">inames</span><span class="p">,</span> <span class="n">ranges</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">extra_inames</span><span class="p">)</span>
    <span class="c1"># join inames</span>
    <span class="n">extra_inames</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inames</span><span class="p">),</span> <span class="s1">&#39; and &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ranges</span><span class="p">))]</span>

    <span class="n">can_vectorize</span><span class="p">,</span> <span class="n">vec_spec</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">get_deep_specializer</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">atomic_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;dRopidnj</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;_ns&#39;</span> <span class="k">if</span> <span class="n">do_ns</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
                          <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
                          <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
                          <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
                          <span class="n">extra_inames</span><span class="o">=</span><span class="n">extra_inames</span><span class="p">,</span>
                          <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
                          <span class="n">preambles</span><span class="o">=</span><span class="n">lp_pregen</span><span class="o">.</span><span class="n">power_function_preambles</span><span class="p">(</span>
                            <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">power_func</span><span class="p">),</span>
                          <span class="n">manglers</span><span class="o">=</span><span class="n">lp_pregen</span><span class="o">.</span><span class="n">power_function_manglers</span><span class="p">(</span>
                            <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">power_func</span><span class="p">),</span>
                          <span class="n">can_vectorize</span><span class="o">=</span><span class="n">can_vectorize</span><span class="p">,</span>
                          <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">vec_spec</span>
                          <span class="p">)</span>


<div class="viewcode-block" id="dRopi_dnj"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.dRopi_dnj">[docs]</a><span class="k">def</span> <span class="nf">dRopi_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">allint</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple wrapper for :func:`__dropidnj` that populates both the Ns and non-Ns</span>
<span class="sd">    derivatives</span>

<span class="sd">    See :func:`__dropidnj` for full details</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    namestore : :class:`array_creator.NameStore`</span>
<span class="sd">        The namestore / creator for this method</span>
<span class="sd">    allint : dict</span>
<span class="sd">        Contains keys &#39;fwd&#39;, &#39;rev&#39; and &#39;net&#39;, with booleans corresponding to</span>
<span class="sd">        whether all nu values for that direction are integers.</span>
<span class="sd">        If True, powers of concentrations will be evaluated using</span>
<span class="sd">        multiplications</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span>
        <span class="n">__dropidnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">allint</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span> <span class="n">do_ns</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">__dropidnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">allint</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span> <span class="n">do_ns</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="finite_difference_jacobian"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.finite_difference_jacobian">[docs]</a><span class="nd">@ic</span><span class="o">.</span><span class="n">with_conditional_jacobian</span>
<span class="k">def</span> <span class="nf">finite_difference_jacobian</span><span class="p">(</span><span class="n">reacs</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">,</span>
                               <span class="n">mode</span><span class="o">=</span><span class="n">FiniteDifferenceMode</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span>
                               <span class="n">jac_create</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mem_limits</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a wrapper around the species rates kernels that evaluates a central,</span>
<span class="sd">    forward or backwards finite difference Jacobian of the given :param:`order`,</span>
<span class="sd">    based on perturbations calculated from :param:`rtol` and :param:`atol`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reacs : list of :class:`ReacInfo`</span>
<span class="sd">        List of species in the mechanism.</span>
<span class="sd">    specs : list of :class:`SpecInfo`</span>
<span class="sd">        List of species in the mechanism.</span>
<span class="sd">    loopy_opts : :class:`loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    conp : bool</span>
<span class="sd">        If true, generate equations using constant pressure assumption</span>
<span class="sd">        If false, use constant volume equations</span>
<span class="sd">    loopy_opts : `loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not none, this kernel is being used for testing.</span>
<span class="sd">        Hence we need to size the arrays accordingly</span>
<span class="sd">    order: int [1]</span>
<span class="sd">        The order of the finite difference jacobian</span>
<span class="sd">    rtol: double [1e-8]</span>
<span class="sd">        The relative tolerance for perturbing the state vector to compute the</span>
<span class="sd">        finite difference jacobian</span>
<span class="sd">    atol: double [1e-15]</span>
<span class="sd">        The relative tolerance for perturbing the state vector to compute the</span>
<span class="sd">        finite difference jacobian</span>
<span class="sd">    mode: [&#39;f&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">        The mode of the Jacobian, forward (&#39;f&#39;), backwards (&#39;b&#39;) or central (&#39;c&#39;)</span>
<span class="sd">    jac_create: Callable</span>
<span class="sd">        The conditional Jacobian instruction creator from :mod:`instruction_creator`</span>
<span class="sd">    mem_limits: str [&#39;&#39;]</span>
<span class="sd">        Path to a .yaml file indicating desired memory limits that control the</span>
<span class="sd">        desired maximum amount of global / local / or constant memory that</span>
<span class="sd">        the generated pyjac code may allocate.  Useful for testing, or otherwise</span>
<span class="sd">        limiting memory usage during runtime. The keys of this file are the</span>
<span class="sd">        members of :class:`pyjac.kernel_utils.memory_limits.mem_type`</span>
<span class="sd">    kwargs: dict</span>
<span class="sd">        Arguements for the construction of the :class:`kernel_generator`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knl_list : list of :class:`knl_info`</span>
<span class="sd">        The generated infos for feeding into the kernel generator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># first we create a species rates kernel</span>
    <span class="n">sgen</span> <span class="o">=</span> <span class="n">rate</span><span class="o">.</span><span class="n">get_specrates_kernel</span><span class="p">(</span><span class="n">reacs</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span>
                                     <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">mem_limits</span><span class="o">=</span><span class="n">mem_limits</span><span class="p">)</span>
    <span class="n">sub_kernels</span> <span class="o">=</span> <span class="n">sgen</span><span class="o">.</span><span class="n">kernels</span><span class="p">[:]</span>

    <span class="c1"># figure out rates and info</span>
    <span class="n">rate_info</span> <span class="o">=</span> <span class="n">determine_jac_inds</span><span class="p">(</span><span class="n">reacs</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">rate_spec</span><span class="p">,</span>
                                   <span class="n">loopy_opts</span><span class="o">.</span><span class="n">jac_type</span><span class="p">)</span>

    <span class="c1"># create the namestore</span>
    <span class="n">namestore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">NameStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">rate_info</span><span class="p">,</span> <span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)</span>

    <span class="c1"># indicies</span>
    <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">initial_condition_dimension_vars</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># need to loop over all non-zero phi entries</span>
    <span class="n">mapstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">MapStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">phi_inds</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>

    <span class="c1"># next, define our FD coefficients</span>
    <span class="c1"># take from https://en.wikipedia.org/wiki/Finite_difference_coefficient</span>
    <span class="n">central_xcoeffs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                       <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                       <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                       <span class="mi">8</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]}</span>
    <span class="n">central_ycoeffs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
                       <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">12</span><span class="p">],</span>
                       <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">60</span><span class="p">],</span>
                       <span class="mi">8</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">280</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span> <span class="o">/</span> <span class="mi">105</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span> <span class="o">/</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">105</span><span class="p">,</span>
                           <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">280</span><span class="p">]}</span>
    <span class="n">fwd_xcoeffs</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)}</span>
    <span class="n">fwd_ycoeffs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                   <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">],</span>
                   <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">11</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">],</span>
                   <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">25</span> <span class="o">/</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span><span class="p">],</span>
                   <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">137</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">5</span><span class="p">],</span>
                   <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">49</span> <span class="o">/</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">15</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">15</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span> <span class="o">/</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">6</span><span class="p">]}</span>

    <span class="c1"># backwards xcoeffs are just the negative of the forward</span>
    <span class="n">bwd_xcoeffs</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fwd_xcoeffs</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fwd_xcoeffs</span><span class="p">}</span>
    <span class="c1"># and the y coeffs as well, as we are using a first derivative</span>
    <span class="n">bwd_ycoeffs</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fwd_ycoeffs</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fwd_xcoeffs</span><span class="p">}</span>

    <span class="n">coeffs</span> <span class="o">=</span> <span class="p">{</span><span class="n">FiniteDifferenceMode</span><span class="o">.</span><span class="n">forward</span><span class="p">:</span> <span class="p">(</span><span class="n">fwd_xcoeffs</span><span class="p">,</span> <span class="n">fwd_ycoeffs</span><span class="p">),</span>
              <span class="n">FiniteDifferenceMode</span><span class="o">.</span><span class="n">backward</span><span class="p">:</span> <span class="p">(</span><span class="n">bwd_xcoeffs</span><span class="p">,</span> <span class="n">bwd_ycoeffs</span><span class="p">),</span>
              <span class="n">FiniteDifferenceMode</span><span class="o">.</span><span class="n">central</span><span class="p">:</span> <span class="p">(</span><span class="n">central_xcoeffs</span><span class="p">,</span> <span class="n">central_ycoeffs</span><span class="p">)}</span>

    <span class="n">xcoeffs</span><span class="p">,</span> <span class="n">ycoeffs</span> <span class="o">=</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">ycoeffs</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xcoeffs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">order</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xcoeffs</span><span class="p">:</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">-mode finite-difference of order </span><span class="si">{}</span><span class="s1"> not defined, &#39;</span>
                         <span class="s1">&#39;available orders are: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">(),</span> <span class="n">order</span><span class="p">,</span>
                            <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xcoeffs</span><span class="p">)))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">xcoeffs</span> <span class="o">=</span> <span class="n">xcoeffs</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
    <span class="n">ycoeffs</span> <span class="o">=</span> <span class="n">ycoeffs</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

    <span class="n">phi_size</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">n_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># need to create a temporary variable to store the error weights</span>
    <span class="n">error_weights</span> <span class="o">=</span> <span class="n">lp</span><span class="o">.</span><span class="n">TemporaryVariable</span><span class="p">(</span><span class="s1">&#39;ewt&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">loopy_opts</span><span class="o">.</span><span class="n">order</span><span class="p">,</span>
                                         <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">phi_size</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                         <span class="n">scope</span><span class="o">=</span><span class="n">scopes</span><span class="o">.</span><span class="n">PRIVATE</span><span class="p">)</span>

    <span class="c1"># and the sum of error weights (needs to be a local for deep-vecs)</span>
    <span class="n">sumv</span> <span class="o">=</span> <span class="n">lp</span><span class="o">.</span><span class="n">TemporaryVariable</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="n">scopes</span><span class="o">.</span><span class="n">PRIVATE</span><span class="p">)</span>

    <span class="c1"># and finally the coeffs</span>
    <span class="n">xcoeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xcoeffs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arc</span><span class="o">.</span><span class="n">kint_type</span><span class="p">)</span>
    <span class="n">xcoeffs</span> <span class="o">=</span> <span class="n">lp</span><span class="o">.</span><span class="n">TemporaryVariable</span><span class="p">(</span><span class="s1">&#39;xcoeffs&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arc</span><span class="o">.</span><span class="n">kint_type</span><span class="p">,</span>
                                   <span class="n">initializer</span><span class="o">=</span><span class="n">xcoeffs</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">xcoeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                   <span class="n">scope</span><span class="o">=</span><span class="n">scopes</span><span class="o">.</span><span class="n">PRIVATE</span><span class="p">,</span>
                                   <span class="n">read_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">ycoeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ycoeffs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">ycoeffs</span> <span class="o">=</span> <span class="n">lp</span><span class="o">.</span><span class="n">TemporaryVariable</span><span class="p">(</span><span class="s1">&#39;ycoeffs&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="n">ycoeffs</span><span class="p">,</span>
                                   <span class="n">shape</span><span class="o">=</span><span class="n">ycoeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="n">scopes</span><span class="o">.</span><span class="n">PRIVATE</span><span class="p">,</span>
                                   <span class="n">read_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># and add to data</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">error_weights</span><span class="p">,</span> <span class="n">sumv</span><span class="p">,</span> <span class="n">xcoeffs</span><span class="p">,</span> <span class="n">ycoeffs</span><span class="p">])</span>
    <span class="n">sumv</span> <span class="o">=</span> <span class="n">sumv</span><span class="o">.</span><span class="n">name</span>

    <span class="c1"># create our extra loops</span>
    <span class="n">i_sum</span> <span class="o">=</span> <span class="s1">&#39;i_sum&#39;</span>
    <span class="n">i_copy</span> <span class="o">=</span> <span class="s1">&#39;i_copy&#39;</span>
    <span class="n">i_end</span> <span class="o">=</span> <span class="s1">&#39;i_end&#39;</span>
    <span class="c1"># copy and end use non-zero inds</span>
    <span class="n">nnz_phi</span> <span class="o">=</span> <span class="n">namestore</span><span class="o">.</span><span class="n">net_nonzero_phi</span>
    <span class="n">extra_inames</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i_sum</span><span class="p">,</span> <span class="s1">&#39;0 &lt;= </span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i_sum</span><span class="p">,</span> <span class="n">phi_size</span><span class="p">)),</span>
                    <span class="p">(</span><span class="n">i_copy</span><span class="p">,</span> <span class="s1">&#39;0 &lt;= </span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i_copy</span><span class="p">,</span> <span class="n">nnz_phi</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span>
                    <span class="p">(</span><span class="n">i_end</span><span class="p">,</span> <span class="s1">&#39;0 &lt;= </span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i_end</span><span class="p">,</span> <span class="n">nnz_phi</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;0 &lt;= k &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xcoeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span>

    <span class="c1"># start creating our variables</span>

    <span class="c1"># sum over all phi</span>
    <span class="n">phi_lp</span><span class="p">,</span> <span class="n">phi_isum</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">n_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">i_sum</span><span class="p">)</span>
    <span class="n">dphi_lp</span><span class="p">,</span> <span class="n">dphi_isum</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">n_dot</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">i_sum</span><span class="p">)</span>

    <span class="c1"># iterate over net non-zero phi (i.e. those w / non-zero derivatives)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">phi_str</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">n_arr</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>

    <span class="c1"># jacobian update</span>
    <span class="n">jac_var_template</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">_is_contiguous</span><span class="p">(</span><span class="n">nnz_phi</span><span class="p">):</span>
        <span class="c1"># need to add a map</span>
        <span class="n">nnz_phi_lp</span><span class="p">,</span> <span class="n">jac_var_template</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">nnz_phi</span><span class="p">,</span> <span class="n">jac_var_template</span><span class="p">)</span>
        <span class="n">kernel_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nnz_phi_lp</span><span class="p">)</span>

    <span class="c1"># dphi for the update instruction needs to be keyed on the same non-zero phi</span>
    <span class="c1"># index</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">dphi_copy</span> <span class="o">=</span> <span class="n">mapstore</span><span class="o">.</span><span class="n">apply_maps</span><span class="p">(</span><span class="n">namestore</span><span class="o">.</span><span class="n">n_dot</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span>
                                       <span class="n">jac_var_template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i_copy</span><span class="p">))</span>

    <span class="c1"># update the jacobian for this ycoeff * dphi</span>
    <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s1">&#39;$</span><span class="si">{jac_str}</span><span class="s1"> = $</span><span class="si">{jac_str}</span><span class="s1"> + ycoeffs[k] * $</span><span class="si">{dphi_copy}</span><span class="s1"> </span><span class="se">\</span>
<span class="s1">                       {id=update, dep=$</span><span class="si">{deps}</span><span class="s1">}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span>
                       <span class="n">dphi_copy</span><span class="o">=</span><span class="n">dphi_copy</span><span class="p">)</span>
    <span class="n">jac_lp</span><span class="p">,</span> <span class="n">jac_update_insn</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">jac_var_template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i_copy</span><span class="p">),</span>
        <span class="n">var_name</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;call_barrier&#39;</span><span class="p">,</span> <span class="n">insn</span><span class="o">=</span><span class="n">jac_update_insn</span><span class="p">)</span>
    <span class="c1"># finite difference division</span>
    <span class="n">jac_finite_diff_insn</span> <span class="o">=</span> <span class="s1">&#39;$</span><span class="si">{jac_str}</span><span class="s1"> = $</span><span class="si">{jac_str}</span><span class="s1"> / r </span><span class="se">\</span>
<span class="s1">                           {id=final, dep=$</span><span class="si">{deps}</span><span class="s1">, nosync=update}&#39;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">jac_finite_diff_insn</span> <span class="o">=</span> <span class="n">jac_create</span><span class="p">(</span>
        <span class="n">mapstore</span><span class="p">,</span> <span class="n">namestore</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">global_ind</span><span class="p">,</span> <span class="n">jac_var_template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i_end</span><span class="p">),</span>
        <span class="n">var_name</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="s1">&#39;update&#39;</span><span class="p">,</span> <span class="n">insn</span><span class="o">=</span><span class="n">jac_finite_diff_insn</span><span class="p">)</span>
    <span class="n">kernel_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">phi_lp</span><span class="p">,</span> <span class="n">dphi_lp</span><span class="p">,</span> <span class="n">jac_lp</span><span class="p">])</span>

    <span class="c1"># we will have to replace this during kernel creation, but for now we just</span>
    <span class="c1"># need to put a call</span>
    <span class="n">spec_rate_call</span> <span class="o">=</span> <span class="s1">&#39;dummy()&#39;</span>

    <span class="n">barrier</span> <span class="o">=</span> <span class="s1">&#39;... nop&#39;</span>
    <span class="n">mem_kind</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">depth</span><span class="p">:</span>
        <span class="n">barrier</span> <span class="o">=</span> <span class="s1">&#39;... lbarrier&#39;</span>
        <span class="n">mem_kind</span> <span class="o">=</span> <span class="s1">&#39;, mem_kind=global&#39;</span>

    <span class="c1"># now create our instructions</span>
    <span class="n">namer</span> <span class="o">=</span> <span class="n">UniqueNameGenerator</span><span class="p">()</span>

    <span class="c1"># initialize sum</span>
    <span class="n">sum_init</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    # get the base dphi</span>
<span class="s2">    $</span><span class="si">{spec_rate_call}</span><span class="s2"> {id=init}</span>
<span class="s2">    # get the error weights and original phi</span>
<span class="s2">    $</span><span class="si">{sumv}</span><span class="s2"> = 0 {id=sum_init}</span>
<span class="s2">    $</span><span class="si">{barrier}</span><span class="s2"> {id=sum_and_dphi_init, dep=sum_init:init$</span><span class="si">{mem_kind}</span><span class="s2">}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="c1"># convert to vecloop if needed</span>
    <span class="n">sum_init</span><span class="p">,</span> <span class="n">iname</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">place_in_vectorization_loop</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">sum_init</span><span class="p">,</span> <span class="n">namer</span><span class="p">,</span> <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iname</span><span class="p">:</span>
        <span class="n">extra_inames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iname</span><span class="p">)</span>

    <span class="c1"># error weight calculations</span>
    <span class="n">ewt_calcs</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    for $</span><span class="si">{i_sum}</span><span class="s2"></span>
<span class="s2">        ewt[$</span><span class="si">{i_sum}</span><span class="s2">] = ATOL + (RTOL * fabs($</span><span class="si">{phi_isum}</span><span class="s2">)) </span><span class="se">\</span>
<span class="s2">            {id=ewt, dep=*, nosync=change}</span>
<span class="s2">        $</span><span class="si">{sumv}</span><span class="s2"> = $</span><span class="si">{sumv}</span><span class="s2"> + (ewt[$</span><span class="si">{i_sum}</span><span class="s2">] * fabs($</span><span class="si">{dphi_isum}</span><span class="s2">)) * (</span><span class="se">\</span>
<span class="s2">            ewt[$</span><span class="si">{i_sum}</span><span class="s2">] * fabs($</span><span class="si">{dphi_isum}</span><span class="s2">)) </span><span class="se">\</span>
<span class="s2">            {id=sum, dep=*:sum_and_dphi_init:ewt}</span>
<span class="s2">    end</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">depth</span><span class="p">:</span>
        <span class="c1"># simply have each workitem run this</span>
        <span class="n">ewt_calcs</span><span class="p">,</span> <span class="n">iname</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">place_in_vectorization_loop</span><span class="p">(</span>
            <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">ewt_calcs</span><span class="p">,</span> <span class="n">namer</span><span class="p">,</span> <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">iname</span><span class="p">:</span>
            <span class="n">extra_inames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iname</span><span class="p">)</span>

    <span class="c1"># and finally the factor inits</span>
    <span class="n">fac_inits</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    &lt;&gt; fac = sqrt($</span><span class="si">{sumv}</span><span class="s2"> / $</span><span class="si">{phi_size}</span><span class="s2">.0) {dep=sum}</span>
<span class="s2">    &lt;&gt; r0 = 1000.0 * RTOL * DBL_EPSILON * $</span><span class="si">{phi_size}</span><span class="s2">.0 * fac</span>
<span class="s2">    &lt;&gt; srur = sqrt(DBL_EPSILON)</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="c1"># put in vecloop</span>
    <span class="n">fac_inits</span><span class="p">,</span> <span class="n">iname</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">place_in_vectorization_loop</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">fac_inits</span><span class="p">,</span> <span class="n">namer</span><span class="p">,</span> <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iname</span><span class="p">:</span>
        <span class="n">extra_inames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iname</span><span class="p">)</span>

    <span class="c1"># and join</span>
    <span class="n">pre_instructions</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">sum_init</span><span class="p">,</span> <span class="n">ewt_calcs</span><span class="p">,</span> <span class="n">fac_inits</span><span class="p">])</span>

    <span class="c1"># inner loop instructions</span>
    <span class="n">per_spec_fac</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    &lt;&gt; phi_orig = $</span><span class="si">{phi_str}</span><span class="s2"> {dep=*}</span>
<span class="s2">    &lt;&gt; r = fmax(srur * fabs(phi_orig), r0 / ewt[i])</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="c1"># put in vecloop</span>
    <span class="n">per_spec_fac</span><span class="p">,</span> <span class="n">iname</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">place_in_vectorization_loop</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">per_spec_fac</span><span class="p">,</span> <span class="n">namer</span><span class="p">,</span> <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iname</span><span class="p">:</span>
        <span class="n">extra_inames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iname</span><span class="p">)</span>

    <span class="c1"># phi update instruction in FD loop</span>
    <span class="n">phi_set</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    $</span><span class="si">{phi_str}</span><span class="s2"> = phi_orig + xcoeffs[k] * r {id=change, nosync=*}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">phi_set</span><span class="p">,</span> <span class="n">iname</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">place_in_vectorization_loop</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">phi_set</span><span class="p">,</span> <span class="n">namer</span><span class="p">,</span> <span class="n">vectorize</span><span class="o">=</span><span class="n">ic</span><span class="o">.</span><span class="n">use_atomics</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">iname</span><span class="p">:</span>
        <span class="n">extra_inames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iname</span><span class="p">)</span>
    <span class="c1"># add barrier to ensure broadcast to all work items</span>
    <span class="n">phi_set</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    $</span><span class="si">{phi_set}</span><span class="s2"></span>
<span class="s2">    $</span><span class="si">{barrier}</span><span class="s2"> {id=phi_set, dep=change$</span><span class="si">{mem_kind}</span><span class="s2">}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="c1"># and the species rate call</span>
    <span class="n">call</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    $</span><span class="si">{spec_rate_call}</span><span class="s2"> {id=inner_call, dep=phi_set}</span>
<span class="s2">    $</span><span class="si">{barrier}</span><span class="s2"> {id=call_barrier, dep=inner_call$</span><span class="si">{mem_kind}</span><span class="s2">}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="c1"># put in vecloop</span>
    <span class="n">call</span><span class="p">,</span> <span class="n">iname</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">place_in_vectorization_loop</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span> <span class="n">namer</span><span class="p">,</span> <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iname</span><span class="p">:</span>
        <span class="n">extra_inames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iname</span><span class="p">)</span>

    <span class="c1"># and reset the phi value to original</span>
    <span class="n">phi_reset</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s1">&#39;$</span><span class="si">{phi_str}</span><span class="s1"> = phi_orig {id=phi_reset, dep=*:update, &#39;</span>
                         <span class="s1">&#39;nosync=*}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">phi_reset</span><span class="p">,</span> <span class="n">iname</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">place_in_vectorization_loop</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">phi_reset</span><span class="p">,</span> <span class="n">namer</span><span class="p">,</span> <span class="n">vectorize</span><span class="o">=</span><span class="n">ic</span><span class="o">.</span><span class="n">use_atomics</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">iname</span><span class="p">:</span>
        <span class="n">extra_inames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iname</span><span class="p">)</span>

    <span class="c1"># put together all instructions</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    $</span><span class="si">{per_spec_fac}</span><span class="s2"></span>
<span class="s2">    for k</span>
<span class="s2">        $</span><span class="si">{phi_set}</span><span class="s2"></span>
<span class="s2">        $</span><span class="si">{call}</span><span class="s2"></span>
<span class="s2">        for $</span><span class="si">{i_copy}</span><span class="s2"></span>
<span class="s2">            $</span><span class="si">{jac_update_insn}</span><span class="s2"></span>
<span class="s2">        end</span>
<span class="s2">    end</span>
<span class="s2">    $</span><span class="si">{phi_reset}</span><span class="s2"></span>
<span class="s2">    for $</span><span class="si">{i_end}</span><span class="s2"></span>
<span class="s2">        $</span><span class="si">{jac_finite_diff_insn}</span><span class="s2"></span>
<span class="s2">    end</span>
<span class="s2">    $</span><span class="si">{barrier}</span><span class="s2"> {id=end, dep=final:phi_reset$</span><span class="si">{mem_kind}</span><span class="s2">}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

    <span class="c1"># set parameters</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;RTOL&#39;</span><span class="p">:</span> <span class="n">rtol</span><span class="p">,</span>
                  <span class="s1">&#39;ATOL&#39;</span><span class="p">:</span> <span class="n">atol</span><span class="p">,</span>
                  <span class="s1">&#39;DBL_EPSILON&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">}</span>

    <span class="c1"># specialization fixer</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">depth</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__fixer</span><span class="p">(</span><span class="n">knl</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">knl</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># need to split only good inames</span>
        <span class="k">def</span> <span class="nf">__fixer</span><span class="p">(</span><span class="n">knl</span><span class="p">):</span>
            <span class="n">vw</span> <span class="o">=</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">depth</span>
            <span class="k">if</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">has_scatter</span><span class="p">:</span>
                <span class="c1"># if we have a scatter operation, the copy and division loops</span>
                <span class="c1"># can be safely vectorized</span>
                <span class="n">can_vec</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i_copy</span><span class="p">,</span> <span class="n">i_end</span><span class="p">])</span>
                <span class="n">no_vec</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">can_vec</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
                <span class="n">no_vec</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i_copy</span><span class="p">,</span> <span class="n">i_end</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">iname</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">extra_inames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;(full|fake)_vec&#39;</span><span class="p">,</span> <span class="n">iname</span><span class="p">)</span> <span class="ow">or</span> <span class="n">iname</span> <span class="ow">in</span> <span class="n">can_vec</span><span class="p">:</span>
                    <span class="c1"># realize full vectorization</span>
                    <span class="n">knl</span> <span class="o">=</span> <span class="n">lp</span><span class="o">.</span><span class="n">split_iname</span><span class="p">(</span><span class="n">knl</span><span class="p">,</span> <span class="n">iname</span><span class="p">,</span> <span class="n">vw</span><span class="p">,</span> <span class="n">inner_tag</span><span class="o">=</span><span class="s1">&#39;l.0&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">iname</span> <span class="ow">in</span> <span class="n">no_vec</span><span class="p">:</span>
                    <span class="c1"># fake vectorization</span>
                    <span class="n">knl</span> <span class="o">=</span> <span class="n">lp</span><span class="o">.</span><span class="n">split_iname</span><span class="p">(</span><span class="n">knl</span><span class="p">,</span> <span class="n">iname</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inner_tag</span><span class="o">=</span><span class="s1">&#39;l.0&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">knl</span>

    <span class="c1"># create kernel info</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">knl_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;fd_jac&#39;</span><span class="p">,</span>
                          <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
                          <span class="n">pre_instructions</span><span class="o">=</span><span class="n">pre_instructions</span><span class="p">,</span>
                          <span class="n">mapstore</span><span class="o">=</span><span class="n">mapstore</span><span class="p">,</span>
                          <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
                          <span class="n">kernel_data</span><span class="o">=</span><span class="n">kernel_data</span><span class="p">,</span>
                          <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
                          <span class="n">can_vectorize</span><span class="o">=</span><span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">loopy_opts</span><span class="o">.</span><span class="n">depth</span><span class="p">),</span>
                          <span class="n">vectorization_specializer</span><span class="o">=</span><span class="n">__fixer</span><span class="p">,</span>
                          <span class="n">extra_inames</span><span class="o">=</span><span class="n">extra_inames</span><span class="p">,</span>
                          <span class="n">manglers</span><span class="o">=</span><span class="p">[</span><span class="n">lp_pregen</span><span class="o">.</span><span class="n">fmax</span><span class="p">(),</span>
                                    <span class="n">lp_pregen</span><span class="o">.</span><span class="n">MangleGen</span><span class="p">(</span><span class="s1">&#39;dummy&#39;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(),</span> <span class="nb">tuple</span><span class="p">())])</span>

    <span class="c1"># inputs and outputs</span>

    <span class="n">input_arrays</span><span class="p">,</span> <span class="n">output_arrays</span> <span class="o">=</span> <span class="n">inputs_and_outputs</span><span class="p">(</span><span class="n">conp</span><span class="p">)</span>

    <span class="c1"># and finally add a reset array</span>
    <span class="n">reset</span> <span class="o">=</span> <span class="n">reset_arrays</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">namestore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)</span>

    <span class="c1"># and barriers</span>
    <span class="n">barriers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">depth</span><span class="p">:</span>
        <span class="n">barriers</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;global&#39;</span><span class="p">))</span>

    <span class="c1"># and return the full generator</span>
    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">make_kernel_generator</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="o">=</span><span class="n">loopy_opts</span><span class="p">,</span>
        <span class="n">kernel_type</span><span class="o">=</span><span class="n">KernelType</span><span class="o">.</span><span class="n">jacobian</span><span class="p">,</span>
        <span class="n">kernels</span><span class="o">=</span><span class="p">[</span><span class="n">reset</span><span class="p">,</span> <span class="n">info</span><span class="p">],</span>
        <span class="n">namestore</span><span class="o">=</span><span class="n">namestore</span><span class="p">,</span>
        <span class="n">depends_on</span><span class="o">=</span><span class="p">[</span><span class="n">sgen</span><span class="p">],</span>
        <span class="n">input_arrays</span><span class="o">=</span><span class="n">input_arrays</span><span class="p">,</span>
        <span class="n">output_arrays</span><span class="o">=</span><span class="n">output_arrays</span><span class="p">,</span>
        <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span>
        <span class="n">fake_calls</span><span class="o">=</span><span class="p">{</span><span class="n">sgen</span><span class="p">:</span> <span class="n">spec_rate_call</span><span class="p">},</span>
        <span class="n">barriers</span><span class="o">=</span><span class="n">barriers</span><span class="p">,</span>
        <span class="n">mem_limits</span><span class="o">=</span><span class="n">mem_limits</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_jacobian_kernel"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.get_jacobian_kernel">[docs]</a><span class="k">def</span> <span class="nf">get_jacobian_kernel</span><span class="p">(</span><span class="n">reacs</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">mem_limits</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function that generates kernels for</span>
<span class="sd">       evaluation of analytical jacobian</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reacs : list of :class:`ReacInfo`</span>
<span class="sd">        List of species in the mechanism.</span>
<span class="sd">    specs : list of :class:`SpecInfo`</span>
<span class="sd">        List of species in the mechanism.</span>
<span class="sd">    loopy_opts : :class:`loopy_options` object</span>
<span class="sd">        A object containing all the loopy options to execute</span>
<span class="sd">    conp : bool</span>
<span class="sd">        If true, generate equations using constant pressure assumption</span>
<span class="sd">        If false, use constant volume equations</span>
<span class="sd">    test_size : int</span>
<span class="sd">        If not None, this kernel is being used for testing.</span>
<span class="sd">    mem_limits: str [&#39;&#39;]</span>
<span class="sd">        Path to a .yaml file indicating desired memory limits that control the</span>
<span class="sd">        desired maximum amount of global / local / or constant memory that</span>
<span class="sd">        the generated pyjac code may allocate.  Useful for testing, or otherwise</span>
<span class="sd">        limiting memory usage during runtime. The keys of this file are the</span>
<span class="sd">        members of :class:`pyjac.kernel_utils.memory_limits.mem_type`</span>
<span class="sd">    kwargs: dict</span>
<span class="sd">        Arguements for the construction of the :class:`kernel_generator`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kernel_gen : :class:`kernel_generator`</span>
<span class="sd">        The generator responsible for creating the resulting Jacobian code</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># figure out rates and info</span>
    <span class="n">rate_info</span> <span class="o">=</span> <span class="n">determine_jac_inds</span><span class="p">(</span><span class="n">reacs</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">rate_spec</span><span class="p">,</span>
                                   <span class="n">loopy_opts</span><span class="o">.</span><span class="n">jac_type</span><span class="p">)</span>

    <span class="c1"># create the namestore</span>
    <span class="n">nstore</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">NameStore</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">rate_info</span><span class="p">,</span> <span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="p">)</span>

    <span class="n">kernels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">barriers</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__add_knl</span><span class="p">(</span><span class="n">knls</span><span class="p">,</span> <span class="n">klist</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">klist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">klist</span> <span class="o">=</span> <span class="n">kernels</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">klist</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">knls</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="n">klist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">knls</span><span class="p">)</span>

    <span class="c1"># barrier management</span>
    <span class="k">def</span> <span class="nf">__insert_at</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">depth</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">knl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kernels</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">knl</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
                    <span class="n">barriers</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;global&#39;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">barriers</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ind</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;global&#39;</span><span class="p">))</span>

    <span class="c1"># Note:</span>
    <span class="c1"># the order in which these kernels get added is important</span>
    <span class="c1"># the kernel generator uses the input order to generate the wrapping</span>
    <span class="c1"># kernel calls</span>
    <span class="c1"># hence, any data dependencies should be expressed in the order added here</span>

    <span class="c1"># reset kernels</span>
    <span class="n">__add_knl</span><span class="p">(</span><span class="n">reset_arrays</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># first, add the species derivatives</span>

    <span class="n">allint</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;net&#39;</span><span class="p">:</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;net&#39;</span><span class="p">][</span><span class="s1">&#39;allint&#39;</span><span class="p">]}</span>

    <span class="c1"># insert a barrier to a) wait for the end of the species rates</span>
    <span class="c1"># and b) wait for the end of the jacobian reset</span>
    <span class="n">__insert_at</span><span class="p">(</span><span class="n">kernels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># rate of progress derivatives</span>
    <span class="n">__add_knl</span><span class="p">(</span><span class="n">dRopi_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">allint</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># and the third body / falloff derivatives</span>
    <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;thd&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
        <span class="n">__add_knl</span><span class="p">(</span><span class="n">dci_thd_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;fall&#39;</span><span class="p">][</span><span class="s1">&#39;lind&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
            <span class="n">__add_knl</span><span class="p">(</span>
                <span class="n">dci_lind_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;fall&#39;</span><span class="p">][</span><span class="s1">&#39;sri&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
            <span class="n">__add_knl</span><span class="p">(</span>
                <span class="n">dci_sri_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;fall&#39;</span><span class="p">][</span><span class="s1">&#39;troe&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
            <span class="n">__add_knl</span><span class="p">(</span>
                <span class="n">dci_troe_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># total spec heats</span>
    <span class="n">__add_knl</span><span class="p">(</span><span class="n">total_specific_energy</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># and thermo derivatives</span>
    <span class="n">__add_knl</span><span class="p">(</span><span class="n">thermo_temperature_derivative</span><span class="p">(</span>
        <span class="n">nstore</span><span class="o">.</span><span class="n">dspec_heat</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;rev&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
        <span class="n">__add_knl</span><span class="p">(</span><span class="n">thermo_temperature_derivative</span><span class="p">(</span>
            <span class="n">nstore</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># next, the temperature derivative w.r.t. species</span>
    <span class="n">__add_knl</span><span class="p">(</span><span class="n">dTdot_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span>
                        <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>
    <span class="c1"># (depends on total_specific_energy)</span>
    <span class="n">__insert_at</span><span class="p">(</span><span class="n">kernels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="c1"># and the extra var deriv</span>
    <span class="n">__add_knl</span><span class="p">(</span>
        <span class="n">dEdot_dnj</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>
    <span class="c1"># (depends on dTdot_dnj)</span>
    <span class="n">__insert_at</span><span class="p">(</span><span class="n">kernels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="c1"># temperature derivatives</span>
    <span class="n">__add_knl</span><span class="p">(</span><span class="n">dRopidT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># check for plog</span>
    <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;plog&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
        <span class="n">__add_knl</span><span class="p">(</span><span class="n">dRopi_plog_dT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span>
                                <span class="n">maxP</span><span class="o">=</span><span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;plog&#39;</span><span class="p">][</span><span class="s1">&#39;max_P&#39;</span><span class="p">],</span>
                                <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># check for chebyshev</span>
    <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;cheb&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
        <span class="n">__add_knl</span><span class="p">(</span><span class="n">dRopi_cheb_dT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span>
                                <span class="n">maxP</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;cheb&#39;</span><span class="p">][</span><span class="s1">&#39;num_P&#39;</span><span class="p">]),</span>
                                <span class="n">maxT</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;cheb&#39;</span><span class="p">][</span><span class="s1">&#39;num_T&#39;</span><span class="p">]),</span>
                                <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># check for third body terms</span>
    <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;thd&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
        <span class="n">__add_knl</span><span class="p">(</span><span class="n">dci_thd_dT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;fall&#39;</span><span class="p">][</span><span class="s1">&#39;lind&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
            <span class="n">__add_knl</span><span class="p">(</span>
                <span class="n">dci_lind_dT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;fall&#39;</span><span class="p">][</span><span class="s1">&#39;sri&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
            <span class="n">__add_knl</span><span class="p">(</span><span class="n">dci_sri_dT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;fall&#39;</span><span class="p">][</span><span class="s1">&#39;troe&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
            <span class="n">__add_knl</span><span class="p">(</span>
                <span class="n">dci_troe_dT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># total tempertature derivative</span>
    <span class="n">__add_knl</span><span class="p">(</span><span class="n">dTdotdT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>
    <span class="c1"># barrier for dnj / dT</span>
    <span class="n">__insert_at</span><span class="p">(</span><span class="n">kernels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="c1"># total extra var derivative w.r.t T</span>
    <span class="n">__add_knl</span><span class="p">(</span><span class="n">dEdotdT</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>
    <span class="c1"># barrier for dependency on dTdotdT</span>
    <span class="n">__insert_at</span><span class="p">(</span><span class="n">kernels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="c1"># finally, do extra var derivatives</span>
    <span class="n">__add_knl</span><span class="p">(</span><span class="n">dRopidE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># check for plog</span>
    <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;plog&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
        <span class="n">__add_knl</span><span class="p">(</span><span class="n">dRopi_plog_dE</span><span class="p">(</span>
            <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">maxP</span><span class="o">=</span><span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;plog&#39;</span><span class="p">][</span><span class="s1">&#39;max_P&#39;</span><span class="p">],</span>
            <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># check for cheb</span>
    <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;cheb&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
        <span class="n">__add_knl</span><span class="p">(</span><span class="n">dRopi_cheb_dE</span><span class="p">(</span>
            <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span>
            <span class="n">maxP</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;cheb&#39;</span><span class="p">][</span><span class="s1">&#39;num_P&#39;</span><span class="p">]),</span>
            <span class="n">maxT</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;cheb&#39;</span><span class="p">][</span><span class="s1">&#39;num_T&#39;</span><span class="p">]),</span>
            <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># and the third body / falloff derivativatives</span>
    <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;thd&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
        <span class="n">__add_knl</span><span class="p">(</span><span class="n">dci_thd_dE</span><span class="p">(</span>
            <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;fall&#39;</span><span class="p">][</span><span class="s1">&#39;lind&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
            <span class="n">__add_knl</span><span class="p">(</span>
                <span class="n">dci_lind_dE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;fall&#39;</span><span class="p">][</span><span class="s1">&#39;sri&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
            <span class="n">__add_knl</span><span class="p">(</span><span class="n">dci_sri_dE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span>
                                 <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">rate_info</span><span class="p">[</span><span class="s1">&#39;fall&#39;</span><span class="p">][</span><span class="s1">&#39;troe&#39;</span><span class="p">][</span><span class="s1">&#39;num&#39;</span><span class="p">]:</span>
            <span class="n">__add_knl</span><span class="p">(</span>
                <span class="n">dci_troe_dE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>

    <span class="c1"># and the temperature derivative w.r.t. the extra var</span>
    <span class="n">__add_knl</span><span class="p">(</span><span class="n">dTdotdE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>
    <span class="c1"># inser barrier for dnj / dE from the previous kernels</span>
    <span class="n">__insert_at</span><span class="p">(</span><span class="n">kernels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="c1"># total extra var derivative w.r.t the extra var</span>
    <span class="n">__add_knl</span><span class="p">(</span><span class="n">dEdotdE</span><span class="p">(</span><span class="n">loopy_opts</span><span class="p">,</span> <span class="n">nstore</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">))</span>
    <span class="c1"># barrier for dependency on dEdotdE</span>
    <span class="n">__insert_at</span><span class="p">(</span><span class="n">kernels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="n">input_arrays</span><span class="p">,</span> <span class="n">output_arrays</span> <span class="o">=</span> <span class="n">inputs_and_outputs</span><span class="p">(</span><span class="n">conp</span><span class="p">)</span>

    <span class="c1"># create the specrates subkernel</span>
    <span class="n">sgen</span> <span class="o">=</span> <span class="n">rate</span><span class="o">.</span><span class="n">get_specrates_kernel</span><span class="p">(</span><span class="n">reacs</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span>
                                     <span class="n">mem_limits</span><span class="o">=</span><span class="n">mem_limits</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)</span>
    <span class="n">sub_kernels</span> <span class="o">=</span> <span class="n">sgen</span><span class="o">.</span><span class="n">kernels</span><span class="p">[:]</span>
    <span class="c1"># and finally fix the barriers to account for the sub kernels</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_kernels</span><span class="p">)</span>
    <span class="n">barriers</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i1</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">i2</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bartype</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">bartype</span> <span class="ow">in</span> <span class="n">barriers</span><span class="p">]</span>
    <span class="c1"># and return the full generator</span>
    <span class="k">return</span> <span class="n">k_gen</span><span class="o">.</span><span class="n">make_kernel_generator</span><span class="p">(</span>
        <span class="n">loopy_opts</span><span class="o">=</span><span class="n">loopy_opts</span><span class="p">,</span>
        <span class="n">kernel_type</span><span class="o">=</span><span class="n">KernelType</span><span class="o">.</span><span class="n">jacobian</span><span class="p">,</span>
        <span class="n">kernels</span><span class="o">=</span><span class="n">sub_kernels</span> <span class="o">+</span> <span class="n">kernels</span><span class="p">,</span>
        <span class="n">namestore</span><span class="o">=</span><span class="n">nstore</span><span class="p">,</span>
        <span class="n">depends_on</span><span class="o">=</span><span class="p">[</span><span class="n">sgen</span><span class="p">],</span>
        <span class="n">input_arrays</span><span class="o">=</span><span class="n">input_arrays</span><span class="p">,</span>
        <span class="n">output_arrays</span><span class="o">=</span><span class="n">output_arrays</span><span class="p">,</span>
        <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span>
        <span class="n">barriers</span><span class="o">=</span><span class="n">barriers</span><span class="p">,</span>
        <span class="n">mem_limits</span><span class="o">=</span><span class="n">mem_limits</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_last_species"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.find_last_species">[docs]</a><span class="k">def</span> <span class="nf">find_last_species</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">last_spec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_map</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find a suitable species to move to the end of the mechanism, taking into account</span>
<span class="sd">    a user specified species, :param:`last_spec` if supplied.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the user does not specify a species, or it cannot be found the first species</span>
<span class="sd">    of Nitrogen (N_2), Argon (Ar) and Helium (He) found in the mechanism will be</span>
<span class="sd">    used. If none of these species can be found, the mechanism will be unchanged.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    specs: list of :class:`SpecInfo`</span>
<span class="sd">        The species in the mechanism</span>
<span class="sd">    last_spec: str [None]</span>
<span class="sd">        The name of the last species specified by the user</span>
<span class="sd">    return_map: bool [False]</span>
<span class="sd">        If True, return a mapping that can be used to map species / data</span>
<span class="sd">        for the mechanism, e.g.:</span>
<span class="sd">            ```</span>
<span class="sd">            map = find_last_species(specs, return_map=True)</span>
<span class="sd">            concs = concs[map]</span>
<span class="sd">            ```</span>
<span class="sd">        If false, an updated species list will be returned</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    map: list of :class:`SpecInfo` or :class:`numpy.ndarray`</span>
<span class="sd">        Depending on value of :param:`return_map`, returns an updated species list</span>
<span class="sd">        or mapping to achieve the same</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="c1"># check to see if the last_spec is specified</span>
    <span class="k">if</span> <span class="n">last_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># find the index if possible</span>
        <span class="n">isp</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">last_spec</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()),</span>
                   <span class="kc">None</span>
                   <span class="p">)</span>
        <span class="k">if</span> <span class="n">isp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;User specified last species </span><span class="si">{}</span><span class="s1"> not found in mechanism.&#39;</span>
                        <span class="s1">&#39;  Attempting to find a default species.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">last_spec</span><span class="p">))</span>
            <span class="n">last_spec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last_spec</span> <span class="o">=</span> <span class="n">isp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;User specified last species not found or not specified.  &#39;</span>
                    <span class="s1">&#39;Attempting to find a default species&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">last_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wt</span> <span class="o">=</span> <span class="n">chem</span><span class="o">.</span><span class="n">get_elem_wt</span><span class="p">()</span>
        <span class="c1"># check for N2, Ar, He, etc.</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;N2&#39;</span><span class="p">,</span> <span class="n">wt</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Ar&#39;</span><span class="p">,</span> <span class="n">wt</span><span class="p">[</span><span class="s1">&#39;ar&#39;</span><span class="p">]),</span>
                      <span class="p">(</span><span class="s1">&#39;He&#39;</span><span class="p">,</span> <span class="n">wt</span><span class="p">[</span><span class="s1">&#39;he&#39;</span><span class="p">])]</span>
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">isp</span> <span class="k">for</span> <span class="n">isp</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
                          <span class="k">if</span> <span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">and</span>
                          <span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">spec</span><span class="o">.</span><span class="n">mw</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">last_spec</span> <span class="o">=</span> <span class="n">match</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">last_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Default last species </span><span class="si">{}</span><span class="s1"> found.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">specs</span><span class="p">[</span><span class="n">last_spec</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">last_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Neither a user specified or default last species &#39;</span>
                    <span class="s1">&#39;could be found. Proceeding using the last species in the &#39;</span>
                    <span class="s1">&#39;base mechanism: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">specs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="n">last_spec</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">return_map</span><span class="p">:</span>
        <span class="n">gas_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">specs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arc</span><span class="o">.</span><span class="n">kint_type</span><span class="p">)</span>
        <span class="n">gas_map</span><span class="p">[</span><span class="n">last_spec</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">gas_map</span><span class="p">[</span><span class="n">last_spec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">gas_map</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_spec</span>
        <span class="k">return</span> <span class="n">gas_map</span>

    <span class="c1"># else, pick up the last_spec and drop it at the end</span>
    <span class="n">specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">specs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">last_spec</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">specs</span></div>


<div class="viewcode-block" id="create_jacobian"><a class="viewcode-back" href="../../../src/pyjac.core.create_jacobian.html#pyjac.create_jacobian">[docs]</a><span class="k">def</span> <span class="nf">create_jacobian</span><span class="p">(</span><span class="n">lang</span><span class="p">,</span> <span class="n">mech_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">therm_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ilp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">build_path</span><span class="o">=</span><span class="s1">&#39;./out/&#39;</span><span class="p">,</span> <span class="n">last_spec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">kernel_type</span><span class="o">=</span><span class="n">KernelType</span><span class="o">.</span><span class="n">jacobian</span><span class="p">,</span> <span class="n">platform</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                    <span class="n">data_order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">rate_specialization</span><span class="o">=</span><span class="n">RateSpecialization</span><span class="o">.</span><span class="n">full</span><span class="p">,</span>
                    <span class="n">split_rate_kernels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">split_rop_net_kernels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">conp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">data_filename</span><span class="o">=</span><span class="s1">&#39;data.bin&#39;</span><span class="p">,</span> <span class="n">output_full_rop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">use_atomic_doubles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_atomic_ints</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">jac_type</span><span class="o">=</span><span class="n">JacobianType</span><span class="o">.</span><span class="n">exact</span><span class="p">,</span>
                    <span class="n">jac_format</span><span class="o">=</span><span class="n">JacobianFormat</span><span class="o">.</span><span class="n">full</span><span class="p">,</span> <span class="n">for_validation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">fd_order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fd_mode</span><span class="o">=</span><span class="n">FiniteDifferenceMode</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span> <span class="n">mem_limits</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                    <span class="n">work_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">explicit_simd</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                    <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create Jacobian subroutine from mechanism.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lang : {&#39;c&#39;, &#39;opencl&#39;}</span>
<span class="sd">        Language type.</span>
<span class="sd">    mech_name : str, optional</span>
<span class="sd">        Reaction mechanism filename (e.g. &#39;mech.dat&#39;).</span>
<span class="sd">        This or gas must be specified</span>
<span class="sd">    therm_name : str, optional</span>
<span class="sd">        Thermodynamic database filename (e.g. &#39;therm.dat&#39;)</span>
<span class="sd">        or nothing if info in mechanism file.</span>
<span class="sd">    gas : cantera.Solution, optional</span>
<span class="sd">        The mechanism to generate the Jacobian for.  This or ``mech_name`` must be</span>
<span class="sd">        specified</span>
<span class="sd">    width : int</span>
<span class="sd">        If supplied, use a &#39;wide&#39; vectorization strategy.</span>
<span class="sd">        The SIMD vector-width to use.  If the targeted platform is a GPU,</span>
<span class="sd">        this is the GPU block size. Cannot be specified along with :param:`depth`.</span>
<span class="sd">    depth : int</span>
<span class="sd">        If supplied, use a &#39;deep&#39; vectorization strategy.</span>
<span class="sd">        The SIMD vector-width to use.  If the targeted platform is a GPU,</span>
<span class="sd">        this is the GPU block size. Cannot be specified along with :param:`width`.</span>
<span class="sd">    unr : int</span>
<span class="sd">        If supplied, unroll inner loops (i.e. those that would be affected by a</span>
<span class="sd">        deep vectorization). Can be used in conjunction with deep or wide parallelism</span>
<span class="sd">    build_path : str, optional</span>
<span class="sd">        The output directory for the jacobian files</span>
<span class="sd">    last_spec : str, optional</span>
<span class="sd">        If specified, the species to assign to the last index.</span>
<span class="sd">        Typically should be N2, Ar, He or another inert bath gas</span>
<span class="sd">    kernel_type : :class:`KernelType`</span>
<span class="sd">        The type of kernel to generate, defaults to Jacobian</span>
<span class="sd">    platform : {&#39;CPU&#39;, &#39;GPU&#39;, or other vendor specific name}</span>
<span class="sd">        The OpenCL platform to run on.</span>
<span class="sd">        *   If &#39;CPU&#39; or &#39;GPU&#39;, the first available matching platform will be used</span>
<span class="sd">        *   If a vendor specific string, it will be passed to pyopencl to get the</span>
<span class="sd">            platform</span>
<span class="sd">    data_order : {&#39;C&#39;, &#39;F&#39;}</span>
<span class="sd">        The data ordering, &#39;C&#39; (row-major) recommended for deep vectorizations,</span>
<span class="sd">        while &#39;F&#39; (column-major) recommended for wide vectorizations</span>
<span class="sd">    rate_specialization : {&#39;fixed&#39;, &#39;hybrid&#39;, &#39;full&#39;}</span>
<span class="sd">        The level of specialization in evaluating reaction rates.</span>
<span class="sd">        &#39;Full&#39; is the full form suggested by Lu et al. (citation)</span>
<span class="sd">        &#39;Hybrid&#39; turns off specializations in the exponential term (Ta = 0, b = 0)</span>
<span class="sd">        &#39;Fixed&#39; is a fixed expression exp(logA + b logT + Ta / T)</span>
<span class="sd">    split_rate_kernels : bool</span>
<span class="sd">        If True, and the :param&quot;`rate_specialization` is not &#39;Fixed&#39;, split different</span>
<span class="sd">        valuation types into different kernels</span>
<span class="sd">    split_rop_net_kernels : bool</span>
<span class="sd">        If True, break different ROP values (fwd / back / pdep) into different</span>
<span class="sd">        kernels</span>
<span class="sd">    conp : bool</span>
<span class="sd">        If True, use the constant pressure assumption.  If False, use the constant</span>
<span class="sd">        volume assumption.</span>
<span class="sd">    data_filename : str</span>
<span class="sd">        If specified, the path to the data.bin file that will be used for kernel</span>
<span class="sd">        testing</span>
<span class="sd">    output_full_rop : bool</span>
<span class="sd">        If ``True``, output forward and reversse rates of progress</span>
<span class="sd">        Useful in testing, as there are serious floating point errors for</span>
<span class="sd">        net production rates near equilibrium, invalidating direct comparison to</span>
<span class="sd">        Cantera</span>
<span class="sd">    use_atomic_doubles: bool [False]</span>
<span class="sd">        If True, the target language / platform can utilized atomic instructions</span>
<span class="sd">        for double precision floating point types.  This affects how deep-vectorized</span>
<span class="sd">        code is generated in pyJac -- if False, any potential data-races will</span>
<span class="sd">        be run in serial form, resulting in a poor vectorization.</span>
<span class="sd">    use_atomic_ints: bool [False]</span>
<span class="sd">        If True, the target language / platform can utilized atomic instructions</span>
<span class="sd">        for integer types.  This affects the driver kernel generated by pyJac.</span>
<span class="sd">        If True, the driver will be generated in &quot;queue&quot; form, and various threads</span>
<span class="sd">        may run without (weak) synchronziation. If False, the threads should run in</span>
<span class="sd">        &quot;lock-step&quot; form (e.g., the global size in OpenCL should be equal to the</span>
<span class="sd">        number of initial conditions).  :see:`Kernel Driver Types` for more</span>
<span class="sd">        information.</span>
<span class="sd">    jac_type: [&#39;exact&#39;, &#39;approximate&#39;, &#39;finite_difference&#39;]</span>
<span class="sd">        The type of Jacobian kernel to generate.</span>

<span class="sd">        An &#39;approximate&#39; Jacobian ignores derivatives of the last species with</span>
<span class="sd">        respect to other species in the mechanism --</span>
<span class="sd">        i.e. :math:`\frac{\partial n_{N_s}}{\partial n_{j}}` -- in the reaction rate</span>
<span class="sd">        derivatives.</span>

<span class="sd">        This can significantly increase sparsity for mechanisms containing reactions</span>
<span class="sd">        that include the last species directly, or as a third-body species with a</span>
<span class="sd">        non-unity efficiency, but gives results in an approxmiate Jacobian, and thus</span>
<span class="sd">        is more suitable to use with implicit integration techniques.</span>

<span class="sd">        Finally a &#39;finite_difference&#39; jacobian is computed using finite differences</span>
<span class="sd">        of the species rates kernel.  This is used internally for performance testing</span>
<span class="sd">        comparison, but is also available to the user if desired.</span>
<span class="sd">    jac_format: [&#39;full&#39;, &#39;sparse&#39;]</span>
<span class="sd">        If &#39;sparse&#39;, the Jacobian will be encoded using a compressed row or column</span>
<span class="sd">        storage format (for a data order of &#39;C&#39; and &#39;F&#39; respectively).</span>
<span class="sd">    for_validation: bool [False]</span>
<span class="sd">        If True, this kernel is being generated to validate pyJac, hence we need</span>
<span class="sd">        to save output data to a file</span>
<span class="sd">    fd_order: int [1]</span>
<span class="sd">        The order of the finite difference jacobian -- used if :param:`jac_type` ==</span>
<span class="sd">        &#39;finite_difference&#39;</span>
<span class="sd">    fd_mode: [&#39;forward&#39;, &#39;backward&#39;, &#39;central&#39;]</span>
<span class="sd">        The mode of the finite difference Jacobian, forward, backwards or central</span>
<span class="sd">        used if :param:`jac_type` == &#39;finite_difference&#39;</span>
<span class="sd">    mem_limits: str [&#39;&#39;]</span>
<span class="sd">        Path to a .yaml file indicating desired memory limits that control the</span>
<span class="sd">        desired maximum amount of global / local / or constant memory that</span>
<span class="sd">        the generated pyjac code may allocate.  Useful for testing, or otherwise</span>
<span class="sd">        limiting memory usage during runtime. The keys of this file are the</span>
<span class="sd">        members of :class:`pyjac.kernel_utils.memory_limits.mem_type`</span>
<span class="sd">    work_size: int [None]</span>
<span class="sd">        If specified, this is the number of thermo-chemical states that pyJac</span>
<span class="sd">        should evaluate concurrently in the generated source code. This option is</span>
<span class="sd">        most useful for coupling to an external library that that has already been</span>
<span class="sd">        parallelized, e.g., via OpenMP.</span>
<span class="sd">    explicit_simd: bool [False]</span>
<span class="sd">        If true, use explicit-SIMD instructions in OpenCL if possible.  Currently</span>
<span class="sd">        available for wide-vectorizations only.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># todo: fix, for some reason loopy yells about broken atomic dtypes</span>
    <span class="c1"># with no target</span>
    <span class="n">lp</span><span class="o">.</span><span class="n">set_caching_enabled</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">lang</span> <span class="o">=</span> <span class="n">lang</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lang</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">utils</span><span class="o">.</span><span class="n">langs</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Language needs to be one of: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">langs</span><span class="p">)))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># configure options</span>
    <span class="k">if</span> <span class="n">width</span> <span class="ow">and</span> <span class="n">depth</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Cannot apply both a wide and deep vectorization at the same &#39;</span>
                     <span class="s1">&#39;time&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">InvalidInputSpecificationException</span><span class="p">([</span><span class="s1">&#39;wide&#39;</span><span class="p">,</span> <span class="s1">&#39;deep&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">jac_type</span> <span class="o">==</span> <span class="n">JacobianType</span><span class="o">.</span><span class="n">finite_difference</span><span class="p">:</span>
        <span class="c1"># convert mode</span>
        <span class="n">fd_mode</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">EnumType</span><span class="p">(</span><span class="n">FiniteDifferenceMode</span><span class="p">)(</span>
            <span class="n">fd_mode</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

    <span class="c1"># load platform if supplied</span>
    <span class="n">device</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">device_type</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># todo: need to break out the platform &amp; command line spec</span>
    <span class="k">if</span> <span class="n">platform</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">platform</span><span class="p">):</span>
        <span class="c1"># todo -- add a copy func to loopy options to avoid this ugliness</span>
        <span class="n">loopy_opts</span> <span class="o">=</span> <span class="n">load_platform</span><span class="p">(</span><span class="n">platform</span><span class="p">)</span>
        <span class="n">checks</span> <span class="o">=</span> <span class="p">[(</span><span class="n">loopy_opts</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">data_order</span><span class="p">,</span> <span class="s1">&#39;order&#39;</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">loopy_opts</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="s1">&#39;width&#39;</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">loopy_opts</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="s1">&#39;depth&#39;</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">loopy_opts</span><span class="o">.</span><span class="n">lang</span><span class="p">,</span> <span class="n">lang</span><span class="p">,</span> <span class="s1">&#39;lang&#39;</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">loopy_opts</span><span class="o">.</span><span class="n">use_atomic_ints</span><span class="p">,</span> <span class="n">use_atomic_ints</span><span class="p">,</span> <span class="s1">&#39;use_atomic_ints&#39;</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">loopy_opts</span><span class="o">.</span><span class="n">use_atomic_doubles</span><span class="p">,</span> <span class="n">use_atomic_doubles</span><span class="p">,</span>
                   <span class="s1">&#39;use_atomic_doubles&#39;</span><span class="p">)]</span>
        <span class="n">bad_checks</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">checks</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bad_checks</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Parameters from supplied code-generation platform: &#39;</span>
                            <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">, do not match command-line arguements.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">platform</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">!=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bad_checks</span><span class="p">))</span>
        <span class="c1"># and copy over</span>
        <span class="n">data_order</span> <span class="o">=</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">order</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">width</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">depth</span>
        <span class="n">lang</span> <span class="o">=</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">lang</span>
        <span class="n">use_atomic_ints</span> <span class="o">=</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">use_atomic_ints</span>
        <span class="n">use_atomic_doubles</span> <span class="o">=</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">use_atomic_doubles</span>
        <span class="n">platform</span> <span class="o">=</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">platform</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">device</span>
        <span class="n">device_type</span> <span class="o">=</span> <span class="n">loopy_opts</span><span class="o">.</span><span class="n">device_type</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">platform</span> <span class="ow">and</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">&#39;opencl&#39;</span><span class="p">:</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;OpenCL platform not specified! &#39;</span>
                     <span class="s1">&#39;This must be supplied to generate wrapping code. &#39;</span>
                     <span class="s1">&#39;To determine the correct platform name, consult documentation.&#39;</span>
                     <span class="p">)</span>
        <span class="k">raise</span> <span class="n">InvalidInputSpecificationException</span><span class="p">(</span><span class="s2">&quot;platform&quot;</span><span class="p">)</span>

    <span class="c1"># create the loopy options</span>
    <span class="n">loopy_opts</span> <span class="o">=</span> <span class="n">lp_utils</span><span class="o">.</span><span class="n">loopy_options</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
                                        <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span>
                                        <span class="n">ilp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">unr</span><span class="o">=</span><span class="n">unr</span><span class="p">,</span>
                                        <span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">,</span>
                                        <span class="n">order</span><span class="o">=</span><span class="n">data_order</span><span class="p">,</span>
                                        <span class="n">rate_spec</span><span class="o">=</span><span class="n">rate_specialization</span><span class="p">,</span>
                                        <span class="n">rate_spec_kernels</span><span class="o">=</span><span class="n">split_rate_kernels</span><span class="p">,</span>
                                        <span class="n">rop_net_kernels</span><span class="o">=</span><span class="n">split_rop_net_kernels</span><span class="p">,</span>
                                        <span class="n">platform</span><span class="o">=</span><span class="n">platform</span><span class="p">,</span>
                                        <span class="n">use_atomic_ints</span><span class="o">=</span><span class="n">use_atomic_ints</span><span class="p">,</span>
                                        <span class="n">use_atomic_doubles</span><span class="o">=</span><span class="n">use_atomic_doubles</span><span class="p">,</span>
                                        <span class="n">jac_format</span><span class="o">=</span><span class="n">jac_format</span><span class="p">,</span>
                                        <span class="n">jac_type</span><span class="o">=</span><span class="n">jac_type</span><span class="p">,</span>
                                        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                                        <span class="n">device_type</span><span class="o">=</span><span class="n">device_type</span><span class="p">,</span>
                                        <span class="n">work_size</span><span class="o">=</span><span class="n">work_size</span><span class="p">,</span>
                                        <span class="n">explicit_simd</span><span class="o">=</span><span class="n">explicit_simd</span><span class="p">)</span>

    <span class="c1"># create output directory if none exists</span>
    <span class="n">build_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">build_path</span><span class="p">)</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">create_dir</span><span class="p">(</span><span class="n">build_path</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">mech_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">gas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;No mechanism specified!&#39;</span>

    <span class="c1"># Interpret reaction mechanism file, depending on Cantera or</span>
    <span class="c1"># Chemkin format.</span>
    <span class="k">if</span> <span class="n">gas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mech_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="s1">&#39;.cti&#39;</span><span class="p">,</span> <span class="s1">&#39;.xml&#39;</span><span class="p">])):</span>
        <span class="n">elems</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">reacs</span> <span class="o">=</span> <span class="n">mech</span><span class="o">.</span><span class="n">read_mech_ct</span><span class="p">(</span><span class="n">mech_name</span><span class="p">,</span> <span class="n">gas</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">elems</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">reacs</span> <span class="o">=</span> <span class="n">mech</span><span class="o">.</span><span class="n">read_mech</span><span class="p">(</span><span class="n">mech_name</span><span class="p">,</span> <span class="n">therm_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">specs</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;No species found in file: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mech_name</span><span class="p">))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">reacs</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;No reactions found in file: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mech_name</span><span class="p">))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># find and move last species to end</span>
    <span class="n">specs</span> <span class="o">=</span> <span class="n">find_last_species</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">last_spec</span><span class="o">=</span><span class="n">last_spec</span><span class="p">)</span>

    <span class="c1"># reassign the reaction&#39;s product / reactant / third body list</span>
    <span class="c1"># to integer indexes for speed</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">reassign_species_lists</span><span class="p">(</span><span class="n">reacs</span><span class="p">,</span> <span class="n">specs</span><span class="p">)</span>

    <span class="c1"># hidden optipn for testing issue where the backend would use the correctly</span>
    <span class="c1"># ordered gas and the command line would improperly re-order the species after</span>
    <span class="c1"># they had already been reassigned</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;test_mech_interpret_vs_backend&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">reacs</span><span class="p">,</span> <span class="n">specs</span>

    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Keyword arguments: </span><span class="si">{}</span><span class="s1"> not recognized!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">stringify_args</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">kwd</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
        <span class="k">raise</span> <span class="n">InvalidInputSpecificationException</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># check for reactions with potentially bad derivatives</span>
    <span class="n">bad_rxns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">irxn</span><span class="p">,</span> <span class="n">reac</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reacs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">reac</span><span class="o">.</span><span class="n">pdep_sp</span> <span class="ow">and</span> <span class="n">reac</span><span class="o">.</span><span class="n">pdep_sp</span> <span class="o">!=</span> <span class="n">last_spec</span><span class="p">:</span>
            <span class="n">bad_rxns</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">irxn</span><span class="p">,</span> <span class="n">reac</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">bad_rxns</span><span class="p">:</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">irxns</span><span class="p">,</span> <span class="n">rxns</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">bad_rxns</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Reactions (</span><span class="si">{}</span><span class="s1">) have third-body concentrations based on &#39;</span>
                    <span class="s1">&#39;species (</span><span class="si">{}</span><span class="s1">) that are not the selected last species (bath-gas).&#39;</span>
                    <span class="s1">&#39; This may result in very large Jacobian entries &#39;</span>
                    <span class="s1">&#39;(approaching infinite) if the concentrations of these species &#39;</span>
                    <span class="s1">&#39;are zero.  You may want to comment these reactions out of your &#39;</span>
                    <span class="s1">&#39;mechanism&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">irxns</span><span class="p">]),</span>
                                       <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">specs</span><span class="p">[</span><span class="n">rxn</span><span class="o">.</span><span class="n">pdep_sp</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
                                                  <span class="k">for</span> <span class="n">rxn</span> <span class="ow">in</span> <span class="n">rxns</span><span class="p">])))</span>

    <span class="c1"># write headers</span>
    <span class="n">aux</span><span class="o">.</span><span class="n">write_aux</span><span class="p">(</span><span class="n">build_path</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">reacs</span><span class="p">)</span>

    <span class="c1"># now begin writing subroutines</span>
    <span class="k">if</span> <span class="n">kernel_type</span> <span class="o">==</span> <span class="n">KernelType</span><span class="o">.</span><span class="n">jacobian</span> \
            <span class="ow">and</span> <span class="n">jac_type</span> <span class="o">!=</span> <span class="n">JacobianType</span><span class="o">.</span><span class="n">finite_difference</span><span class="p">:</span>
        <span class="c1"># get Jacobian subroutines</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="n">get_jacobian_kernel</span><span class="p">(</span><span class="n">reacs</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span>
                                  <span class="n">mem_limits</span><span class="o">=</span><span class="n">mem_limits</span><span class="p">)</span>
        <span class="c1">#  write_sparse_multiplier(build_path, lang, touched, len(specs))</span>
    <span class="k">elif</span> <span class="n">kernel_type</span> <span class="o">==</span> <span class="n">KernelType</span><span class="o">.</span><span class="n">jacobian</span> <span class="ow">and</span> \
            <span class="n">jac_type</span> <span class="o">==</span> <span class="n">JacobianType</span><span class="o">.</span><span class="n">finite_difference</span><span class="p">:</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="n">finite_difference_jacobian</span><span class="p">(</span><span class="n">reacs</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="p">,</span> <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span>
                                         <span class="n">mode</span><span class="o">=</span><span class="n">fd_mode</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">fd_order</span><span class="p">,</span>
                                         <span class="n">mem_limits</span><span class="o">=</span><span class="n">mem_limits</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kernel_type</span> <span class="o">==</span> <span class="n">KernelType</span><span class="o">.</span><span class="n">species_rates</span><span class="p">:</span>
        <span class="c1"># just specrates</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="n">rate</span><span class="o">.</span><span class="n">get_specrates_kernel</span><span class="p">(</span><span class="n">reacs</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="p">,</span>
                                        <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">output_full_rop</span><span class="o">=</span><span class="n">output_full_rop</span><span class="p">,</span>
                                        <span class="n">mem_limits</span><span class="o">=</span><span class="n">mem_limits</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kernel_type</span> <span class="o">==</span> <span class="n">KernelType</span><span class="o">.</span><span class="n">chem_utils</span><span class="p">:</span>
        <span class="c1"># just chem utils</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="n">rate</span><span class="o">.</span><span class="n">write_chem_utils</span><span class="p">(</span><span class="n">reacs</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">loopy_opts</span><span class="p">,</span>
                                    <span class="n">conp</span><span class="o">=</span><span class="n">conp</span><span class="p">,</span> <span class="n">mem_limits</span><span class="o">=</span><span class="n">mem_limits</span><span class="p">)</span>

    <span class="c1"># write the kernel</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">build_path</span><span class="p">,</span> <span class="n">data_filename</span><span class="o">=</span><span class="n">data_filename</span><span class="p">,</span>
                 <span class="n">for_validation</span><span class="o">=</span><span class="n">for_validation</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">kernel_type</span><span class="o">=</span><span class="n">KernelType</span><span class="o">.</span><span class="n">jacobian</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">pyJac</a></h1>



<p class="blurb">Python-based generator of analytical Jacobians for chemical kinetics</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=kyleniemeyer&repo=pyjac&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faqs.html">Frequently asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installing.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../src/index.html">pyJac API</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Nicholas Curtis, Kyle Niemeyer.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    
    <a href="https://github.com/kyleniemeyer/pyjac" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>